<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F09%2F20%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[正则表达式的意义作用假设用户需要在 HTML 表单中填写姓名、地址、出生日期等。那么在将表单提交到服务器进一步处理前，JavaScript 程序会检查表单以确认用户确实输入了信息并且这些信息是符合要求的。 因为客户端验证，可以节约大量的服务器端的系统资源，并且提供更好的用户体验。 正则表达式的创建方式创建正则表达式有两种方法，new运算符和字面量。 new运算符创建方式12var box = new RegExp('box'); var box = new RegExp('box', 'ig'); 第一个参数是模式字符串，第二个参数可选模式修饰符，顺序无所谓 模式修饰符可选参数： i ：忽略大小写 g ：全局匹配 m ：多行匹配 字面量创建方式12var box = /box/;var box = /box/ig; 直接用两个反斜杠 在第二个斜杠后面加上模式修饰符 测试正则表达式RegExp 对象包含两个方法：test()和 exec()，功能基本相似，用于测试字符串匹配。 test()方法：在字符串中测试模式匹配，返回 true 或 false exec()方法：在字符串中执行匹配搜索，返回结果数组，匹配不到返回null。 test()方法使用 new 运算符的 test() 方法示例，第一个区分大小写，第二个不区分大小写。 1234567var pattern = new RegExp('box'); var str = 'Box';alert(pattern.test(str)); //因为大小写不一致，所以返回false。var pattern = new RegExp('box', 'i'); var str = 'Box'; alert(pattern.test(str)); //返回true，因为'i'忽略大小写。 使用字面量方式的 test() 方法示例，不区分大小写。 123var pattern = /box/i; var str = 'This is a Box!';alert(pattern.test(str)); // true 字符串中是否包含模式中的正则（This is a Box!是否存在不区分大小写的box） 使用一条语句实现正则匹配 1alert(/box/i.test('This is a Box!')); exec()方法匹配了之后会返回数组，不匹配则返回null 123var pattern = /box/i;var str = 'This is a Box!';alert(pattern.exec(str)); // 返回的是box，是一个数组 下面的代码会返回整个字符串，但是数组格式，length值为1。 123var pattern = /^[a-z]+\s[0-9]&#123;4&#125;$/i;var str = 'google 2012';alert(pattern.exec(str)); 如果使用分组，返回的数组中，第一个是整个字符串，第二个是分组1匹配的内容，第三个是分组2匹配的内容。 12345var pattern = /^([a-z]+)\s([0-9]&#123;4&#125;)$/i; var str = 'google 2012';alert(pattern.exec(str)[0]); //google 2012alert(pattern.exec(str)[1]); //googlealert(pattern.exec(str)[2]); //2012 非捕获性分组 ?: 。在分组加上 ?: 就不会捕获到这个分组，所以数组只有两个元素。 1234var pattern = /^(?:[a-z]+)\s([0-9]&#123;4&#125;)$/i; var str = 'google 2012';alert(pattern.exec(str)[0]); //google 2012alert(pattern.exec(str)[1]); //2012 使用前瞻捕获 ?=。 123var pattern = /(goo(?=gle))/; //goo 后面必须跟着 gle 才能捕获goo并输出var str = 'google';alert(pattern.exec(str)); // goo 使用String的正则表达式方法（重点）除了 test() 和 exec() 方法，String对象也提供了 4 个使用正则表达式的方法。是String上的方法，不是正则表达式对象上的方法。但是也可以利用正则表达式来匹配数据。 String对象中的正则表达式方法： match(pattern)返回 pattern 中的子串或 null，就是查找功能 replace(pattern, replacement)用 replacement 替换 pattern search(pattern)返回字符串中 pattern 开始位置 split(pattern)返回字符串按指定 pattern 拆分的数组 match方法全局搜索，返回的是数组，如果不是全局就只返回第一个匹配到的 1234var pattern = /box/ig; var str = 'This is a Box!，That is a Box too';alert(str.match(pattern)); //匹配到两个 返回Box,box 是数组alert(str.match(pattern).length); //获取数组的长度 search方法search 方法查找到即返回，也就是说返回查找到的第一个匹配的位置，设置全局也没用。如果查找到返回位置，否则返回-1 123var pattern = /box/ig;var str = 'This is a Box!，That is a Box too';alert(str.search(pattern)); // 返回10，也就是Box在字符串的位置。 replace方法使用 replace 替换匹配到的数据，如果不开全局就只替换第一个查找到的。 123var pattern = /box/ig;var str = 'This is a Box!，That is a Box too';alert(str.replace(pattern, 'Tom')); // 将Box替换成了Tom。 split方法使用 split 拆分成字符串数组 123var pattern = / /ig;var str = 'This is a Box!，That is a Box too';alert(str.split(pattern)); //按空格拆开分组成数组。 RegExp对象的静态属性所谓静态属性就是直接调用无需创建实例，无需声明创建。但这里的静态和其他语言不同的是会打印出整个文件的静态地址，所以最好还是先创建实例再使用 静态属性用处不大，主要作为了解，因为兼容性不好 属 性 短 名 含 义 input $_ 当前被匹配的字符串 lastMatch $&amp; 最后一个匹配字符串 lastParen $+ 最后一对圆括号内的匹配子串 leftContext $` 最后一次匹配前的子串 multiline $* 用于指定是否所有的表达式都用于多行的布尔值 rightContext $’ 在上次匹配之后的子串 使用静态属性，以下所有的属性都可以用短名来代替属性名使用 12345678910111213var pattern = /google/;var str = 'This is google！';pattern.test(str); //执行一下，必须执行一下静态属性才有效。alert(RegExp.input); //This is google！ 如果匹配到了就返回该字符串alert(RegExp.leftContext); //This is 如果匹配了就返回匹配内容的左边的字符串alert(RegExp.rightContext); //！ 如果匹配了就返回匹配内容的右边的字符串alert(RegExp.lastMatch); //google 匹配到的最后一个字符串，有可能有多个，只会得到最后一个匹配到的var pattern = /(g)oogle/;var str = 'This is google！';pattern.test(str);alert(RegExp.lastParen); //g 得到圆括号内的匹配的 alert(RegExp.multiline); //false RegExp对象的实例属性和静态属性一样，同样也用处不多，只是了解一下。 属 性 含 义 global Boolean 值，表示 g 是否已设置 ignoreCase Boolean 值，表示 i 是否已设置 lastIndex 整数，代表下次匹配将从哪里字符位置开始 multiline Boolean 值，表示 m 是否已设置 Source 正则表达式的源字符串形式 使用实例属性 1234567891011var pattern = /google/ig;alert(pattern.global); //true，是否全局了alert(pattern.ignoreCase); //true，是否忽略大小写alert(pattern.multiline); //false，是否支持换行alert(pattern.lastIndex); //0，下次的匹配位置alert(pattern.source); //google，正则表达式的源字符串var pattern = /google/g;var str = 'google google google';pattern.test(str); //google，匹配第一次alert(pattern.lastIndex); //6，第二次匹配的位 RegExp对象的重复匹配这个是比较常用的正则 元字符/元符号 匹配情况 x? 匹配 0 个或 1 个 x x* 匹配 0 个或任意多个 x x+ 匹配至少一个 x (xyz)+ 匹配至少一个(xyz) x{m,n} 匹配最少 m 个、最多 n 个 x 12345678910111213141516171819202122232425262728293031323334353637383940var pattern = /go?gle/; // ? 匹配0个或1个ovar str = 'ggle';var str1 = 'google';var str2 = 'gooogle';alert(pattern.test(str)); // true 0个oalert(pattern.test(str1)); // true 1个oalert(pattern.test(str2)); // false 只能匹配0个或1个var pattern = /go*gle/; // * 匹配0个或任意多个ovar str = 'ggle';var str1 = 'goooooooooooogle';alert(pattern.test(str)); // true 0个oalert(pattern.test(str1)); // true 多个ovar pattern = /go+gle/; // + 匹配至少一个ovar str = 'ggle';var str1 = 'google';alert(pattern.test(str)); // false 至少一个o，所以没有为falsealert(pattern.test(str1)); // true 至少1个o就行var pattern = /go&#123;2，4&#125;gle/; // &#123;2，4&#125; 匹配2个到4个o，包含2和4var str = 'gogle';var str1 = 'google';var str2 = 'goooooogle';alert(pattern.test(str)); // false 小于&#123;2，4&#125;的区间alert(pattern.test(str1)); // true 在&#123;2，4&#125;的区间内alert(pattern.test(str2)); // false 大于&#123;2，4&#125;的区间var pattern = /go&#123;2&#125;gle/; // &#123;2&#125; 匹配2个o，var str = 'gogle';var str1 = 'google';alert(pattern.test(str)); // false 必须是2个o；alert(pattern.test(str1)); // true var pattern = /go&#123;2，&#125;gle/; // &#123;2，&#125; 匹配2个或2个以上ovar str = 'gogle';var str1 = 'goooooogle';alert(pattern.test(str)); // false 小于2个oalert(pattern.test(str1)); // true 只要大于等于2个o就行// 实际上用&#123;&#125;就可以模拟之前的元符号 RegExp对象的单个字符和数字这个是比较常用的正则 元字符/元符号 匹配情况 . 匹配除换行符外的任意字符 [a-z0-9] 匹配括号中的字符集中的任意字符 [^a-z0-9] 匹配任意不在括号中的字符集中的字符 \d 匹配数字 \D 匹配非数字，同[^0-9]相同 \w 匹配字母和数字及_ \W 匹配非字母和数字及_ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var pattern = /g..gle/ // . 匹配一个任意字符var str = 'google'; var str1 = 'guogle'var str2 = 'gogle';alert(pattern.test(str)) // true, . 可以匹配任意除了换行符外的字符alert(pattern.test(str1)) // true 同上alert(pattern.test(str2)) // false 一个 . 代表一位字符，所以位数要相同才行。 var pattern = /[a-z]oogle/; // [a-z] 匹配a-z的任意一个字符var str = 'foogle';var str1 = '5oogle';alert(pattern.test(str)); // true f包含在[a-z]alert(pattern.test(str1)); // false 数字不在范围内var pattern = /[0-9]oogle/; // [0-9] 匹配0-9任意一个数字var str = 'foogle';var str1 = '5oogle';alert(pattern.test(str)); // false 数字不在范围内alert(pattern.test(str1)); // true 5是0-9的数字var pattern = /[A-Z]oogle/; // [A-Z] 匹配A-Z任意一个字符var str = 'foogle';var str1 = 'Foogle';alert(pattern.test(str)); // false A-Z是大写alert(pattern.test(str1)); // truevar pattern = /[0-9a-zA-Z]oogle/; // [0-9a-zA-Z] 匹配0-9、a-z、A-Z范围内任意一个数字，基本上除了符号之外都匹配var str = 'foogle';var str1 = '5oogle';var str2 = 'Boogle';alert(pattern.test(str)); // truealert(pattern.test(str1)); // truealert(pattern.test(str2)); // truevar pattern = /[^0-9a-zA-Z]oogle/; // [^0-9a-zA-Z] 匹配非0-9、a-z、A-Z范围内的字符var str = 'foogle';var str1 = '5oogle';var str2 = '_oogle';alert(pattern.test(str)); // falsealert(pattern.test(str1)); // falsealert(pattern.test(str2)); // truevar pattern = /\doogle/; // \d 匹配数字var str = 'foogle';var str1 = '5oogle';alert(pattern.test(str)); // falsealert(pattern.test(str1)); // truevar pattern = /\Doogle/; // \D 匹配非数字var str = 'foogle';var str1 = '5oogle';alert(pattern.test(str)); // truealert(pattern.test(str1)); // falsevar pattern = /\woogle/; // \w 匹配字母和数字及_var str = '_oogle';var str1 = 'google';var str2 = '.oogle';alert(pattern.test(str)); // truealert(pattern.test(str1)); // truealert(pattern.test(str2)); // falsevar pattern = /\Woogle/; // \W 匹配非字母和数字及_var str = '_oogle';var str1 = 'google';var str2 = '.oogle';alert(pattern.test(str)); // falsealert(pattern.test(str1)); // falsealert(pattern.test(str2)); // true RegExp对象的空白字符 元字符/元符号 匹配情况 \b 匹配空格字符 \f 匹配进纸字符 \n 匹配换行符 \r 匹配回车字符 \t 匹配制表符 \s 匹配空白字符、空格、制表符和换行符 \S 匹配非空白字符 \s 是重点，匹配空白字符、空格、制表符和换行符,通常用来匹配空格 123var pattern = /goo\sgle/; var str = 'goo gle';alert(pattern.test(str)); // true RegExp对象的锚字符 元字符/元符号 匹配情况 ^ 行首匹配 $ 行尾匹配 \A 只有匹配字符串开始处 \b 匹配单词边界，词在[]内时无效 \B 匹配非单词边界 \G 匹配当前搜索的开始位置 \Z 匹配字符串结束处或行尾 \z 只匹配字符串结束处 ^ 和 &amp; 比较常用。^ 匹配以google开头的字符串。&amp; 匹配以google结尾的字符串。^ 和 &amp; 一起使用表示匹配整个被包裹的字符串。\b 匹配单词边界，词在 [] 内时无效。 1234567891011121314151617181920212223var pattern = /^google/; var str = 'google';var str1 = 'googleeeee';alert(pattern.test(str)); // truealert(pattern.test(str1)); // truevar pattern = /google$/; var str = 'google';var str1 = 'ggggggggoogle';alert(pattern.test(str)); // truealert(pattern.test(str1)); // truevar pattern = /^google$/; var str = 'google';var str1 = 'ggggggggoogle';alert(pattern.test(str)); // truealert(pattern.test(str1)); // false var pattern = /google\b/; var str = 'google';var str1 = 'googlefdsfef';alert(pattern.test(str)); // truealert(pattern.test(str1)); // false 这里e并不是在边界 RegExp对象的替代字符替代字符算是比较重要 元字符/元符号 匹配情况 this或where或logo 匹配 this 或 where 或 logo 中任意一个 12345var pattern = /google|baidu|soso/;var str = 'google';var str1 = 'soso';alert(pattern.test(str)); // truealert(pattern.test(str1)); // true RegExp对象的记录字符 元字符/元符号 匹配情况 (string) 用于反向引用的分组 \1 或$1 匹配第一个分组中的内容 \2 或$2 匹配第二个分组中的内容 \3 或$3 匹配第三个分组中的内容 () 是最常用的，() 分组就是将整个括起来的部分看成是一整个字符， 12345var pattern = /(google)(4,8)/; // 匹配google整个字符有4-8次，var str = 'googleeee';var str1 = 'googlegooglegooglegoogle';alert(pattern.test(str)); // false 判断整个google。alert(pattern.test(str1)); // true RegExp.$1 表示获取模式中第一个分组对括号应的匹配字符串，必须加括号 1234var pattern = /8(.*)8/; var str = 'this is a 8google8';pattern.test(str); // 这里必须运行一下才能用alert(RegExp.$1); // google $1 的用法，得到替换的字符串输出，替换的就是匹配到的第一组的匹配的字符 1234var pattern = /8(.*)8/; var str = 'This is 8google8';var res = str.replace(pattern,'&lt;strong&gt;$1&lt;/strong&gt;'); document.write(res); // google 组合用法，将两个分组的值替换输出 1234var pattern = /(.*)\s(.*)/; var str = 'google baidu';var res = str.replace(pattern, '$2 $1'); document.write(res); // baidu google 替换了两个值得位置 RegExp对象的贪婪和惰性模式贪婪就是什么都是我的，惰性就是节制一点，这是一种模式，并不是特指某个匹配符号，其实也就是一个量词。3 元字符/元符号 匹配情况 {} 字符出现的范围，{4,7}就是至少出现4次、最多出现7次 + 是至少出现一次，也可以写成 {1,} ? 是0次或者1次，也可以写成 {0,1} * 至少出现0次，也可以写成 {0,} 其中贪婪模式为：+ ? * {n} {n,} {n,m}。 惰性就是再这些符号后面加 ?。 123456789101112var pattern = /[a-z]+/; // +号是贪婪模式1个或多个var str = 'abcdefg';alert(str.replace(pattern,'1')); // 1,贪婪模式会将所有匹配[a-z]条件的字符替换成1，如果不是贪婪模式只会替换第一个。var pattern = /[a-z]+?/; // 贪婪模式后面加上?就是惰性模式。var str = 'abcdefg';alert(str.replace(pattern,'1')); // 1bcdefg, 惰性模式会将第一个匹配[a-z]条件的字符替换成1。var pattern = /8(.+?)8/g; //禁止了贪婪，开启了全局才能匹配三次，不然惰性模式只会匹配第一个var str = 'This is 8google8, That is 8google8, There is 8google8';var result = str.replace(pattern,'&lt;strong&gt;$1&lt;/strong&gt;');document.write(result); // 三个8google8替换为加粗的google。如果使用贪婪会匹配整个字符串的第一个8至最后一个8的内容，而使用惰性模式就只会匹配第一个8到下一个8之间的内容。 综合应用使用exec返回数组1234567891011121314151617181920var pattern = /^[a-z]+\s[0-9]&#123;4&#125;$/i;var str = 'google 2012';alert(pattern.exec(str)); //返回整个字符串，但是数组格式var pattern = /^([a-z]+)\s([0-9]&#123;4&#125;)$/i; //使用分组var str = 'google 2012';alert(pattern.exec(str)[0]); //google 2012alert(pattern.exec(str)[1]); //googlealert(pattern.exec(str)[2]); //2012// 返回的是数组，第一个是整个字符串，第二个是分组1匹配的内容，第三个是分组2匹配的内容，var pattern = /^(?:[a-z]+)\s([0-9]&#123;4&#125;)$/i; //非捕获性分组?:。var str = 'google 2012';alert(pattern.exec(str)[0]); //google 2012alert(pattern.exec(str)[1]); //2012// 在分组加上?:就不会捕获到这个分组，所以数组只有两个数据var pattern = /(goo(?=gle))/; //使用前瞻捕获。goo 后面必须跟着 gle 才能捕获goo并输出var str = 'google';alert(pattern.exec(str)); // goo 使用特殊字符匹配1234567var pattern = /[/; // 这样会报错，因为[是特殊字符var str = '[';var pattern = /\[/; //特殊字符，用\符号转义即可var str = '[';alert(pattern.test(str)) //true 使用换行模式123456789var pattern = /^\d+/g; //启用了全局模式var str = '1.baidu\n2.google\n3.bing'; // 这里用了换行,就是说一共三行var res = str.replace(pattern,"*");alert(res); // 这时即是用了全局也只能替换第一行,不会识别后两行var pattern = /^\d+/mg; //启用了全局模式+换行,m就是换行匹配的意思var str = '1.baidu\n2.google\n3.bing'; // 这里用了换行,就是说一共三行var res = str.replace(pattern, "*");alert(res); // 用了换行匹配后就能匹配到后几行的内容并替换 常用的正则表达式检查邮政编码123var pattern = /[1-9][0-9]&#123;5&#125;/; //共 6 位数字，第一位不能为 0var str = '224000';alert(pattern.test(str)); 检查文件压缩包123var pattern = /[\w]+\.zip|rar|gz/; //\w 表示所有数字和字母加下划线var str = '123.zip'; //\.表示匹配.，后面是一个选择alert(pattern.test(str)); 删除多余空格1234var pattern = /\s/g; //g 必须全局，才能全部匹配var str = '111 222 333';var result = str.replace(pattern,''); //把空格匹配成无空格alert(result); 删除首尾空格1234567891011121314151617var str = ' goo gle ';var res = str.replace(/^\s+/g,"").replace(/\s+$/g,"");alert('|' + res + '|');var pattern = /^\s*(.+?)\s*$/; //使用了非贪婪捕获var str = ' google ';alert('|' + pattern.exec(str)[1] + '|');var pattern = /^\s*(.+?)\s*$/;var str = ' google ';alert('|' + str.replace(pattern, '$1') + '|'); //使用了分组获取var pattern = /^\s*(.+?)\s*$/;var str = ' google ';alert('|' + str.replace(/^\s+|\s+$/g,"") + '|');// 使用或来去掉收尾空格 简单的电子邮件验证1234567var pattern = /^([a-zA-Z0-9_\.\-]+)@([a-zA-Z0-9_\.\-]+)\.([a-zA-Z]&#123;2,4&#125;)$/;var str = "yc60.com@gmail.com";alert(pattern.test(str));var pattern = /^([\w\.\-]+)@([\w\.\-]+)\.([\w]&#123;2,4&#125;)$/;var str = 'yc60.com@gmail.com';alert(pattern.test(str));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cookie基础]]></title>
      <url>%2F2017%2F09%2F20%2FCookie%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[Cookie的原理服务器记录用户上次的登录信息，服务器需要一个类似橱柜的空间存储，橱柜的每个区域要通过钥匙才能打开。 钥匙存储在用户的计算机上，要取信息相当于拿着钥匙去访问服务器。钥匙上有个id号，通过这个id号就知道是哪个柜子的钥匙，这样就能拿到柜子里面的数据。 用户手上的这把钥匙就叫做Cookie。 我们需要Cookie的原因是http协议是一种无状态的协议，服务器从网络连接上无法获知用户身份，那就只能给每个用户一把钥匙。 session就是保存用户数据的橱柜，保存在服务端。要记录用户登录的状态信息，也就是存储在session。 Cookie的过程 浏览器发送了一个请求，这个过程中做了一个封装请求报文。转成二进制，通过tcp协议传输层传输给服务器。 在服务器解析，将二进制数据转换请求报文。通过url和请求方式做对应处理。 中间件是架设在一次请求与相应之间做的事情。请求过来之后session是接收请求后，将响应做了加工。在响应头添加了一个字段set-cookie: …… 。客户端会接受到相应的响应报文。 客户端浏览器在接收到set-cookie的时候会在客户端生成一个文件，里面的内容是connect.sid=………。本次连接结束。 这个sid就代表了橱柜的id值。再一次访问，浏览器会根据域来找到对应的cookie，把内容加入请求头。 带着cookie去访问网页，就可以用cookie带着的sid去找到存在网站的相应的session信息。 cookie是一个技术。session是基于该技术，通过connect.sid找到对应的数据 查看某个网站颁发的Cookie在Console中输入JavaScript:alert (document. cookie)就可以了（需要有网才能查看）。 JavaScript浏览器会弹出一个对话框显示本网站颁发的所有Cookie的内容。 Cookie的所有属性String name该Cookie的名称。Cookie一旦创建，名称便不可更改 Object value该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码 int maxAge该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为–1 boolean secure该Cookie是否仅被使用安全协议传输。安全协议。安全协议有HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false String path该Cookie的使用路径。如果设置为“/sessionWeb/”，则只有contextPath为“/sessionWeb”的程序可以访问该Cookie。如果设置为“/”，则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为“/” String domain可以访问该Cookie的域名。如果设置为“.google.com”，则所有以“google.com”结尾的域名都可以访问该Cookie。注意第一个字符必须为“.” String comment该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明 int version该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC 2109规范 Cookie的有效期Cookie的 maxAge 决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge() 方法与 setMaxAge(int maxAge) 方法来读写maxAge属性。 如果 maxAge 属性为正数，则表示该Cookie会在 maxAge 秒之后自动失效。浏览器会将 maxAge 为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在 maxAge 秒之前，登录网站时该Cookie仍然有效。下面代码中的Cookie信息将永远有效。 123Cookie cookie = new Cookie("username","helloweenvsfei"); // 新建Cookiecookie.setMaxAge(Integer.MAX_VALUE); // 设置生命周期为MAX_VALUEresponse.addCookie(cookie); // 输出到客户端 如果 maxAge 为负数，则表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效。maxAge 为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中。Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的 maxAge 值为–1。 如果 maxAge 为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置该Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除。 123Cookie cookie = new Cookie("username","helloweenvsfei"); // 新建Cookiecookie.setMaxAge(0); // 设置生命周期为0，不能为负数response.addCookie(cookie); // 必须执行这一句 Cookie的修改、删除Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，添加到response中覆盖原来的Cookie。 如果要删除某个Cookie，只需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。负数代表其他的意义。读者可以通过上例的程序进行验证，设置不同的属性。 Cookie的域名Domain就是域，根据域来选择相应Cookie，域Domain的值是网站的地址。 Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。 浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie 正常情况下，同一个一级域名下的两个二级域名如www.google.com和images.google.com也不能交互使用Cookie，因为二者的域名并不严格相同。如果想所有google.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数，例如： 12345Cookie cookie = new Cookie("time","20080808"); // 新建Cookiecookie.setDomain(".helloweenvsfei.com"); // 设置域名cookie.setPath("/"); // 设置路径cookie.setMaxAge(Integer.MAX_VALUE); // 设置有效期response.addCookie(cookie); // 输出到客户端 Cookie的路径Domain属性决定运行访问Cookie的域名，而path属性决定允许访问Cookie的路径（ContextPath）。例如，如果只允许/sessionWeb/下的程序使用Cookie，可以这么写： 123Cookie cookie = new Cookie("time","20080808"); // 新建Cookiecookie.setPath("/session/"); // 设置路径response.addCookie(cookie); // 输出到客户端 设置为“/”时允许所有路径使用Cookie。path属性需要使用符号“/”结尾。name相同但domain相同的两个Cookie也是两个不同的Cookie。 注意：页面只能获取它属于的Path的Cookie。例如/session/test/a.jsp不能获取到路径为/session/abc/的Cookie。使用时一定要注意。 Cookie的安全属性HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被截获的可能。 使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。下面的代码设置secure属性为true： 123Cookie cookie = new Cookie("time", "20080808"); // 新建Cookiecookie.setSecure(true); // 设置安全属性response.addCookie(cookie); // 输出到客户端 提示：secure属性并不能对Cookie内容加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密 JavaScript操作CookieCookie是保存在浏览器端的，因此浏览器具有操作Cookie的先决条件。浏览器可以使用脚本程序如JavaScript或者VBScript等操作Cookie。 这里以JavaScript为例介绍常用的Cookie操作。例如下面的代码会输出本页面所有的Cookie。 1&lt;script&gt;document.write(document.cookie);&lt;/script&gt; 由于JavaScript能够任意地读写Cookie，有些好事者便想使用JavaScript程序去窥探用户在其他网站的Cookie。不过这是徒劳的，W3C组织早就意识到JavaScript对Cookie的读写所带来的安全隐患并加以防备了，W3C标准的浏览器会阻止。 JavaScript读写任何不属于自己网站的Cookie。换句话说，A网站的JavaScript程序读写B网站的Cookie不会有任何结果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVN]]></title>
      <url>%2F2017%2F09%2F20%2FSVN%2F</url>
      <content type="text"><![CDATA[VisualSVNSVN服务器：运行Subversion服务的计算机。 SVN服务器分为命令行工具和图形化工具，VisualSvn就是一款图形化工具。 安装时，默认使用443端口，如果被占用了就换成8443。 创建用户或组在Users右键选择Create User，创建用户。 创建版本库及设定权限一般每个项目对应一个版本库 步骤： 在Repositories右键Create New Repositories，创建一个新项目。 在Repositories name步骤输入项目名称。 在Repositories Structure步骤选择仓库结构，Empty是指空仓库。 在Repositories Access Permissions步骤选择权限，Nobody是没有人能访问，All Subversion是所有用户有读和写的全选，Customize是自定义用户和其权限。 TortoiseSVNSVN的客户端，用户通过SVN客户端同步服务器交互，TortoiseSVN是一款图形化工具。 如果在文件夹单机鼠标右键有TortoiseSVN选项就是安装成功了。 SVN基本协作流程客户端在操作之前要先走一些流程，这里有一些名词： 检出项目：checkout 增加文件或目录：add(增加)，commit(提交)。 修改文件或目录：commit(提交)。 删除文件或目录：commit(提交)。 更新文件或目录：updata(更新)。 查看版本日志：log(日志)。 检出操作在本地文件夹中右键选择SVN Checkout选项。从服务器把代码下载下来。 在URL of repository填入仓库地址。 在VisualSVN中的项目右键选择Copy URL to Clipboard将地址复制出来去粘贴。 在CHeckout directory选择检出的本地目录。 在Checkout Depth中选择深度，Fully recursive是把项目全部下载。 Revison是表选择哪个版本，HEAD revison是最新的版本。 接下来需要输入账号密码完成操作。 操作完成后，当前操作的文件夹中右键就不会再有SVN Checkout选项。已经执行过一遍了就不会再有了 更新操作文件夹鼠标右键选择SVN Updata操作即可从服务器更新最新版本的代码。 当修改了源代码，客户端要先把修改的文件通过在修改后的文件上右键TortoiseSVN — ‘add’操作把文件添加到待提交列表中。 只有新建的文件需要手动add操作，增删改之后的文件都不需要手动add。 接下来通过在文件夹中右键 SVN commit 操作把待提交列表中的项目提交到远程仓库中。提交时Message是填写提交日志的。 在提交之前一定要记得先updata，目的是避免和别人冲突。 查看版本日志在文件夹的空白处右键TortoiseSVN—show log操作查看。 更新到某个版本在需要更新的文件右键TortoiseSVN—updata to revision。HEAD revision是最新版本，Revision是选择版本，点击show log选择。最后确定。 可以随时恢复到之前的版本。 解决冲突当别人改好了文件commit之后我这里也在编辑相同的文件，这时我更改完了准备提交，而服务器上的文件已经改变，那么提交前Updata时会有错误Conflicted提示是哪个文件，此时不能点ok。 会生成两个文件，一个是本地的版本，一个是服务器的版本。 解决冲突就是在文件夹空白处右键TortoiseSVN—Resolve，双击打开冲突的文件。 左边的Theirs是他们的，右边的Mine是我的。黄色的部分是冲突部分，红色是冲突的内容。 选择Theirs或Mine右键选择use this txt block就是选择用这个版本的。还可以选择Mine在Theirs之前或者Theirs在Mine之前。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新增API介绍]]></title>
      <url>%2F2017%2F09%2F20%2FHTML5%20%20%E6%96%B0%E5%A2%9EAPI%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[文件读取javascript 阻止读取本地文件浏览器是不允许JS读取本地文件的，也就是用户电脑本地的文件。这是出于安全的考虑。 但是有的时候需要这种功能，上传图片预览 实际场景就是qq空间。 传统的上传是通过flash上传至服务器，服务器将上传后的地址返回给浏览器，然后让js通过dom操作添加到图片标签上。 缺点是如果上传的图片不合适，重新上传就要再走一个这个步骤，而且之前上传的图片也不会被删除，会存在服务器上。 FileList通过 FileList 对象，可以让js直接读取本地文件，将读取到的文件放到页面上。不经过服务器，不需要网络 FileList 对象存储文件的信息。支持多个文件上传。 上传一个文件查看FileList的信息1&lt;input type="file" multiple class="file"/&gt; 123456789101112// 获取上传的表单var file = document.querySelector('.file');// 选择文件打开之后会触发change事件,也就是检测表单的变化，有改变就会触发file.onchange = function()&#123;for(var k in this)&#123; console.log(k + '===' + this[k]); // 查看该dom对象的属性和值&#125;console.log(this.files); // 其中有个属性是files，记录着文件信息(FileList对象)// 因为是列表，所以会有多个信息，属性是索引数字，值是文件信息&#125; FileReader是html5的内建对象，也就是说使用时需要new一下，也叫文件读取器，负责读取本地文件。比如图片就是将图片处理成了base64编码格式，代替url地址。 上传一个图片显示在页面上12&lt;input type="file" multiple class="file"/&gt;&lt;img src="" alt="" id="img"/&gt; 1234567891011121314// 获取上传的表单var file = document.querySelector('.file');file.onchange = function()&#123; var file = this.files[0]; // 获取第一个文件 var fileReader = new FileReader(); // 文件有的以二进制形式存在，有的以字符串形式存在。readAsDataURL()就是把文件以DataURL形式读取 fileReader.readAsDataURL(file); // onload 事件监听，当文件读取完成时调用，比如文件有好几兆，读取需要花时间 fileReader.onload = function()&#123; // 读取完之后会将文件编译后的内容保存在result中，要放到页面上只能是readAsDataURL格式 document.querySelector('#img').src = this.result; &#125;&#125; 全屏让网页内容以一个全屏的形式展现，也可以是图片等元素 Node.requertFullScreen() 开启全屏显示 Node.cancelFullScreen() 关闭全屏显示 Node.IsFullScreen 检测是否是全屏 是属性不是方法 返回true或者false 由于其兼容性原因。不同浏览器需要添加前缀。 webkitRequertFullScreen mozRequertFullScreen 让整个html文档全屏的步骤123456789.box&#123; width: 200px; height: 200px; background-color: pink;&#125;/*全屏伪类，当整个文档全平时，把盒子改为蓝色*/:-webkit-full-screen .box&#123; background-color: blue;&#125; 12345&lt;div class="box"&gt; &lt;input type="button" class="open" value="全屏"/&gt; &lt;input type="button" class="cancel" value="关闭"/&gt; &lt;input type="button" class="check" value="是否全屏"/&gt;&lt;/div&gt; 1234567891011121314151617var open = document.querySelector('.open');var cancel = document.querySelector('.cancel');var check = document.querySelector('.check');var box = document.querySelector('.box');open.onclick = function()&#123; // 获取整个dom文档节点，并让整个文档全屏 document.documentElement.webkitRequestFullScreen();&#125;cancel.onclick = function()&#123; // 在关闭窗口时不是节点了，而是使用document。 document.webkitCancelFullScreen();&#125;check.onclick = function()&#123; document.webkitIsFullScreen;&#125; 让div全屏的效果的步骤123456789.box&#123; width: 200px; height: 200px; background-color: pink;&#125;/*全屏伪类，当盒子处于全屏状态时会颜色改为蓝色,类似.box:hover*/.box:-webkit-full-screen&#123; background-color: blue;&#125; 12345&lt;div class="box"&gt; &lt;input type="button" class="open" value="全屏"/&gt; &lt;input type="button" class="cancel" value="关闭"/&gt; &lt;input type="button" class="check" value="是否全屏"/&gt;&lt;/div&gt; 12345678910111213141516var open = document.querySelector('.open');var cancel = document.querySelector('.cancel');var check = document.querySelector('.check');var box = document.querySelector('.box');open.onclick = function()&#123; // 让普通盒子全屏，盒子的宽高不变，空白区域都是黑色，但是可以通过css伪类选择器解决 box.webkitRequestFullScreen();&#125;cancel.onclick = function()&#123; // 关闭普通盒子也是这个，而不是节点 document.webkitCancelFullScreen();&#125;check.onclick = function()&#123; document.webkitIsFullScreen;&#125; 地理定位获取用户当前的地理信息，可以向用户推送一些服务，给用户周边的商家带来消费 基于位置的服务LBS（Location Base Service） navigator想获取地理信息是通过BOM进行获取的，也就是指的浏览器 通过 navigator，这个对象存储着和浏览器相关的一些信息，userAgent 比较常用，记录浏览器版本、内核信息 navigator.geolocation 是html5新增的获取地理位置的对象 此对象对应着两个方法： getCurrentPosition() 获取当前的位置信息，只获取一次 WatchPosition() 持续的获取位置信息，比如导航 使用方法介绍12345678// 需要两个回调方法，一个表示成功，一个表示失败navigator.geolocation.getCurrentPosition(success,error);function success()&#123;&#125;function error(err)&#123; console.log(err);&#125; 失败原因 在谷歌浏览器下要想使用地理定位必须要以服务器的方式访问。 用谷歌浏览器时，在获取位置信息时需要谷歌的一个服务，但是谷歌浏览器在国内会被墙。 但是在手机上的浏览器没问题，因为手机有gps，浏览器在获取用户地理位置时是有多种途径的.可以通过wifi、ip、GPS，依次检测，看看哪个能获取到。 ####实际开发案例 在实际开发中，根据api的文档来做，这里以百度为例 1&lt;div id="container"&gt;&lt;/div&gt; 用百度地图的话，需要传递一个参数给这个url，注册成为开发者，获取AK值 1&lt;script src="http://api.map.baidu.com/api?v=2.0&amp;ak=ak的值"&gt;&lt;/script&gt; 在真正的实际开发中，geolocation只是获得用户的当前位置信息，但要发挥作用还是要借助第三方的服务器，比如百度地图的api。 也就是通过这个方法获取用户的地理信息，传给百度地图，然后百度地图帮我们生成地图图像。 12345678910111213141516171819// 第一个函数表示成功的回调，在函数里传递一个参数，这个参数记录了地理位置信息navigator.geolocation.getCurrentPosition(function(position)&#123; var latitude = position.coords.latitude; // 纬度 var longitude = position.coords.longitude // 纬度 // 查看地理信息 console.log(position); // 这些都是写死的，使用百度地图的固定写法 var map = new BMap.Map("container"); // div的id值，将地图放到这个盒子里，把经纬度传给百度 var point = new BMap.Point(latitude,longitude); // 居中并且缩放经纬度 map.centerAndZoom(point,15); // 写到这里就可以出现地图了，并且会定位 // 定义一个图片标记，本地传递一个图片，设定一个尺寸 var myIcon = new BMap.Icon("http://developer.baidu.com/map/jsdemo/img/fox.gif"),new BMap.Size(300,157)); // 创建标注、调用方法 var marker = new BMap.Marker(point,&#123;icon:myIcon&#125;); map.addOverlay(marker);&#125;) 网络状态可以监听网络是处于联网状态还是断网状态，应用场景：当前网络不佳的提示 online和offline监听在线的是事件 online 离线是 offline，要绑定在window上 使用方法12345678// 当设备联网的时候会触发。window.addEventListener('online',function()&#123; alert('网络已连接');&#125;)// 当设备断开网络会触发。window.addEventListener('offline',function()&#123; alert('网络已断开');&#125;) 历史管理history针对BOM的 window.history 对象我们可以管理历史记录。 可用于单页面应用(SPA(Single Page Application) ，无刷新改变页面内容，模仿原生app。 在DOM操作中，通过按钮更改页面的内容后，一刷新后还是按钮之前的样子，有的网站刷新后不变就是通过历史管理来实现的 更改href1&lt;input type="button" value="看地址变没变" id="btn"/&gt; 12345var btn = document.getElementById('btn');// 地址发生变化，页面刷新了btn.onclick = function()&#123; location.href = 'http://www.baidu.com';&#125; 用历史管理的效果1&lt;input type="button" value="看地址变没变" id="btn"/&gt; 123456var btn = document.getElementById('btn');// 新增一条历史记录(后退能回到之前的地址)。btn.onclick = function()&#123; // 参数说明 history.pushState(null,'标题','./test.html');&#125; 第一个参数是传递数据，数据是以对象的形式传递的,没有数据传就写null。 第二个是网页的标题，暂不支持 第三个是新的历史 replaceState的区别1&lt;input type="button" value="看地址变没变" id="btn"/&gt; 12345678var btn = document.getElementById('btn');// 参数都一样btn.onclick = function()&#123; history.replaceState(null,'标题','./test.html'); // 区别，replaceState没有新增加历史，而是替换掉了原地址，不能后退&#125;&lt;/script&gt;&lt;/body&gt; onpopstate事件1&lt;input type="button" value="看地址变没变" id="btn"/&gt; 1234567891011var btn = document.getElementById('btn');btn.onclick = function()&#123; history.pushState(&#123;name:'tom'&#125;,'','test.html')&#125;// 当历史发生变化时会触发，上面的按钮改变地址的时候，这里的事件就触发了window.onpopstate = function (ev)&#123; console.log(ev); // 查看事件对象的内容 // state属性是pushState传递的数据 // 只有地址变为test.html时候才会传递,没有传递数据显示null // 作用是每次返回相应页面都会传递数据，让数据不变。&#125; web存储通常存储数据是存在变量或者对象里，变量是要占内存的，所以存储量比较大的数据不适合放在变量里 换另外一种存储方式，用html5新增的数据存储方法。window.sessionStorage 和 window.localStorage 而且数据不仅要存，还要可存可删 sessionStorage添加、读取、删除、清空的使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!-- 添加 --&gt;&lt;p&gt; &lt;label for=""&gt; 键:&lt;input type="text" class="key"&gt; &lt;/label&gt; &lt;label for=""&gt; 值:&lt;input type="text" class="val"&gt; &lt;/label&gt; &lt;input type="button" class="set" value="设置"&gt;&lt;/p&gt;&lt;!-- 读取 --&gt;&lt;p&gt; &lt;label for=""&gt; 值: &lt;output class='val'&gt;&amp;nbsp;&lt;/output&gt; &lt;/label&gt; &lt;label for=""&gt; 键:&lt;input type="text" class="key"&gt; &lt;/label&gt; &lt;input type="button" class="get" value="读取"&gt;&lt;/p&gt;&lt;!-- 删除 --&gt;&lt;p&gt; &lt;label for=""&gt; 键:&lt;input type="text" class="key"&gt; &lt;/label&gt; &lt;input type="button" class="remove" value="删除"&gt;&lt;/p&gt;&lt;!-- 清空 --&gt;&lt;p&gt; &lt;input type="button" class="clear" value="清空"&gt;&lt;/p&gt;``` ```js// 添加数据$('.set').on('click',function()&#123; // 存储一个数据，数据是以键值对形式存在的。 var key = $(this).parent().find('.key').val(); var val = $(this).parent().find('.val').val(); window.sessionStorage.setItem(key,val);&#125;)// 读取数据$('.get').on('click',function()&#123; // 读取数据的值，只需要输入key就行 var key = $(this).parent().find('.key').val(); var val = $(this).parent().find('.val'); val.val(window.sessionStorage.getItem(key));&#125;)// 删除数据$('.remove').on('click',function()&#123; // 删除数据，需要输入key的值 var key = $(this).parent().find('.key').val(); window.sessionStorage.removeItem(key);&#125;)// 全部清除$('.clear').on('click',function()&#123; // 全部清空不需要传参数 window.sessionStorage.clear();&#125;) localStorage用法和 sessionStorage 用法相同，区别是声明周期不同，sessionStorage 是关闭浏览器就被清除，localStorage 永远都是在的，除非手动清除数据。sessionStorage 只能在同一个页面下存储和读取数据，localStorage 可以在多页面之间存储和读取数据 应用缓存用html和css模拟原生应用和实际原生的区别是原生应用在没有网络时候也能打开看到内容，只是内容不更新，而模拟的话会直接打不开网页，不能显示。 这个可以通过应用缓存来解决。需要一个缓存清单。其中资源是被缓存起来的，需要明确告诉浏览器要缓存谁不要缓存谁，浏览器按照缓存清单来确认该缓存哪个。 创建 新建一个txt文档，改名XXX.appcache 顶行写：CACHE MANIFEST 在html标签添加： 1&lt;html lang="en" manifest="./study.appcache"&gt; 文件内容也就是要缓存的内容： CACHE:./image/img1.jpg./image/img2.jpg./image/img3.jpg./image/img4.jpg./css/main.css 正常情况浏览器会优先读取缓存的内容，这样服务器更新了的话还会读取缓存。而写在NETWORK中的文件列表会让浏览器优先去服务器获取 NETWORK:./css/main.css*代表所有文件 回滚：当我们找不到某个资源时，可以去找一个备份资源FALLBACK:./online.html ./offline.html 管理chrome浏览器可以模拟网络，Network中右边的选项可以下拉选择，可以测试断网环境 管理缓存内容在chrome浏览器打开：chrome://appcache-internals 工具和离线模式来调试管理应用缓存 所有缓存列表写的的文件都有显示，可以手动清除，然后在下一次联网时候会再次生成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas-2d的应用]]></title>
      <url>%2F2017%2F09%2F20%2FCanvas(2d)%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[绘制网格12345678for (var i = 0; i &lt;= 1000; i+=20) &#123; ctx.moveTo(100,100+i) ctx.lineTo(1100,100+i) ctx.stroke() ctx.moveTo(100+i,100) ctx.lineTo(100+i,1100) ctx.stroke()&#125; 绘制坐标轴1234567891011121314151617181920// 绘制坐标轴var padding = 30ctx.moveTo(canvas.width - padding, canvas.height - padding)ctx.lineTo(padding, canvas.height - padding)ctx.lineTo(padding, padding)ctx.strokeStyle = "rgb(50,200,240)"ctx.stroke()// 绘制箭头var h = 20, w = 20ctx.beginPath()ctx.moveTo(canvas.width - padding - w, canvas.height - padding - h / 2)ctx.lineTo(canvas.width - padding, canvas.height - padding)ctx.lineTo(canvas.width - padding - w, canvas.height - padding + h / 2)ctx.strokeStyle = "rgb(50,200,240)"ctx.stroke()ctx.moveTo(padding - w / 2, padding + h)ctx.lineTo(padding, padding)ctx.lineTo(padding + w / 2, padding + h)ctx.stroke() 绘制矩形ctx.fillRect(x,y,width,height) 和 ctx.strokeRect(x,y,width,height) 是左上角的坐标，根据宽高自动绘制 1234567ctx.beginPath()ctx.fillStyle = 'pink'ctx.fillRect(50,50,200,200)ctx.beginPath()ctx.strokeStyle = 'pink'ctx.strokeRect(50,50,200,200) 绘制圆弧 ctx.arc(x,y,radius,start angle，end angle，anit-clockwise(true/false)) x,y 是指定圆心坐标 radius 确定圆弧的半径 start angle 指定该圆弧的起始弧度 end angle 指定圆弧终止的弧度 anit-clockwise(true/false) 是否逆时针绘制圆弧，默认是false 1234ctx.beginPath();ctx.strokeStyle = 'pink';ctx.arc(300,300,100,0,Math.PI,true);ctx.stroke() ctx.arcTo(x1,y1,x2,y2,radius) moveTo(x,y)这个点到arcTo(x1,y1,x2,y2,radius)这两个点，画两条线相交 由(x,y)(x1,y1)(x2,y2) 确定线段，绘制以radius为半径的，并且和上面两条线段相切的圆弧 123456789// 画布的长宽为1000*600 绘制一个圆角矩形ctx.beginPath()ctx.fillStyle = 'orange'ctx.moveTo(100,0)ctx.arcTo(1000,0,1000,900,100) // 第一个圆弧ctx.arcTo(1000,600,900,600,100) // 第二个圆弧ctx.arcTo(0,600,0,0,100) // 第三个圆弧ctx.arcTo(0,0,1000,0,100) // 第四个圆弧ctx.fill() 注意：移动了笔触再绘制圆弧时，当前笔触的点会和绘制圆弧的起始点进行连线。（画了两个圆弧，默认会将结束的圆弧点和下一个开始圆弧的点相连。） 弧度制 360度表示一圈， 2 * Math.PI 表示一圈 360度 = 2 * Math.PI 一弧度：Math.PI / 180 一度：180 / Math.PI 绘制文字 ctx.fillText(&quot;text&quot;,x pos , y pos , maxwidth(optional)) ctx.strikeText(&quot;text&quot;,x pos , y pos , maxwidth(optional)) text 要绘制的文本内容 (x,y) 要指定绘制文本的位置 maxwidth 指定文本的最大宽度 ctx.font 指定字体和大小 格式：”20px 字体” ctx.textAlign 默认是start start和left是一样的 end和right是一样的 start end left 对齐方式相对于基点的位置 right center ctx.textBaseline （中文用的很少） 文字相对于基线的位置调整，一般用middle alphabetic 默认 top hanging ideographic bottom middle drawImage 绘制图像使用时要等图片加载完再绘制，要不然绘制的是空的，可以用load事件，两种方式： 123456789101112a:var img = document.querySelector('image');img.addEventListener('load',function()&#123; ctx.drawImage(img,50,50);&#125;)b:var img = new Image()img.src = '路径'img.'onload' = function()&#123; ctx.drawImage(img,50,50)&#125; 以下三种用法都要等页面加载完毕之后再去绘制 普通的渲染图像drawImage(imObj,x,y) 在canvas的x,y位置上渲染指定的imgObj。宽高是按照图像的宽高 12345var img = new Image();img.src = 'imgs/1.png'img.addEventListener('load',function()&#123; ctx.drawImage(img,100,200)&#125;) 缩放绘制图像drawImage(imgObj,x,y,width,height) 在canvas的(x,y)位置上，根据指定的宽和高来渲染imgObj图像。设定的时候要保持原比例，假如width设定的是300，那么高就等于：img.height / img.width * 300 12345var img = new Image();img.src = 'imgs/1.png'img.addEventListener('load',function()&#123; ctx.drawImage(img,100,200,200,200) //img对象，原点位置，长宽&#125;) 切片绘制图像drawImage(imgObj,sx,sy,swidth,sheight,x,y,width,height) sx,sy,swidth,sheight 是在原图片上的sx,sy的位置切片一个带下为swidth宽和sheight高的图像。将切出来的图像绘制在canvas的x,y的位置上，并且指定width为宽height为高。 123456var img = new Image();img.src = 'imgs/1.png'img.addEventListener('load',function()&#123; ctx.drawImage(img,img.width/2,img.height/2,img.width/2,img.height/2,200,200,50,50) // 图片对象，设定图片的原点，参照原点的长宽切图片，放在画布的原点，显示的长宽&#125;) 坐标系变换整个坐标轴就按照移动后的计算，两种移动方式都要写在渲染之前 平移坐标系ctx.translate(x,y) 将坐标系的原点平移到x,y的位置，平移之后原点就变了，x,y的位置就变成了新的原点。是相对于之前的起始点移动。 123ctx.beginPath();ctx.translate(100,100);ctx.fillRect(300,200,200,200); 旋转坐标系ctx.rotate(radian) 以当前原点旋转坐标系到指定的弧度（radian），如果为负数就是逆时针旋转，如果为整数就是顺时针旋转 1234ctx.beginPath();ctx.translate(300,300);ctx.rotate(Math.PI/2)ctx.fillRect(0,0,200,200); 清除画布ctx.clearRect(x,y,width,height) 清除由x,y为原点width和height确定的矩形内部的所有的图形。 状态保存与恢复ctx.save() 将上一次的状态保存起来。 ctx.restore() 将最近一次保存起来的状态恢复，第一次执行恢复上一次，在执行恢复上上次，再执行恢复上上上次。 1234567891011121314ctx.beginPath();ctx.lineWidth = 20;ctx.strokeStyle = 'orange'ctx.strokeRect(100,100,600,200)ctx.save();ctx.strokeStyle = 'hotpink'ctx.strokeRect(120,120,560,160)ctx.save();ctx.strokeStyle = 'red'ctx.strokeRect(140,140,520,120)ctx.restore();ctx.strokeRect(160,160,480,80)ctx.restore();ctx.strokeRect(180,180,440,40)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas(2d)]]></title>
      <url>%2F2017%2F09%2F20%2FCanvas(2d)%2F</url>
      <content type="text"><![CDATA[简介概念H5提供的一个新的标签元素。相当于画纸 描述canvas是指可以在其上面绘制图形（通过js）、图像以及制作动画的标签。canvas不具有绘图能力，只是用来展示（渲染） 兼容在浏览器不支持canvas时，会将其当做div标签来解析，在IE低版本中会将其当做文本节点来解析。 基本使用创建一个画布 &lt;canvas&gt;内容&lt;/canvas&gt;，其中内容如果浏览器不支持就会显示。 在创建一个canvas标签时，如果没有指定宽高，默认是300*150。 只能用canvas本身的宽高属性去定义宽高，而且不加单位，直接写值。如果用css样式去指定宽高，会在默认值得基础上进行缩放，而在缩放时，并没有增加canvas的内部的像素点的个数。 获取绘制工具（canvas提供的）getConText方法12var convas = document.querySelector('canvas')var ctx = canvas.getContext('2d') // 值有两个，2d和WebGL 2d：获取绘制平面图形的工具。 WebGL：获取绘制立体图形的工具。 canvas的坐标系规则原点在canvas的左上角，水平方向是x轴，垂直方向是y轴 绘制工具的API方法moveTo(x,y)移动笔触方法，x确定点的横坐标，y确定点的纵坐标 lineTo(x,y)画线的方法，从当前笔触所在点连线到指定点。 绘制直线的步骤 移动笔触moveTo 画线lineTo 描边strike()，填充fill()。 练习：绘制一个矩形12345678910111213141516171819// 绘制矩形var canvas = document.getElementById('canvas') ctx = canvas.getContext('2d')var x, yvar w, hx = 50 // 矩形的x轴值y = 50 // 矩形的y轴值w = 150 // 矩形的宽h = 100 // 矩形的高// 移动笔触至矩形的顶点// 并依次连线到矩形的其他各个顶点ctx.moveTo(x, y)ctx.lineTo(x + w, y)ctx.lineTo(x + w, y + h)ctx.lineTo(x, y + h)ctx.lineTo(x, y)// ctx.stroke()ctx.fill() 路径的概念使用方法stroke 或者 fill 开头具有描边和填充功能。浏览器没法识别是不是一个新路径。 closePath() 闭合路径，将路径闭合并形成一个封闭空间。 12345678// 绘制三角形ctx.moveTo(50,50)ctx.lineTo(250,250)ctx.lineTo(50,250)// 让路径自动闭合，必须写在路径最后。这样就不用写原点了，而且避免了锯齿问题ctx.closePath()ctx.strokeStyle = 'pink'ctx.stroke() beginPath() 开辟新的路径，告诉解析器这是一个新路径，这样不会影响上一个路径。 12345678// 绘制三角形ctx.beginPath()ctx.moveTo(300,50)ctx.lineTo(450,200)ctx.lineTo(300,200)ctx.closePath()ctx.strokeStyle = 'blue'ctx.stroke() 这里如果不用 beginPath() 的话，上面的那个三角也会变成蓝色。不只是颜色属性，如果不用 beginPath() 的话所有属性都会被最后一个绘制的图形覆盖。 所以 beginPath() 就是让浏览器知道上个这个路径是新的开始和上一个没有关联。 注意 只有在需要开始新路径时，调用 beginPath()。 在需要将图形闭合，形成封闭的图形，那么久可以调用 closePath() 方法。 这两个方法并不一定要成对出现。 除了 stroke() 或者 fill() 开的方法之外，都只会绘制路径，此时需要手动调用 stroke() 或者 fill() 方法。 线性相关的属性使用方法lineWidth：设置线宽，值是数值； strokeStyle：设置线条颜色，值可以为16进制、颜色字符串、rgb、渐变色。 fillStyle：设置填充颜色 lineCap：设置线段两端的样式，有三个值。 butt：默认值，没有样式 round：设置线的两端是突出的圆弧 square：设置线的两端为突出的方形 lineJoin：设置线的相交线的拐点 round：线相拐点是圆弧 bevel：线相拐点是平角 miter：线相拐点是尖角，是默认值 lineCap和lineJoin的练习123456789101112131415161718192021222324// lineCap和lineJoin的练习ctx.moveTo(50, 50)ctx.lineTo(250, 150)ctx.lineTo(450, 50)ctx.lineWidth = 20ctx.lineCap = 'round' //线的两端是突出的圆弧ctx.lineJoin = 'round' //线的拐点是圆弧ctx.stroke()ctx.beginPath()ctx.moveTo(50, 100)ctx.lineTo(250, 200)ctx.lineTo(450, 100)ctx.lineCap = 'square' // 线的两端是突出的方形ctx.lineJoin = 'miter' // 线的拐点是尖角 ， 默认ctx.stroke()ctx.beginPath()ctx.moveTo(50, 150)ctx.lineTo(250, 250)ctx.lineTo(450, 150)ctx.lineCap = 'butt' // 线的两端没有样式 吗，默认ctx.lineJoin = 'bevel' // 线的拐点是平角ctx.stroke() 渐变色练习12345678// 渐变色练习for (var i = 0; i &lt; 255; i++) &#123; ctx.beginPath() ctx.moveTo(50,50+i) ctx.lineTo(300,50+i) ctx.strokeStyle = "rgb("+ i +",0,0)" ctx.stroke()&#125; 非零环绕原则目的是确认某一块区域是否需要填充。 从这个当前区域选取任意点，然后从该点到整个图形外部绘制一条射线，观察和这条射线相交的所有的线段，如果该相交的线段是顺时针穿过这条射线，那么计数+1，如果是逆时针穿过，那么计数-1，如果计数为0，那就不填充该区域，如果计数非0，那么就填充该区域。 从左只有穿过或从上至下穿过都是顺时针，反之是逆时针。 练习12345678910111213// 顺时针绘制ctx.moveTo(50,50)ctx.lineTo(500,50)ctx.lineTo(500,500)ctx.lineTo(50,500)ctx.closePath()// 逆时针绘制ctx.moveTo(80,80)ctx.lineTo(80,470)ctx.lineTo(470,470)ctx.lineTo(470,80)ctx.closePath()ctx.fill() 奇偶原则就是看相交线的个数，如果为奇数，就填充；否则就不填充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gulp]]></title>
      <url>%2F2017%2F09%2F20%2Fgulp%2F</url>
      <content type="text"><![CDATA[为什么需要gulp 多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的。 使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析。 合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能。 这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。这种工具就是gulp。 构建工具就是指通过简单吗配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具 gulp下载和配置 gulp是基于node和npm的，在安装了node的基础上。执行 npm install gulp -g 即可在电脑上安装。 在需要构建的文件夹目录下，执行npm init 进行初始化，会生成package.json文件。 在本地目录下载 npm install gulp –save-dev save时为了保存依赖关系 在项目下新建文件gulpfile.js，构建的逻辑都写在这里边。 gulp基本命令以下的编辑器的内容都是写在 gulpfile.js 中的。这里以压缩css文件为例。 第一步在gulp是通过require()来引包.会自动在当前目录寻找node_modules并进去找gulp。 12345var gulp = require('gulp')var cssmin = require('gulp-cssmin')var autoprefixer = require('gulp-autoprefixer') 第二步定义一个任务，名字取为css。 12345678910111213gulp.task('css',function()&#123; // 通过gulp.src以参数的形式表示文件存放位置 // &#123;base:'./'&#125;是基准目录，也就是放到/release/css/main.css，如果不加基准目录就是/release/main.css gulp.src('./css/main.css',&#123;base:'./'&#125;) // pipe是管道的意思,cssmin的参数是.之前返回的结果 .pipe(cssmin()) // 加c3的浏览器兼容前缀，根据当前版本往前倒5个版本 .pipe(autoprefixer(&#123; browsers:['last 5 versions'] &#125;)) // 选择压缩后存放文件的位置 .pipe(gulp.dest('./release')) &#125;); 总结：gulp.task() 定义任务 gulp.src() 寻找资源 gulp.pipe() 管道 gulp.dest() 存储目录 常用插件介绍gulp-less 编译LESS文件 gulp-autoprefixer 添加CSS私有前缀 gulp-cssmin 压缩CSS gulp-rename重命名 gulp-imagemin 图片压缩 gulp-uglify 压缩Javascript gulp-concat 合并 gulp-htmlmin 压缩HTML gulp-rev 添加版本号 gulp-rev-collector 内容替换 gulp-useref 处理文件合并后的引用问题 gulp-if 合并文件之后压缩 以上代码将在下面的案例中做使用说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109var gulp = require('gulp');//less转cssvar less = require('gulp-less') // 加c3前缀var autoprefixer = require('gulp-autoprefixer') // 文件改名var rev = require('gulp-rev') // 压缩css文件var cssmin = require('gulp-cssmin') // 压缩图片var imagemin = require('gulp-imagemin') // 文件重命名var rename = require('gulp-rename') // 更改js文件后html里的引用修改var useref = require('gulp-useref') // 筛选文件var gulpif = require('gulp-if') // 压缩js文件var uglify = require('gulp-uglify') // 内容替换var revCollector = require('gulp-rev-collector') // 处理css文件gulp.task('css',function()&#123; return gulp.src('./public/less/main.less') .pipe(less()) // 首先将less转为css .pipe(cssmin()) // 转为css之后就可以对css文件进行压缩 .pipe(autoprefixer(&#123; browsers:['last 5 versions'] &#125;)) .pipe(rev()) // 给css改名字，防止浏览器从缓存读取文件 .pipe(gulp.dest('./release/public/css')) .pipe(rev.manifest()) // 生成css新旧文件名的对应关系的json文件 .pipe(rename('css-manifest.json')) // 将文件改名，防止保存时重命名被覆盖 .pipe(gulp.dest('./release/rev'));&#125;)//处理图片任务gulp.task('image',function()&#123; return gulp.src(['./public/images/**/*','./uploads/*'],&#123;base:'./'&#125;) // 图片有两个文件夹 .pipe(imagemin()) // 图片压缩 .pipe(rev()) // 给图片改名字，防止浏览器从缓存读取文件 .pipe(gulp.dest('./release')) .pipe(rev.manifest()) // 生成图片新旧文件名的对应关系的json文件 .pipe(rename('image-manifest.json')) .pipe(gulp.dest('./release/rev'))&#125;)//处理js文件/**uesref的用法：第一种 以下被注释包裹的部分是html文件的引用部分，意思是将下面三个js文件合并成all.js文件。./script/all.js保存位置中的./是指相对于html文件的当前目录下&lt;!--build:js ./script/all.js--&gt; &lt;script src="./scripts/app.js"&gt;&lt;/script&gt; &lt;script src="./scripts/controllers.js"&gt;&lt;/script&gt; &lt;script src="./scripts/directives.js"&gt;&lt;/script&gt;&lt;!--endbuild--&gt;&lt;!--build:js ./libs/angular.min.js--&gt; &lt;script src="./bower_components/angular/angular.js"&gt;&lt;/script&gt; &lt;script src="./bower_components/angular-route/angular-route.js"&gt;&lt;/script&gt;&lt;!--endbuild--&gt;第二种 和第一种相同，只是换成了css文件&lt;!--build:css ./public/css/main.css--&gt; &lt;link rel="stylesheet/less" href="./public/less/main.less"&gt;&lt;!--endbuild--&gt;第三种 将被包裹的部分删除&lt;!--build:remove--&gt; &lt;script src="./public/libs/less.js"&gt;&lt;/script&gt;endbuild*/gulp.task('useref',function()&#123; return gulp.src('./index.html') //最终是要替换页面中的引用 .pipe(useref()) .pipe(gulpif('*.js',uglify())) // 对合并后的文件进行筛选，再进行压缩 .pipe(gulpif('*.js',rev())) // 防止浏览器从缓存取文件,js也要改名 .pipe(gulp.dest('./release')) // 将index.html放到release中，useref的注释的目录是根据index文件的位置保存的， // 所以html位置变了，那几个合并的文件的位置也就在release中了 .pipe(rev.manifest()) .pipe(rename('js-manifest.json')) .pipe(gulp.dest('./release/rev'))&#125;)// 内容替换(图片、js、css文件名都改了，那么html中的引用的名字也要改一下才行)gulp.task('rev',function()&#123; gulp.src(['./release/rev/*.json','./release/index.html'],&#123;base:'./release'&#125;) // 新旧名字对应都在json文件里 // 如果不加base那json就和html一样保存在release根目录下了 // 表示将./release后面的路径保存到release目录下 .pipe(revCollector()) .pipe(gulp.dest('./release'))&#125;)// 以上内容是每个都需要执行，也可以写成一次性执行// rev必须等之前的执行完了才能执行，这样会先执行数组里的，再执行revgulp.task('rev',['css','image','useref'],function()&#123; gulp.src(['./release/rev/*.json','./release/index.html'],&#123;base:'./release'&#125;) .pipe(revCollector()) .pipe(gulp.dest('./release'))&#125;)// 但是问题是执行数组里的三个需要时间，但是它们还没执行完，rev就执行了,在上面的构建里加return就可以解决// 其他任务（api、字体等不需要修改的）gulp.task('other',function()&#123; gulp.src(['./api/*','./public/fonts/*','./public/libs/*','./views/*'],&#123;base:'./'&#125;) .pipe(gulp.dest('./release'));&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>%2F2017%2F09%2F19%2FGit%2F</url>
      <content type="text"><![CDATA[Git的三个区域介绍Git仓库Git仓库目录就是Git用来保存项目的源数据和对象数据库的地方。Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录工作目录是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供用户使用或修改 暂存区暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index）,不过一般说法还是叫暂存区。 Git 本地版本管理基本的Git工作流程 在工作目录中国修改文件。 暂存文件，将文件的快照放入暂存区域。 提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 操作方法和命令本地仓库根目录右键：Git Bash Here，打开Git Bash。 输入：git init 就可以让git来管理目录。这个命令只是创建了一个名为 .git 的隐藏目录，这个目录就是存储我们历史版本的仓库。 添加到缓存git add index.html将index.html文件放到暂存区 git add js css将js和css文件夹的文档都放到暂存区 git add * 或 -A所有文件都放到暂存区 git会自动过滤空目录。 查看状态git status检测当前仓库文件的状态，红色表示被修改，放到暂存区的文件被标记成了绿色等待提交。 git checkout index.html将index.html从暂存区还原到工作区。 提交git commit -m ‘frist’已提交状态，-m是mark的意思，将暂存区的内容全部文件提交，将暂存区被标记成绿色的文件，全部提交到本地仓库存储，’frist’ 是对本次提交内容的说明。 其他git log查看存盘点，每次提交会生成一个随机id值 git reset –hard id值还原代码到该id值得版本 第一次使用git时需要配置。 git config –global user.name pj.Yu设置自己的名字。 git config –global user.email 406490508@qq.com设置自己的邮箱 Git分支为什么需要分支同时开发多个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要来修复，这个时候我们当然希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。通过Git创建分支来解决实际开发中类似的问题。 分支的好处开发时在另一个分支上开发新功能A然后上线，然后再写另一个分支另外一个功能B，这时A功能有bug再去调试，不会影响其他分支的状态。 分支原理当我们初始化仓库时候，实际上就是产生了第一次提交。Git会默认帮我们创建一个master的分支，每次commit操作生成一个新的版本（存盘点）。而且会生成一个sha值，master是主干，这些版本就是在主干上的存盘点，每一次的历史按本都是基于分支存在的。 分支功能实现建立新的分支git branch share建立一个名为share的分支，建立后现在还是在master主干上。 git checkout share切换到share分支，切换之前尽量先commit。 git branch查看当前都有哪些分支。*号表示当前处于哪个分支。 git checkout -b share创建并切换到share分支 另外分支是有继承关系的。新建的自分支会继承父分支的所有提交历史。 合并两个分支git merge share当前分支合并share分支。同一个文件被修改会产生冲突。 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD冲突开始的位置 ===========.之上是当前分支的代码，之下是share分支的代码 .&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; share冲突结束的位置 根据需求留下想要的代码，将标识符都删除掉就解决冲突了。 删除分支git branch -d share删除share分支 git的分支管理规范 不要有太多的分支，分支太多管理起来太费劲，毕竟是多人开发制定策略太复杂 要有一个稳定的平行分支，即master分支不要轻易修改，这个稳定的文分支不能有bug。 要有一个开发分支(developer)，保证master分支的稳定性 所有的功能分支(feature)从developer创建，功能写完后合并到developer，但不能直接合并到master，因为要保证始终有一个没有bug的稳定分支 所有功能开发完成后新建发布分支(release)，用作测试，测试完全没问题就合并到master分支。 Git 协同开发多个人共同开发，改完代码后放到共享仓库，其他人就可以取到代码。借助一个远程仓库，大家可以共享代码、历史版本等数据 在自己电脑创建一个共享仓库Git要求共享仓库是一个以.git结尾的目录。 mkdir repo.git 创建以.git结尾的repo文件夹目录 cd repo.git 进入这个目录 git init –bare 初始化一个共享仓库，也叫裸仓库 注意选项–bare 假设自己的本地仓库和repo是同级目录，回到自己的本地仓库执行 git push ../repo.git master 就把master分支的代码共享到了共享库中 从共享仓库里取出内容 另一个开发者执行 git pull ./repo.git master 获取共享仓库的master分支。 将本地仓库上传到服务器：git push 用户名@IP地址:/路径名 master。 以上是以自己电脑为例创建了一个共享仓库，而在实际中，gitHub就是一个共享仓库功能的网站 gitHub提供共享仓库的功能，类似于一个博客空间 在gitHub中新建一个仓库 首先创建一个新的项目，要输入项目名，项目描述，是否公开。其实就相当于新建一个共享库。 以表格形式创建一个仓库，并且会提供给我们一个仓库地址。 由于主机名太长，可以简写成主机名。以后只填写主机名就行，就不用写远程仓库地址了。 git remote管理远程地址用 git remote add “主机名” “远程仓库地址”添加远程主机 其实就是给远成仓库地址起一个比较短的名字 git remote show “主机名”查看这个主机名对应的主机名是谁 git remote显示所有主机名 地址下面会告诉用户应该怎样操作，如何创建.git并上传等设置，这里根据自己的实际情况，并不是每一步骤都要设置，有可能之前已经设置好了 设置之后就可以push了，但是这时会有权限问题，也就是公钥和私钥，需要将本电脑的公钥传到gitHub上。 为了免密码共享代码需要通过SSH来实现：创建公钥：ssh-keygen -t rsa 一直回车。在用户的文件里创建了一文件夹.ssh里边创建了对公钥和私钥.pub是公钥。 将公钥放到gitHub对应账号下，在个人设置里有SSH的选项，复制进去就行。相当于在自己电脑和gitHub之间建立了连接。私钥不需要管如果有两台电脑就要添加两个SSH key 权限解决之后就可以随意 git push gitHun仓库地址 分支 和 git pull gitHun仓库地址 分支 git push origin login:master把本地的login分支的修改共享到远程的master分支上去 如果远程没有这个分支就会创建一个。 fork功能gitHub除了创建共享仓库，还有一个目的是coding，大家一起来共享代码 这里的项目都是公开的开源项目，除了自己可以维护功能，其他来自全世界的人都可以共同进行开发，并且其他开发者可以对原有的项目进行修改 但是程序员水平参差不齐，所以项目不允许其他人直接修改。需要先forking一份到自己的目录下，然后通过克隆、pull、push等操作，修改自己目录下的这份副本。 自己改完以后经过自己测试，没问题的话可以申请原有项目合并自己的修改。申请合并是pull requests选项，在gitLab中是Merge Requests选项。要填写合并哪个项目的哪个分支，还要填写更改的说明，和发邮件类似，这样发送请求就成功了。 对方会受到申请并且检验，如果对方觉得改的不错，同意后可进行合并，否则拒绝 克隆远程仓库当仓库已经有项目了，项目已经开始开发了，可以执行克隆操作。 git clone “仓库地址”拿下来的就是仓库了 就不用再执行init了 克隆下来后，查看分支，当前只有 master 分支，因为克隆的就是主干分支。 git fetch “仓库地址”这时就把其他分支都拿下来了 git branch -A可以看远程仓库的分支，除了主干都是红色的 总结来看，我如果使用git clone “仓库地址” 相当于完成了以下步骤：mkdir 目录 -&gt; cd 目录 -&gt; git init -&gt; git remote add origin “仓库地址” -&gt; git pull origin master gitLab通过gitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，私有仓库又是需要交“保护费”的，而gitLab就是免费私有的这么一个网站。 gitLab也是一个可以通过Web界面管理仓库的网站程序，我们可以把它架设到公司自已的服务器上，实现仓库私有化，这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。 由于操作和gitHub一样，就取一部分使用作为笔记记录，比如在公司内开发的应用场景，在公司内的代码肯定是要私有化的，而gitHub又是收费的，所以用gitLab更常用 给项目添加成员进入一个项目后，右上角的设置有个Menbers选项，就是成员的意思，如果希望有个人一起合作写这个项目，就可以邀请并分配权限，通常分配Developer权限。现在对方就可以随意push代码，但是不能操作master分支。 分组很多时候我们需要创建一个分组，相当于建立一个群。Groups，在左边的菜单栏里。 分组可以直接添加分组成员，步骤和项目添加成员相同。 在分组里可以建立项目，作为小组的成员也会自动生成一个项目目录，大家就可以一起开发这个项目，之后的步骤和上面相同。 Protexted Branches受保护的分支，默认情况下保护的是master分支， 也可以自行根据权限设置保护的分支。 gitignore 忽略文件有些文件不需要提交，比如笔记，图片等。这时就可以忽略掉 忽略方式：创建一个没有文件名的.gitignore后缀文件，通过另存为来保存。也可以用命令行创建将要忽略的文件名存进去，就忽略了。 比较差异当内容被修改时，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 git difftool比较暂存区和修改的文件的差异，接一个sha值比较暂存区和历史记录的差异,两个sha值就是历史版本和历史版本的差异 回滚（撤销）操作如果刚刚上传完后又发现一个bug， 可以用 git reset 把某一个版本的代码还原到工作目录 –hard 工作区会变，历史会变，暂存区也会变–soft 只会变历史区域的代码，即是回滚在工作区也看不见。–mixed 历史会变，暂存区也会变，工作区不变 工作区指的能看的见的代码，.git目录就是仓库区域，暂存区也在.git目录下就是index文件。 git checkout可以从某一个版本取出某一个特定的文件。 git checkout SHA值 – index.html只拿出index到工作区中，其他文件不变 历史不变。 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过 git fetch 命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch “远程主机” 或者 git fetch “远程主机” “分支名称”获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用 git merge 来将对应的分支合并（融合）到特定分支。用 git merge remotes/主机名/分支名 当前分支合并remotes/主机名/分支名 也可以用 git pull 主机名 分支名 ，这个命令等于做了两个操作：git fetch 和 git merge origin/某个分支 git branch -a便可以查看所有(本地+远程仓库)分支了 git push origin –delete 分支名称删除远程分支]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[版本控制]]></title>
      <url>%2F2017%2F09%2F19%2F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[概念版本控制（Version Control Systems）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。这个系统可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态。 分类控制文件内部的修改信息，记录之后可以还原信息到上次保存的状态。实现版本控制的软件有很多种类，大致可以分为本地版本控制系统、集中式版本控制系统、分布式版本控制系统。 本地版本控制系统（现在已经没人使用）文件的每一次修改，都会记录一次版本，这样我们通过版本控制系统（软件）便可以非常方便的恢复到任意版本。可以想象成游戏的存档，本地控制系统只能保存自己电脑的更改版本，就好比单机游戏 集中式版本控制系统（有缺陷但不致命，仍然有很多公司使用）它通过单一的集中管理的服务器，保存所有文件的修订版本，协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN这种方式很好解决了多人协同开发的问题，但是也有一个弊端，如果集中管理的服务器出现故障，将会导致数据（版本）丢失的风险，另外协同开发者从集中服务器中更新数据时，严重依赖网络，如果网络不佳，也给开发带来诸多不便。比如在第三个版本有一个bug，b同学解决了这个bug后，那么就创建了一个版本4，而a、b开发者如果网络有问题就没法拿到这个版本 分布式版本控制系统（最新最完善，应用广泛）分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，这么一来，任何协同开发者用的服务器发生故障，事后都可以用其它协同开发者本地仓库恢复。由于版本库在本地计算机，也便不再受网络影响了。如果要将本地的修改，推送给其它协同开发者，还需要一台共享服务器，所有开发者通过这台共享服务器同步和更新数据。相同点是服务都有。差别在于本地也有存盘点，服务器挂掉等于在每个客户端都有备份。其代表就是Git。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shell&Vi]]></title>
      <url>%2F2017%2F09%2F19%2Fshell%26Vi%2F</url>
      <content type="text"><![CDATA[壳和核的概念概念shell俗称为壳，在cmd中输入的命令就称为shell。 壳的概念是为了区别于核kemel，而核是通过壳才能驱动运行的，假如核是汽车那么壳就是车钥匙。再比如播放视频，双击打开就是壳的部分，壳来驱动存放在硬盘的视频来播放运行视频文件，播放视频就是核。它接收用户命令，然后调用相应的应用程序。 结论：用户 -&gt; 壳 -&gt; 核 -&gt; 硬件 壳的分类图形界面GUI通过提供友好的可视化界面，调用相应应用程序。图形界面的代表就是windows等操作系统，相当于一个壳。 命令行cli通过键盘输入特定命令的方式，调用相应的应用程序。在windows有cmd、powershell。在linux有sh(Bourne shell)、bash(Bourne Again shell) bash命令在window系统下使用bash，需要一个软件，这个软件模拟（还有很多其他软件）集成了bash大部分命令 windows要支持bash的命令才可以，所以要在windows使用要装GIT和bash，这两个也可以分开装 格式命令[-options] [参数]，如 tar zxvf demo.tar.gz 查看帮助命令 –help bash常见命令pwd（Print Working Directory）查看当前目录 cd（Change Directory）切换目录。打开e盘：cd /e 或者 打开web文件夹： cd web；返回上一级：cd .. ls（List）查看当前目录下的内容。ls -al(all list) ； 查看web文件夹下的内容：ls web 。 mkdir（Make Directory）创建文件夹。创建一个blog目录：mkdir blog。 touch创建文件。创建一个index.html文件：touch index.html cat查看文件的全部内容。查看文件里编辑的内容：cat index.html less查看文件的部分内容。文件里的内容太长可以用less命令：less index.html。 可以分页查看，q是退出功能、空格翻页。 rm(Remove)删除文件。rm index.html。 加-rf可以删除有子文件的文件夹：rm -rf blog。 小心使用，删除的内容不回回收站。 rmdir(Remove Directory)删除文件夹。rmdir web。 只能删除空文件夹，不常用 mv（move）移动文件或重命名。移动：mv index.html ./demo ；重命名：mv index.html test.html。 cp（copy）复制文件。复制时可以顺便改名：cp index.html ./demo/test.html head查看文件内容的前几行。查看前5行内容：head -5 index.html。 tail查看文件内容的后几行。查看后5行内容：tail -5 index.html。 tab自动补全。连按两次会将所有匹配内容显示出来。 history查看操作历史 ssh远程登录。在下面的部分会介绍 &gt; 和 &gt;&gt;重定向&gt;是覆盖，&gt;&gt;是追加。将原本应该输出在屏幕上的内容输出到README.md中：history &gt; README.md。 可以实现复制文件夹里的内容：test.txt &gt; test1.txt。 wget下载。wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz。 tar解压缩。tar zxvf node-v4.4.0.tar.gz。只能解压gz格式 curl网络请求。curl http://www.baidu.com whoami查看当前操作系统的用户名 |管道符可以将多个命令连接使用。把上一次命令的执行结果当成下一次命令的参数 grep匹配内容。去index.txt中找出匹配index字符的行内容：grep index index.txt (可以匹配正则表达式)。 配合管道符使用。在ls返回的结果中（很多文件）中查找包含index字符的内容行：ls | grep index (ls | 就当做第二个参数来使用) Vi编辑器如同windows下的记事本，vi编辑器是linux下的编辑器。通过它们我可以创建、编辑文件。它是一个随系统一起安装的文本编辑软件。 vi在编辑文本内容时，在不同模式下进行的操作是不同的，有三种模式：插入模式、命令模式、底行模式。 打开vi编辑器默认是命令行模式，在命令行模式输入 i 或 a 就进入了输入模式，输入模式按 ESC 就回到了命令行模式，命令行模式输入 : 就进入了底行模式，底行模式按 ESC 就回到了命令行模式。 vi编辑器的常用操作：打开/创建文件vi 文件路径 底行模式w保存，w 文件名 另存为 q退出 wq保存并退出 e!撤销更改，返回到上一次保存的状态 q!不保存强制退出 set nu 设置行号 命令模式ZZ保存并退出 u撤销操作，可多次使用 dd删除当前行 yy复制当前行 p粘贴内容 ctrl+f向前翻页 ctrl+b向后翻页 i进入编辑模式，当前光标出插入 a进入编辑模式，当前光标后插入 A进入编辑模式，光标移动到行尾 o进入编辑模式，当前行下面插入新行 O进入编辑模式，当前行上面插入新行 ssh协议概念SSH是一种网络协议，用于计算机之间的加密登录，在自己的电脑上登录远程服务器。这种协议存在多种实现，就好比HTTP是一个协议它是通过浏览器来实现。linux下使用OpenSSH，在windows下使用PuTTY。 通过ip就可以访问到远程服务器：ssh student@192.168.21.70 使用student这个用户名来登录192.168.21.70这个服务器，当然这个用户是提前创建好的。 加密对称性加密经过算法将原始数据加密，接收方接收到之后解密，两方通过秘钥加密和解密。在第一次发送时会先将秘钥传递到接收方，所以虽然很好用但是秘钥可能会被拦截。 非对称性加密加密和解密使用的不是同一个秘钥。本地电脑创建一对秘钥，分别是公钥和私钥，可以通过公钥加密数据，这样只能用对应的私钥来解密。也可以通过私钥加密只能用对应的公钥来解密。 第一次登陆远程计算机时，会将远程计算机的公钥下发下来，保存在本地。这时登陆远程计算机，密码就可以用公钥加密发送。当远程服务器接收到公钥加密的数据后，会自动使用私钥进行加密。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bbc的css]]></title>
      <url>%2F2017%2F09%2F15%2Fbbc%E7%9A%84css%2F</url>
      <content type="text"><![CDATA[全局css样式 html 的背景为 background: #FFFFFF bod 有默认的 font-family，font-size，line-height a 有默认的 color 并且不显示下划线 .wrap 类用于固定宽度的容器，宽度为950px的版心 .wrap-fluid 类用于 100% 宽度，占据全部视口的容器，宽度为1200px的版心 栅格系统栅格容器 栅格分为最多16列 暂定两种宽度的容器 .wrap 和 .wrap-lg，分别是950px和1200px。 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为“行（row）”的直接子元素。 类似 .row 和 .col-4 这种预定义的类，可以用来快速创建栅格布局。 如果一“行（row）”中包含了的“列（column）”大于 16，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。 如果一个元素中使用了多个类，预定义类 .col-* 必须放在首位，否则一部分样式应用不上。 在 .wrap 下，列要使用 .col- ,列宽50间距10。在 .wrap-lg 下，列要使用 .col-lg- ,列宽75间距10 列偏移 使用 .offset-* 类可以将列向右侧偏移，通过增加元素左侧 margin 实现的。 在 row 内第一列设置没有作用。 每个 offset-1 的宽度和 col-1 是相同的。 列嵌套如果要在 col 内部再去嵌套列，可以通过添加一个新的 .row 元素和一系列 .col-* 元素到已经存在的 .col-* 元素内。被嵌套的行（row）所包含的列（column）的个数不能超过 16。 1234567891011&lt;section class="wrap"&gt; &lt;div class="row"&gt; &lt;div class="col-16"&gt; &lt;div class="row"&gt; &lt;div class="col-4"&gt;col-4&lt;/div&gt; &lt;div class="col-8"&gt;col-8&lt;/div&gt; &lt;div class="col-4"&gt;col-4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 排版页面主体 标题样式：HTML中提供了 .h1 到 .h6 类，为的是给内联（inline）属性的文本赋予标题的样式。 默认格式：全局字体大小为 12px，行高设置为 1.5。这些属性直接赋予 &lt;body&gt; 元素和所有段落元素。另外，&lt;p&gt; 元素还被设置了 1/2 行高 (9px) 的底部外边距。 突出文字：通过添加 .lead 类可以让段落突出显示。 标记文字：一般使用 &lt;mark&gt; 标签来标记文本，显示高亮效果，也可以使用 .mark 。 删除字：对于被删除的文本使用 &lt;del&gt; 标签。 无用字：对于没用的文本使用 &lt;s&gt; 标签。 插入字：额外插入的文本使用 &lt;ins&gt; 标签。 下划线字：为文本添加下划线，使用 &lt;u&gt; 标签，一般表示专有名词或拼写错误的单词。 小号文字：使用 &lt;small&gt; 标签包裹，其内的文本将被设置为父容器字体大小的 85%，也可以使用 .mark 。 着重字：通过 &lt;strong&gt; 标签增加 font-weight 值强调一段文本。 斜体字：用 &lt;em&gt; 标签强调一段文本。 列表：给 &lt;ul&gt; 元素增加 .list-inline 内部的 &lt;li&gt; 会横向排列 对齐通过文本对齐类，可以简单方便的将文字重新对齐。 12345&lt;p class="text-left"&gt;左对齐文本。&lt;/p&gt;&lt;p class="text-center"&gt;居中对齐文本。&lt;/p&gt;&lt;p class="text-right"&gt;右对齐文本。&lt;/p&gt;&lt;p class="text-justify"&gt;两端对齐&lt;/p&gt;&lt;p class="text-nowrap"&gt;不折行文本&lt;/p&gt; 表格 基本实例：为任意 &lt;table&gt; 标签添加 .table 类可以为其赋予基本的样式：少量的内补（padding）和水平方向的分隔线。 隔行变色：通过 .table-striped 类可以给 &lt;tbody&gt; 之内的每一行增加斑马条纹样式。 表格的边框：添加 .table-bordered 类为表格和其中的每个单元格增加边框。 鼠标悬停：通过添加 .table-hover 类可以让 &lt;tbody&gt; 中的每一行对鼠标悬停状态作出响应。 状态类：通过这些状态类可以为行或单元格设置颜色：.selected当前被选中的行、 .active鼠标悬停在行上时所设置的颜色、 .success标识成功或积极的动作、 .info标识普通的提示信息或动作、 .warning标识警告或需要用户注意、 .danger标识危险或潜在的带来负面影响的动作。这些是设置在 &lt;tr&gt; 标签上的 表单基本实例 单独的表单控件会被自动赋予一些全局样式。 一个相关完整的表单项组以 .form-row 为类名，以获得整洁的排列。 最后一项表单项组可以加 .form-row-last 类（可选），以去除底部的外边距。 标题以 &lt;label&gt; 包裹，并设置 .form-label 类以使标题右对齐，为增大表单的焦点区域为 &lt;label&gt; 增加 for 属性，并以 for_ 开头对应表单元素的 id 属性。 紧接着 .form-act 元素，用以包裹表单元素。 所有设置了 .input-block 类的 &lt;input&gt;、&lt;textarea&gt; 和 &lt;select&gt; 元素都将被默认设置宽度属性为 width: 100%;。 12345678910111213141516171819202122232425&lt;form action="" method="post" role="form"&gt; &lt;div class="form-row"&gt; &lt;label for="for_username" class="form-label"&gt;用户名：&lt;/label&gt; &lt;span class="form-act"&gt; &lt;input type="text" name="" value="" id="for_username"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="form-row"&gt; &lt;label for="for_email" class="form-label"&gt;邮箱：&lt;/label&gt; &lt;span class="form-act"&gt; &lt;input type="email" name="" value="" id="for_email"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="form-row"&gt; &lt;label for="for_input_file" class="form-label"&gt;上传文件&lt;/label&gt; &lt;span class="form-act"&gt; &lt;input type="file" id="for_input_file"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="form-row-last"&gt; &lt;label class="form-act"&gt; &lt;input type="checkbox"&gt;复选框 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 纵向表单纵向表单是指标题和表单控件之间分行显示，此模式只需要在 &lt;form&gt; 标签加类名 .form-vertical 即可，其它结构与基本实例保持一致。 栅格化表单把基本表单与栅格布局结合在一起，创建出符合栅格化标准的表单，需要对类名做一些改变。 1234567891011121314151617181920212223242526&lt;form action="" method="post" role="form"&gt; &lt;div class="form-row row"&gt; &lt;label for="for_username" class="form-label col-2"&gt;用户名：&lt;/label&gt; &lt;span class="col-5"&gt; &lt;input type="text" name="" value="" id="for_username"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="form-row row"&gt; &lt;label for="for_email" class="form-label col-2"&gt;邮箱：&lt;/label&gt; &lt;span class="col-5"&gt; &lt;input type="email" name="" value="" id="for_email"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="form-row row"&gt; &lt;label for="for_input_file" class="form-label col-2"&gt;上传文件：&lt;/label&gt; &lt;span class="col-5"&gt; &lt;input type="file" id="for_input_file"&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class="form-row-last row"&gt; &lt;label for="" class="form-label col-2"&gt;&lt;/label&gt; &lt;label class="col-5"&gt; &lt;input type="checkbox"&gt;复选框 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; &lt;label&gt;元素的 .form-label 和表单容器的 .form-act 类名可以去掉可以保留，建议 .form-label 不要去掉。 在每个 .form-row 类名的元素上增加类名 .row，在 &lt;label&gt; 和表单的容器上增加 col-* 的类名。 也可以选择只对输入框有效果： 123456&lt;div class="form-row"&gt; &lt;label for="for_username" class="form-label"&gt;用户名：&lt;/label&gt; &lt;span class="form-act row input-row"&gt; &lt;input type="text" name="" value="" id="for_username" class="col-5"&gt; &lt;/span&gt;&lt;/div&gt; 只需要在表单的容器上增加 . row 和 .input-row 类名，在表单元素上增加 col-* 。 被支持的控件输入框 包括大部分表单控件、文本域控件、所有html5类型的输入控件。只有正确设置了 type 属性的输入控件才能被赋予正确的样式。 输入框焦点：某些表单控件的默认 outline 样式移除，然后在 :focus 状态下改变 border-color。 被禁用的输入框：为输入框设置 disabled 属性可以防止用户输入，并能对外观做一些修改，使其更直观。 只读输入框：为输入框设置 readonly 属性可以禁止用户输入，并且输入框的样式也是禁用状态。 多选框和单选框设置了 disabled 属性的单选或多选框都能被赋予合适的样式。对于一组多选或单选框可以用 .radio、.radio-inline、.checkbox、.checkbox-inline 类包裹。 123456789101112131415161718192021222324252627282930&lt;div class="checkbox"&gt; &lt;label for=""&gt; &lt;input type="checkbox" value="option1"&gt; 选项1,请确认 &lt;/label&gt;&lt;/div&gt;&lt;div class="checkbox"&gt; &lt;label for=""&gt; &lt;input type="checkbox" value="option2" disabled&gt; 选项2,禁止选取 &lt;/label&gt;&lt;/div&gt;&lt;div class="radio"&gt; &lt;label for=""&gt; &lt;input type="radio" value="option1" checked name="radios"&gt; 选项1,默认选择 &lt;/label&gt;&lt;/div&gt;&lt;div class="radio"&gt; &lt;label for=""&gt; &lt;input type="radio" value="option2" name="radios"&gt; 选项,请确认 &lt;/label&gt;&lt;/div&gt;&lt;div class="radio"&gt; &lt;label for=""&gt; &lt;input type="radio" value="option3" name="radios" disabled&gt; 选项1,禁止选取 &lt;/label&gt;&lt;/div&gt; 1234567891011121314151617181920&lt;label for="" class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox1" value="option1"&gt;选项1&lt;/label&gt;&lt;label for="" class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox2" value="option2"&gt;选项2&lt;/label&gt;&lt;label for="" class="checkbox-inline"&gt; &lt;input type="checkbox" id="inlineCheckbox3" value="option3"&gt;选项3&lt;/label&gt;&lt;br&gt;&lt;br&gt;&lt;label for="" class="radio-inline"&gt; &lt;input type="radio" name="inlineRadios" id="inlineCheckbox1" value="option1"&gt;选项1&lt;/label&gt;&lt;label for="" class="checkbox-inline"&gt; &lt;input type="radio" name="inlineRadios" id="inlineCheckbox2" value="option2"&gt;选项2&lt;/label&gt;&lt;label for="" class="checkbox-inline"&gt; &lt;input type="radio" name="inlineRadios" id="inlineCheckbox3" value="option3"&gt;选项3&lt;/label&gt; 下拉列表框使用默认选项或添加 multiple 属性可以同时显示多个选项。 12345678910111213141516&lt;select class="input-xln"&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; &lt;option&gt;选项4&lt;/option&gt; &lt;option&gt;选项5&lt;/option&gt;&lt;/select&gt;&lt;br&gt;&lt;br&gt;&lt;select multiple class="input-xln"&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; &lt;option&gt;选项4&lt;/option&gt; &lt;option&gt;选项5&lt;/option&gt;&lt;/select&gt; 状态校验B2B2C 对表单控件的校验状态，如 error 和 success 状态，都定义了样式。使用时，添加 .has-error 或 .has-success 类到这些控件的父元素即可。 任何包含在此元素之内的标题，输入框和信息提示都将接受这些校验状态的样式。 123456789101112131415&lt;div class="form-row has-success"&gt; &lt;label for="for_inputsuccess" class="form-label"&gt;输入正确&lt;/label&gt; &lt;div class="form-act"&gt; &lt;input type="text" id="for_inputsuccess"&gt; &lt;span class="icon-checkmark caution"&gt;通过&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="form-row has-error"&gt; &lt;label for="for_inputerror" class="form-label"&gt;输入错误&lt;/label&gt; &lt;div class="form-act"&gt; &lt;input type="text" id="for_inputerror"&gt; &lt;span class="icon-alert caution"&gt;此项必填&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819&lt;div class="has-success"&gt; &lt;div class="checkbox-inline"&gt; &lt;label for=""&gt; &lt;input type="checkbox" class="x-chcek" id="for_checkboxsuccess" value="option1"&gt; 复选框通过验证 &lt;/label&gt; &lt;/div&gt; &lt;span class="icon-checkmark caution"&gt;通过&lt;/span&gt;&lt;/div&gt;&lt;div class="has-error"&gt; &lt;div class="checkbox-inline"&gt; &lt;label for=""&gt; &lt;input type="checkbox" class="x-check" id="for_checkboxerror" value="option1"&gt; 复选框验证失败 &lt;/label&gt; &lt;/div&gt; &lt;span class="icon-alert caution"&gt;此项必填&lt;/span&gt;&lt;/div&gt; 输入框图标在需要为输入框内添加图标时，常规做法是为其父元素添加 .has-figure 类并给相应的图标添加 .input-figure 类。 123456789101112131415&lt;div class="form-row"&gt; &lt;label for="for_input_user" class="form-label"&gt;输入用户名：&lt;/label&gt; &lt;span class=" has-figure col-5"&gt; &lt;input type="text" class="input-block" id="for_input_user"&gt; &lt;i class="icon-user input-figure"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class="form-row"&gt; &lt;label for="for_input_pass" class="form-label"&gt;密码：&lt;/label&gt; &lt;span class=" has-figure col-5"&gt; &lt;input type="password" class="input-block" id="for_input_pass"&gt; &lt;i class="icon-lock input-figure"&gt;&lt;/i&gt; &lt;/span&gt;&lt;/div&gt; 还可以针对校验状态为输入框添加额外的图标。只需为其父元素添加 .has-figure 类并给相应的图标添加 .input-figure 类即可。 1234567891011121314&lt;div class="form-row has-error has-figure"&gt; &lt;label class="form-label" for="for_inputerror"&gt;输入错误&lt;/label&gt; &lt;span class="has-figure col-5"&gt; &lt;input type="text" class="input-block caution-input" id="for_inputerror"&gt; &lt;span class="icon-alert input-figure"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class="form-row has-success has-figure"&gt; &lt;label class="form-label" for="for_inputsuccess"&gt;输入正确&lt;/label&gt; &lt;span class="has-figure col-5"&gt; &lt;input type="text" class="input-block" id="for_inputsuccess"&gt; &lt;span class="icon-checkmark-a input-figure"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 控件尺寸通过 .input-lg 类似的类可以为控件设置高度，通过 .col-* 或 .input-ln 类似的类可以为控件设置宽度（长度）。 高度尺寸创建大一些或小一些的表单控件以匹配按钮尺寸。 123456&lt;input class="input-lg" type="text" placeholder=".input-lg" name="" value=""&gt;&lt;input type="text" placeholder="默认" name="" value=""&gt;&lt;input class="input-sm" type="text" placeholder=".input-sm" name="" value=""&gt;&lt;select name="" id="" class="input-lg"&gt;&lt;/select&gt;&lt;select name="" id="" &gt;&lt;/select&gt;&lt;select name="" id="" class="input-sm"&gt;&lt;/select&gt; 调整列（column）尺寸用栅格系统中的列（column）包裹输入框或其任何父元素，都可很容易的为其设置宽度。 12345&lt;div class="row input-row"&gt; &lt;input type="text" class="col-3" placeholder=".col-3"&gt; &lt;input type="text" class="col-4" placeholder=".col-4"&gt; &lt;input type="text" class="col-5" placeholder=".col-5"&gt;&lt;/div&gt; 调整输入框的长度为输入框加入 .input-ln 类似的类以调节输入框的长度。 1234567891011121314&lt;input type="text" class="input-xxst" placeholder=".input-xxst"&gt;&lt;br&gt;&lt;input type="text" class="input-xst" placeholder=".input-xst"&gt;&lt;br&gt;&lt;input type="text" class="input-st" placeholder=".input-st"&gt;&lt;br&gt;&lt;input type="text" class="input-me" placeholder=".input-me"&gt;&lt;br&gt;&lt;input type="text" class="input-ln" placeholder=".input-ln"&gt;&lt;br&gt;&lt;input type="text" class="input-xln" placeholder=".input-xln"&gt;&lt;br&gt;&lt;input type="text" class="input-xxln" placeholder=".input-xxln"&gt;&lt;br&gt; 辅助文本针对表单控件的块(block)级辅助文本 1&lt;span class="help-block"&gt;表单项的帮助提示信息&lt;/span&gt; 输入框组针对一些特殊功能或组件，定义了一些输入框组合，以 .input-comb 作为父容器，在内部加入 .input-comb-addon 元素作为功能图标，然后放入内容。 1234567891011121314151617181920212223242526&lt;div class="input-comb"&gt; &lt;input type="text" class="input-me"&gt; &lt;span class="input-comb-addon"&gt;&lt;i class="icon-calendar"&gt;&lt;/i&gt;&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="input-comb"&gt; &lt;span class="input-comb-addon"&gt;@&lt;/span&gt; &lt;input type="text" class="input-me"&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="input-comb"&gt; &lt;span class="input-comb-addon"&gt;¥&lt;/span&gt; &lt;input type="text" class="input-me"&gt; &lt;span class="input-comb-addon"&gt;&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="input-comb input-comb-lg"&gt; &lt;span class="input-comb-addon"&gt;¥&lt;/span&gt; &lt;input type="text" class="input-st"&gt; &lt;span class="input-comb-addon"&gt;.00&lt;/span&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="input-comb"&gt; &lt;input type="search" class="input-ln"&gt; &lt;button type="button" class="btn-input-comb-btn"&gt;&lt;span&gt;&lt;span&gt;搜索&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;/div&gt; 按钮预定义样式使用下面列出的类可以快速创建一个带有预定义样式的按钮。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;button type="button" class="btn"&gt; &lt;span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn"&gt; &lt;span&gt;&lt;span&gt;查看&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-flat"&gt; &lt;span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-flat"&gt; &lt;span&gt;&lt;span&gt;查看&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-simple"&gt; &lt;span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-simple"&gt; &lt;span&gt;&lt;span&gt;查看&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;button type="button" class="btn btn-primary"&gt; &lt;span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-primary"&gt; &lt;span&gt;&lt;span&gt;提交&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-success"&gt; &lt;span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-success"&gt; &lt;span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-info"&gt; &lt;span&gt;&lt;span&gt;信息&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-info"&gt; &lt;span&gt;&lt;span&gt;信息&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-warning"&gt; &lt;span&gt;&lt;span&gt;警告&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-warning"&gt; &lt;span&gt;&lt;span&gt;警告&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-danger"&gt; &lt;span&gt;&lt;span&gt;危险&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-danger"&gt; &lt;span&gt;&lt;span&gt;危险&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;button type="button" class="btn btn-caution"&gt; &lt;span&gt;&lt;span&gt;到货通知&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-caution"&gt; &lt;span&gt;&lt;span&gt;到货通知&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-link"&gt; &lt;span&gt;&lt;span&gt;继续&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;button type="button" class="btn btn-import"&gt; &lt;span&gt;&lt;span&gt;去付款&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-import"&gt; &lt;span&gt;&lt;span&gt;去付款&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-major"&gt; &lt;span&gt;&lt;span&gt;加入购物车&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-major"&gt; &lt;span&gt;&lt;span&gt;加入购物车&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-caution"&gt; &lt;span&gt;&lt;span&gt;到货通知&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-caution"&gt; &lt;span&gt;&lt;span&gt;到货通知&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 尺寸需要让按钮具有不同尺寸可以使用 .btn-sm、.btn-lg 或 .btn-xl 可以获得不同尺寸的按钮。 1234567891011121314151617181920212223&lt;button type="button" class="btn btn-simple btn-sm"&gt; &lt;span&gt;&lt;span&gt;清空购物车&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-simple btn-sm"&gt; &lt;span&gt;&lt;span&gt;继续购物&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-simple btn-lg"&gt; &lt;span&gt;&lt;span&gt;清空购物车&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-simple btn-lg"&gt; &lt;span&gt;&lt;span&gt;继续购物&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;button type="button" class="btn btn-simple btn-xl"&gt; &lt;span&gt;&lt;span&gt;清空购物车&lt;/span&gt;&lt;/span&gt;&lt;/button&gt;&lt;a href="" class="btn btn-simple btn-xl"&gt; &lt;span&gt;&lt;span&gt;继续购物&lt;/span&gt;&lt;/span&gt;&lt;/a&gt; 满屏按钮： .btn-block 类可以将按钮设为父元素100%的宽度。圆角按钮： .btn-rounded 类来为按钮增加圆角效果。禁用按钮： .disabled 类可以让样式变灰，但是ie9以下的版本比较难看。 辅助类文本颜色通过各种不同颜色的文本来表达不同的语义，你可以添加 .text-* 类来达到此效果。 12345&lt;p class="text-muted"&gt;一篇文档用text-muted类&lt;/p&gt;&lt;p class="text-success"&gt;一篇文档用text-success类&lt;/p&gt;&lt;p class="text-info"&gt;一篇文档用text-info类&lt;/p&gt;&lt;p class="text-warning"&gt;一篇文档用text-warning类&lt;/p&gt;&lt;p class="text-danger"&gt;一篇文档用text-danger类&lt;/p&gt; 背景颜色类似于文本颜色类，你也可以通过添加不同的 .bg-* 类来表达不同的语义。(PS:不知道为何实际css中设置仍然是前景色) 12345678&lt;p class="bg-yellow"&gt;文本的背景颜色bg-yellow类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-alert"&gt;文本的背景颜色bg-alert类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-success"&gt;文本的背景颜色bg-success类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-info"&gt;文本的背景颜色bg-info类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-warning"&gt;文本的背景颜色bg-warning类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-danger"&gt;文本的背景颜色bg-danger类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-error"&gt;文本的背景颜色bg-error类&lt;/p&gt;&lt;br&gt;&lt;p class="bg-selected"&gt;文本的背景颜色bg-selected类&lt;/p&gt;&lt;br&gt; 关闭和三角符号通过使用一个象征关闭的图标，可以让模态框和警告框消失。 通过使用三角符号可以指示某个元素具有下拉菜单的功能。注意，向上弹出式菜单中的三角符号是反方向的。 12345&lt;button type="button" class="close"&gt; &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;span class="hide"&gt;关闭&lt;/span&gt;&lt;/button&gt;&lt;span class="caret"&gt;&lt;/span&gt; 浮动左浮动和有浮动使用的类名，内部都使用了!important。 清除浮动有两种方式：第一种是在父元素加 .clearfix 类，第二种是在后方元素加入 .clear 元素。 12345&lt;div class="clearfix"&gt; &lt;div class="pull-left"&gt;...&lt;/div&gt; &lt;div class="pull-right"&gt;...&lt;/div&gt;&lt;/div&gt;&lt;div class="clear"&gt;&lt;/div&gt; 显示隐藏内容对于元素的显示和隐藏分别使用 .show 和 .hide 类切换。也加入了 !important。请注意它们只适合块级元素的切换。 对于元素是否可见，还可以使用 .visible 和 .hidden 来实现，区别是它们会继续占用原来的位置和大小。 1234&lt;div class="show"&gt;...&lt;/div&gt;&lt;div class="hide"&gt;...&lt;/div&gt;&lt;div class="visible"&gt;...&lt;/div&gt;&lt;div class="hidden"&gt;...&lt;/div&gt; 图像占位文本利用 .text-hide 类隐藏文本内容，以便用图像替换。 1&lt;h1 class="text-hide"&gt;自定义标题&lt;/h1&gt; 路径导航在一个带有层次的导航结构中标明当前页面的位置。各路径间的分隔符通过 CSS 的 :before 生成，无需再次添加。 12345&lt;ol class="breadcrumb"&gt; &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;商品列表&lt;/a&gt;&lt;/li&gt; &lt;li class="active"&gt;商品品牌&lt;/li&gt;&lt;/ol&gt; 分页带有展示页码的分页组件，或者可以使用简单的翻页组件。 标准的分页12345678910&lt;div class="pager"&gt; &lt;span class="flip prev disabled"&gt;&amp;lsaquo;&lt;/span&gt; &lt;a href="#" class="flip"&gt;1&lt;/a&gt; &lt;a href="#" class="flip"&gt;2&lt;/a&gt; &lt;a href="#" class="flip active"&gt;3&lt;/a&gt; &lt;span class="ellipsis"&gt;...&lt;/span&gt; &lt;a href="#" class="flip"&gt;4&lt;/a&gt; &lt;a href="#" class="flip"&gt;5&lt;/a&gt; &lt;a href="#" class="flip next"&gt;&amp;rsaquo;&lt;/a&gt;&lt;/div&gt; 更小的分页加入 .page-sm 就会得到更小尺寸的分页 12345678910&lt;div class="pager pager-sm"&gt; &lt;span class="flip prev disabled"&gt;&amp;lsaquo;&lt;/span&gt; &lt;a href="#" class="flip"&gt;1&lt;/a&gt; &lt;a href="#" class="flip"&gt;2&lt;/a&gt; &lt;a href="#" class="flip active"&gt;3&lt;/a&gt; &lt;span class="ellipsis"&gt;...&lt;/span&gt; &lt;a href="#" class="flip"&gt;4&lt;/a&gt; &lt;a href="#" class="flip"&gt;5&lt;/a&gt; &lt;a href="#" class="flip next"&gt;&amp;rsaquo;&lt;/a&gt;&lt;/div&gt; 标签1234567&lt;span class="label"&gt;新&lt;/span&gt;&lt;span class="label label-disabled"&gt;新&lt;/span&gt;&lt;span class="label label-primary"&gt;新&lt;/span&gt;&lt;span class="label label-success"&gt;新&lt;/span&gt;&lt;span class="label label-info"&gt;新&lt;/span&gt;&lt;span class="label label-warning"&gt;新&lt;/span&gt;&lt;span class="label label-danger"&gt;新&lt;/span&gt; 指示给链接、导航等元素嵌套 .point 元素，可以很醒目的展示新的或未读的信息条目。 1234567&lt;span class="point"&gt;5&lt;/span&gt;&lt;span class="point"&gt;10&lt;/span&gt;&lt;span class="point"&gt;245&lt;/span&gt;&lt;span class="point point-disabled"&gt;0&lt;/span&gt;&lt;span class="point point-sm"&gt;5&lt;/span&gt;&lt;span class="point point-sm"&gt;10&lt;/span&gt;&lt;span class="point point-sm"&gt;245&lt;/span&gt; 警告框将任意文本包裹在以下类中就能组成一个警告框，每个类分别代表不同的警告信息。 12345&lt;div class="alert"&gt;&lt;span class="icon-alert"&gt;&lt;/span&gt; alert提示提醒注意！&lt;/div&gt;&lt;div class="info"&gt;&lt;span class="icon-info"&gt;&lt;/span&gt; info提示提醒注意！&lt;/div&gt;&lt;div class="warning"&gt;&lt;span class="icon-tip"&gt;&lt;/span&gt; warning提示提醒注意！&lt;/div&gt;&lt;div class="danger"&gt;&lt;span class="icon-close-b"&gt;&lt;/span&gt; danger提示提醒注意！&lt;/div&gt;&lt;div class="success"&gt;&lt;span class="icon-checkmark-c"&gt;&lt;/span&gt; success提示提醒注意！&lt;/div&gt; 字体图标 增加的css .ablock ：display: block; width: 100%; height: 100%; .line-clamp1: 文本一行显示。 .line-clamp2: 文本两行显示。 .price-font：¥符号的字体样式，带这个符号的元素都要加这个类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[wamp安装]]></title>
      <url>%2F2017%2F09%2F11%2Fwamp%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[wamp安装wamp的简介wamp Windows + Apache + Mysql + PHP。继承安装环境，即在window下的apache、php和mysql的服务器软件。 Apache Apache是世界使用排名第一的Web服务器软件。它可以运行在几乎所有广泛使用的计算机平台上。 由于其跨平台和安全性被广泛使用，是最流行的Web服务器端软件之一。 MySQL MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下公司。 MySQL 最流行的关系型数据库管理系统，在 WEB 应用方面MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 PHP php 的运行环境。 wamp的配置配置ip 需要配置wamp\bin\apache\Apache2.2.21\conf下的httpd.conf文件。 在Allow from 127.0.0.1下面的一行添加一行Allow from all。 默认文件地址 网页默认是放在wamp/www文件夹下才能使用ip地址访问，这个文件夹的位置可以更改，还是httpd.conf文件。 修改DocumentRoot 后面跟文件路径，将文件路径改为自己要设置的即可，Directiry也要和DocumentRoot相同。 hosts 在实际中访问网页都是通过域名来访问。 浏览器会先去找C:\Windows\System32\drivers\etc下的hosts文件。在这里找不到才会取到外网找，所以可以在这里做拦截，比如在文件最后添加一行127.0.0.1 www.taobao.com。那么通过浏览器访问www.taobao.com就会跳转到Apache的默认目录。同理www.jd.com也可以这样设置 开启虚拟主机 如果要做到jd和taobao访问的是本地不同网页，要修改httpd.conf文件的Include conf/extra/httpd-vhosts.conf，将前面的备注取消 Virtual hosts的备注也取消。 然后打开extra文件下下的httpd-vhosts.conf文件。修改以下三项，以taobao 为例：DocumentRoot：taobao.com、ServerName：www.taobao.com、ServerAlias：路径/taobao，其他无需修改。如果要增加就复制这段配置后再修改。 在Apache默认路径下新建taobao文件夹，并建立index文件，Apache默认会打开文件夹下面的index，如果没有index会显示该文件夹下的所有目录。 通过ip地址访问会访问httpd-vhosts.conf的第一个地址。 需要注意的是以上每项修改完之后都要重启一下Apache服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bbc的tool.js]]></title>
      <url>%2F2017%2F09%2F11%2Fbbc%E7%9A%84js%2F</url>
      <content type="text"><![CDATA[工具类函数 tools.js判断是否为 dom 元素函数： isElement(dom) 作用： 判断参数是否为一个 dom 元素。 参数： jQuery对象或dom对象 返回值： (Boolean)是 dom 对象返回 true，否则返回 false。 12345678//判断是否为dom元素function isElement(dom) &#123; if(dom instanceof jQuery) &#123; dom = dom[0]; &#125; if(!dom) return false; return dom.nodeName &amp;&amp; dom.nodeType === 1;&#125; 使用isElement： 1&lt;div id="box"&gt;&lt;/div&gt; 1234var box = document.getElementById('box');var flag = isElement($('#box')); // truevar falg1 = isElement(box); // truevar flag2 = isElement('#box') // false 模板字符替换函数： substitute(string, object) 作用： 以json直接量替换字符串中的 {xx} 部分，可看做一个简单的html模板 参数： string：要被替换的字符串 object：对应的json直接量 返回值： (String)被替换后的字符串 123456function substitute(string, object) &#123; return string.replace(/\\?\&#123;([^&#123;&#125;]+)\&#125;/g, function(match, name)&#123; if (match.charAt(0) === '\\') return match.slice(1); return (object[name] != null) ? object[name] : ''; &#125;);&#125; 使用substitute： 123456789var config = &#123; data : &#123;value : '123',text:'abc'&#125;, template : '&lt;label&gt;&#123;text&#125;&lt;/label&gt;&lt;input type="text" value="&#123;value&#125;"/&gt;'&#125;;var s = substitute(config.template,config.data);console.log(s);// 打印: &lt;label&gt;abc&lt;/label&gt;&lt;input type="text" value="123"/&gt; 页面最大 z-index函数： maxZindex(scope, increase) 作用： 获取页面所有元素中最大的z-index是多少 参数： scope：查找范围的dom元素，这里dom元素不是指的父元素，而是直接含有定位属性的元素。 increase：增量 返回值： (Number)最终计算的结果 1234567891011121314151617181920212223function maxZindex(scope, increase) &#123; scope = scope || 'div'; scope = $(scope); var max = 0; if(scope.length) &#123; var pos = scope.filter(function(i,el)&#123; // 如果el不是一个dom对象，或者是'script', 'link', 'base', 'style'中的一个就没必要去管 if(!isElement(el) || ['script', 'link', 'base', 'style'].indexOf(el.tagName.toLowerCase()) &gt; -1) return; // 判断el有没有'absolute','relative','fixed'中的一个属性 return ['absolute','relative','fixed'].indexOf($(el).css('position')) &gt; -1; &#125;); // 获取有定位的元素中最大的z-index值 if(pos.length) &#123; for(var i=0, j=pos.length;i&lt;j;i++) &#123; var z = pos.eq(i).css('z-index'); max = Math.max(max, isNaN(z) ? 0 : z); &#125; &#125; &#125; if(increase) max += parseInt(increase); // z-index的最大值是2147483647 return Math.min(max, 2147483647);&#125; 使用maxZindex： 123var maxZ = maxZindex('div',10);console.log(maxZ); // 假如页面中的div元素定位最高为100，那么会打印110 获取配置项函数： dataOptions(element, prefix) 作用： 从元素的 data- 属性中组织出配置项，以JSON方式输出，主要是对 data-xxx-xxx 这种两个-及以上连接的属性，目的就是只保留最后一个 xxx 作为属性名。 参数： element: 要获取的目标dom元素。 prefix: 必需，前缀，在 data- 后面、要获取的配置项名前面。 返回值： (JSON)最终配置项 123456789101112131415161718192021function dataOptions1(element, prefix)&#123; if(!prefix) return false; // prefix参数的值为select // 这里通过data后，像data-select-time会被解析为selectTime，去取消-改为驼峰 var data = $(element).data(), out = &#123;&#125;, inkey, replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'); // replace是为了获取驼峰写法/select([A-Z])/ prefix = new RegExp('^' + prefix.toLowerCase()); for (var key in data) &#123; // 匹配所有带有select的属性，key现在是驼峰写法selectT if (prefix.test(key))&#123; inkey = key.replace(replace, function(_, a)&#123; // 将selectT替换为小写t return a.toLowerCase(); &#125;); out[inkey] = data[key]; &#125; &#125; return out;&#125; 使用dataOptions1： 123&lt;div class="test" data-select-time="3000" data-select-name="box"&gt; 1111111111111111&lt;/div&gt; 12345var obj = dataOptions1('.test','select')console.log(obj)// 打印 &#123; name: "box",time: 3000 &#125; 倒计时时钟函数： countdown(element, options) 作用： 通用倒计时，包括倒计时所在容器，倒数秒数，显示方式，回调。 参数： element: 要显示的位置的dom元素 options: 配置参数，包含以下参数： start：倒计时的秒数 secondOnly：显示方式（是否只显示秒） callback：倒计时完成后的回调 返回值： 无 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function countdown(element, options)&#123; var self = this; options = $.extend(&#123; start: 60, secondOnly: false, callback: null &#125;, options || &#123;&#125;); var t = options.start; var sec = options.secondOnly; var fn = options.callback; var d = +new Date(); var diff = Math.round((d + t * 1000) / 1000); this.timer = timeout(element, diff, fn); this.stop = function() &#123; clearTimeout(self.timer); &#125;; function timeout(element, until, fn) &#123; var str = '', started = false, left = &#123;d: 0, h: 0, m: 0, s: 0, t: 0&#125;, current = Math.round(+new Date() / 1000), data = &#123;d: '天', h: '时', m: '分', s: '秒'&#125;; left.s = until - current; if (left.s &lt; 0) &#123; return; &#125; else if(left.s == 0) &#123; // fn &amp;&amp; fn(); fn &amp;&amp; fn.call(element,null); &#125; if(!sec) &#123; if (Math.floor(left.s / 86400) &gt; 0) &#123; left.d = Math.floor(left.s / 86400); left.s = left.s % 86400; str += left.d + data.d; started = true; &#125; if (Math.floor(left.s / 3600) &gt; 0) &#123; left.h = Math.floor(left.s / 3600); left.s = left.s % 3600; started = true; &#125; &#125; if (started) &#123; str += ' ' + left.h + data.h; started = true; &#125; if(!sec) &#123; if (Math.floor(left.s / 60) &gt; 0) &#123; left.m = Math.floor(left.s / 60); left.s = left.s % 60; started = true; &#125; &#125; if (started) &#123; str += ' ' + left.m + data.m; started = true; &#125; if (Math.floor(left.s) &gt; 0) &#123; started = true; &#125; if (started) &#123; str += ' ' + left.s + data.s; started = true; &#125; $(element).html(str); return setTimeout(function() &#123;timeout(element, until,fn);&#125;, 1000); &#125;&#125; 使用countdown： 1234567countdown($('#box'),&#123; start: 6000, secondOnly: false, callback: function()&#123; // do something; &#125;&#125;) 获取元素的内补或外补函数： $.fn.patch(type) 作用： 获取元素内边距、外边距或边框宽度 参数： type：获取哪一部分样式，可以为padding、margin、border，不传参数是三个都获取。 返回值： (JSON)根据type计算出的最终结果{x:number, y:number}，x是left+right，y是top+bottom 1234567891011121314151617181920212223242526272829303132$.fn.patch = function (type) &#123; var el = this; var args; if (type) &#123; args = $.makeArray(type); // 将参数转换为真数组 &#125; else &#123; args = ['margin', 'padding', 'border']; &#125; var _return = &#123; x: 0, y: 0 &#125;; // 这里遍历2次（x、y） $.each(&#123;x: ['left', 'right'], y: ['top', 'bottom']&#125;, function(p1, p2) &#123; // 这里遍历2次（['left', 'right']和['top', 'bottom']） $.each(p2, function(i, p) &#123; try &#123; // 遍历三次（'margin', 'padding', 'border'），或者是1次（参数） $.each(args, function(i, arg) &#123; // ['margin', 'padding', 'border']的left、right、top、bottom arg += '-' + p; // 如果是border只需要获取width就行，因为border 有很多其他属性 if (arg.indexOf('border') == 0) arg += '-width'; _return[p1] += parseInt(el.css(arg)) || 0; &#125;); &#125; catch(e) &#123;&#125; &#125;); &#125;); return _return;&#125;; 使用patch： 12345678910&lt;style&gt; .test&#123; margin: 10px; padding: 10px 20px; border: 2px solid #000; &#125;&lt;/style&gt;&lt;div class="test" data-select-time="3000" data-select-name="box"&gt;1111111111111111&lt;/div&gt; 12345var result = $('.test').patch()console.log(result); // 打印 &#123; x: 64, y: 44&#125; dom 9点定位函数： $.fn.locate(options) 作用： 根据9个方位由一个dom定位到另一个dom上的位置 参数： - options：配置项的JSON直接量，包括： - relative：调用元素的父元素，默认为body - x：定位dom的x轴的位置，默认为center，可选left、right - y：定位dom的y轴的位置，默认为center，可选top、bottom - pos：定位方式，可选absolute和fixed，默认absolute - offset：设置偏移量，默认是 0。 返回值： (DOM)自身 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//双dom9点定位，支持绝对定位和固定定位$.fn.locate = function (options) &#123; options = $.extend(&#123; relative: document.body, // 应该是父元素 x: 'center', //left center right y: 'center', // top center riht pos: 'absolute', // 定位方式 //top center bottom offset: &#123; //偏移量 x: 0, y: 0 &#125; &#125;, options); var left, top, x, y, offset = options.offset, el = $(options.relative), // el是父元素 $this = $(this).css('position', options.pos), // 调用元素的定位方式 h = $this.height(), // 调用元素的高度 w = $this.width(), // 调用元素的宽度 // innerHeight不含边框和外边距 elH = (el.is('body') ? $('body') : el).innerHeight(), // 判断父元素是不是body，获取父元素的高度 elW = el.innerWidth(); // 获取父元素的宽度 // 绝对定位 if (options.pos === 'absolute') &#123; //left定位 switch (options.x) &#123; case 0: case 'left': x = 0; break; case 'right': x = elW - w; break; default: x = parseInt((elW - w) / 2); // 默认居中 break; &#125; // top定位 switch (options.y) &#123; case 0: case 'top': y = 0; break; case 'bottom': y = elH - h; break; default: y = parseInt((elH - h) / 2); break; &#125; // 定位的数值加上父元素的边距 el.scrollLeft()??? left = Math.max(0, Math.floor(x + (el.offset() ? el.offset().left : 0) + el.scrollLeft())); top = Math.max(0, Math.floor(y + (el.offset() ? el.offset().top : 0) + el.scrollTop())); if ($.isPlainObject(offset)) &#123; left += offset.x || 0; top += offset.y || 0; &#125; $this.css(&#123; left: left, top: top &#125;); // 固定定位只能居中 &#125; else if (options.pos === 'fixed') &#123; left = '50%'; top = '50%'; $this.css(&#123; left: left, top: top, marginLeft: -w / 2, marginTop: -h / 2 &#125;); &#125; return this;&#125;; 数组some方法函数： Array.some(fn, thisArg) 作用： 为不支持数组some方法的浏览器增加some方法，使得回调中执行的结果只要有一个为真值，就返回true，否则为false。它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略。 some 不会改变原有数组。 参数： - fn：要对每个数组元素执行的回调函数，此函数可以有三个参数：当前元素，当前元素的索引和当前的数组对象。 - thisArg：在执行回调函数时定义的this对象。如果没有定义或者为null，那么将会使用全局对象。 返回值： (Boolean)根据执行结果返回true或false 1234567891011121314if (!Array.prototype.some) &#123; Array.prototype.some = function(fn, thisArg) &#123; var i = 0, n = this.length; for (; i &lt; n; i++) &#123; // 给isBigEnough传值 if (i in this &amp;&amp; fn.call(thisArg, this[i], i, this)) &#123; return true; &#125; &#125; return false; &#125;;&#125; 使用some方法： 123456function isBigEnough(element, index, array) &#123; // 这里是判断数组是否有比10大的数字 return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough); // false 数组every方法函数： Array.every(fn, thisArg) 作用： 为不支持数组every方法的浏览器增加every方法，使得回调中执行的结果必须全部为真值，才返回true，否则为false。它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略。 every 不会改变原有数组。 参数： - fn：要对每个数组元素执行的回调函数，此函数可以有三个参数：当前元素，当前元素的索引和当前的数组对象。 - thisArg：在执行回调函数时定义的this对象。如果没有定义或者为null，那么将会使用全局对象。 返回值： (Boolean)根据执行结果返回true或false 1234567891011if (!Array.prototype.every) &#123; Array.prototype.every = function(fn, thisArg) &#123; var i = 0, n = this.length; for (; i &lt; n; i++) &#123; if (i in this &amp;&amp; !fn.call(thisArg, this[i], i, this)) &#123; return false; &#125; &#125; return true; &#125;;&#125; 使用some方法： 123456789function isBigEnough(element, index, array) &#123; // 这里是判断数组的元素是否全部大于10 return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// falsevar passed1 = [12, 54, 18, 130, 44].every(isBigEnough);// true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ionic环境配置(android)]]></title>
      <url>%2F2017%2F09%2F10%2Fionic%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE(android)%2F</url>
      <content type="text"><![CDATA[系统环境搭建安装java jdk点击这里下载 java jdk 下载后双击打开安装 配置jdk环境变量 增加系统变量 JAVA_HOME 把jdk的安装路径复制即可 新增系统变量 CLASSPATH，值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar，注意复制开头的点。 在Path系统变量的后面增加 %JAVA_HOME%\bin 注意每个路径之间用 ; 分开 打开cmd，输入javac能正常运行即可 安装android adt点击这里下载 android sdk 安装完毕后在目录用管理员身份打开SDK Manager.exe。建议设置国内镜像地址 需要安装的更新有以下这些。 设置 android sdk 环境变量 新建系统变量 ANDROID_HOME，值为android sdk的安装路径 在Path系统变量后面增加 %ANDROID_HOME%\platform-tools;%ANDROID_HOME%\tools 打开cmd 正常执行adb命令即可 安装C++直接在百度搜索即可。也可以下载Visual Studio只安装C++部分。 node环境 直接在node官网或者node中文网下载即可 git环境git官网的下载页面 项目依赖环境搭建cordova打开cmd，下载npm install -g cordova ionic打开cmd，下载npm install -g ionic 项目搭建创建项目模板打开cmd，输入ionic start myApp (muApp是项目名)。 tabs是默认样式，还有Ionic start myApp blank和Ionic start myApp sidemenu 打包App添加项目平台进入刚才下载的项目，打开cmd，执行ionic platform add android 打包成apk在项目目录下打开cmd执行ionic build android。打包成功后文件存放位置会有提示 添加项目平台报错的情况如果命令框一直出现……………… ctrl+c 直接退出，下载.gradle.zip解压后放到 用户名-&gt;users下。 .gradle文件夹下应该有四个文件夹：caches、daemon、native、wrapper 再运行Ionic platform add android 出现Picked up _JAVA_OPTIONS: -Xmx512M 在.gradle文件夹建一个文件gradle.properties。 记事本打开内容设置为 org.gradle.jvmargs=-Xmx2048m -XX:MaxPermSize=3072m【最后面这个3072是我根据自己电脑运行内存修改的，因为之前报过错误not enough space什么的忘记了，电脑是2g内存，在想是不是不够内存运行虚拟机什么的所以我去维修点换成了3g，1g就1024，我3g所以就改成了3072，具体看自己电脑内存。】 有可能是它在执行命令的时候download jar包的时候网络不好什么的，所以报错了缺少哪个文件失败了。反正我又重新来一遍了，因为资源都是下载在myApp里面的platform文件夹里【不完整】，所以我就整个都删掉了然后重新执行命令 ionic platform add android。 注意以上错误改完后再运行ionic platform add android，会提示platform added 已经被添加。只要删除目录下的platform文件夹就行，这里面就是打包的内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端开发----基础知识]]></title>
      <url>%2F2017%2F09%2F10%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E2%80%94-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
      <content type="text"><![CDATA[屏幕移动设备与PC设备最大的差异在于屏幕，这主要体现在屏幕尺寸和屏幕分辨率两个方面。 通常我们所指的屏幕尺，实际上指的是屏幕对角线的长度（一般用英寸来度量） 分辨率则一般用像素来度量，表示屏幕水平和垂直方向的像素数，例如1920*1080指的是屏幕垂直方向和水平方向分别有1920和1080个像素点而构成 像素的概念长度单位在web开发中可以使用px、em、pt、cm、in等作为长度单位 相对长度单位：在不同屏幕上大小不同，没有固定长度，比如像素。 绝对长度单位：在任何场合任何场景带下是固定不会变的，比如cm，in。 像素密度像素密度指的是每英寸面积中可容纳的像素点数。用PPI或者DPI来表示像素密度的单位。 PPI或者DPI的计算公式如下： 密度越高画面约清晰.比如：iphone 3GS 163ppi 480 * 320像素 3.5英寸iphone 4S 330ppi 960 * 640像素 3.5英寸iphone 4S 的屏幕要比 iphone 3GS清晰很多。结论：屏幕尺寸固定时，PPI越大，像素的实际大小就会越小，当PPI越小，像素实际大小就越大。 在手机屏幕大小一样的情况下，一个像素大小已经不固定了，开发网页时再使用像素作为单位已经不太合适。 比如设定一个盒子为320px，在iphone 3G上就满屏了，在iphone 4上就只有一半。 保证图像内容在不同PPI设备看上去大小应该差不多，这就是独立像素。在IOS设备上叫做PT在安卓上叫做DP。 我们可以设置44 * 44dp，这时在iPhone3G/S上代表44 * 44px，在iPhone4/S上代表88 * 88px，最终用可以看到的图像差不多大小。 dp或者pt同px是有一个对应（比例）关系的，这个对应（比例）关系是操作系统确定并处理。通过window.devicePixelRatio可以获得该比例值 物理像素以上所有的像素的概念都是物理像素，也就是屏幕渲染图像的最小单位。属于屏幕的物理属性，我们没法改变。 获取屏幕的物理像素：window.screen.widthwindow.screen.height CSS像素CSS像素指的是通过CSS进行网页布局时用到的单位。 width = 100px; 这个px指的就是css像素，正常情况下，1css像素=1物理像素。 但是在缩放页面的比例时，屏幕物理像素不变，而css像素会成比例变化，所以1个物理像素并不总是等于一个CSS像素。 在PC上，物理像素和CSS像素是保持一致的，所以没什么意义，主要是用在移动端。 视口的概念(viewport)PC端视口在PC设备上是取决于浏览器窗口的大小，约束了最顶级元素 &lt;html&gt;，决定了 &lt;html&gt; 元素的大小。 在PC端，默认情况下获取了 &lt;html&gt; 大小也就获取到了视口的大小document.documentElement.clientWidth;document.documentElement.clientHeight; &lt;html&gt; 元素大小是会影响我们的网页布局，父盒子的宽度变小了，会影响子盒子的布局。 如果要让子盒子一直保持不变，那就需要设定父盒子的固定宽度，不让它继承 &lt;html&gt; 的宽度，这样再调整浏览器窗口的大小。 由于父盒子宽度不变，子盒子布局也不会乱，只不过浏览器窗口缩小会出现滚动条，但是布局没有乱。 移动端移动端设备普遍比较小，移动端浏览网页也是通过浏览器，而过去网页大部分都是为PC设备来设计的。 由于移动端浏览器窗口小，那么浏览PC端网页布局有可能也会错乱。 浏览器厂商为了避免这种情况，就将视口的宽度设置一个比较大的值。视口的值变大了 &lt;html&gt; 的值也就变大了。 在移动设备上视口的大小不取决于浏览器的大小了，而是浏览器厂商允许开发者改变视口大小。 通常厂商会设定980px位默认视口大小。后果是会出现滚动条，或者实惠被缩放的很小。 布局视口(layout viewport)和理想视口(ideal viewport)布局视口和理想视口，在实际开发中只有视口这个概念，区分理想视口和布局视口只是单纯为了理解视口的概念。 布局视口指的是我们可以进行网页布局区域的大小。也就是 &lt;html&gt; 的大小.document.documentElement.clientWidth;document.documentElement.clientHeight; 理想视口指的是移动设备屏幕的区域。不同设备区域尺寸不同。但这个尺寸指的不是屏幕实际像素，而是独立像素。PT或者DP。这是安卓程序员和IOS程序员使用的单位。 前端在开发时依然是要使用px作为单位。也就是CSS像素。以iphone 5s 举例，它的分辨率是1136 * 640，换算到px单位也就是568 * 320，同设备独立像素一样，也是用实际设备像素/比例的结果。window.screen.widthwindow.screen.height 滚动条和缩放布局视口要放到理想视口下去显示，布局视口是比较大的，通常980px，而理想视口比较小，也就是手机尺寸的宽。 那么大盒子放到小盒子中就会出现滚动条，如果不想出现滚动条就要将大盒子缩放至正好放进小盒子的比例。 该出现滚动条还是该缩放并没有统一的规定，全看厂商自己的想法 2倍图比如一张图片的尺寸是165 * 80px。在iphone 3GS和iphone 4S上 都设为165dp * 80dp；这时图片在iphone 3GS上 尺寸是165px * 80px；而在iphone 4S上会被拉成330px * 160px因为iphone 4S 1dp = 2px ，图片会失真变模糊。这就是需要2倍图的原因。 移动浏览器系统自带浏览器：滚岁移动设备一起安装的浏览器 应用内置浏览器：在手机APP内部打开某个链接，就是通过应用内置浏览器打开的。这个浏览器更重要一些。APP的内容可以通过网页来展现，也就是通过H5和C3来写。升级方便。不需要下载，有新内容只需要刷新就行 第三方浏览器：浏览器厂商开发的移动端浏览器APP 屏幕适配控制缩放屏幕适配最理想的状态就是没有缩放并且也没有滚动条 出现缩放和滚动条主要原因就是布局视口过大于理想视口，如果这两个一样大，就不会缩放和出现滚动条。 通过 &lt;meta&gt; 进行控制1&lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt; viewport是苹果为了移动设备浏览器提出的解决方案，后来被其他移动设备厂商采纳 通过设置 width=device-width，让布局视口的宽=设备屏幕的宽。当然这里的宽依然指的是独立像素。 initial-scale=1，设置页面初始缩放。让浏览器缩放比例一直为1。默认的缩放比例 = device-width \/ 980。 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数。 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数。 user-scalable 是否允许用户进行缩放，值为”no”或”yes”。 width=device-width 和 initial-scale=1 效果相同，但是开发时通常将这两句都加上，防止出现兼容性问题。 避免滚动以上设置完毕后假如viewport的宽是320px，这时设置一个盒子的宽为480px，就会出现滚动条没因为已经限制了视口的缩放和大小。 但是这个值也不能写死，要不然换个设备又会出问题，所以移动设备的宽度最好使用百分比。 适配方案不管哪种适配方案，设置 &lt;meta&gt; 标签都是必须的。 固定宽度必须让内容区域小于屏幕宽度，根据现在市场情况一般设置最大宽度为320px。 www.viewportsizes.com 保存了现有所有手机屏幕尺寸的信息。 不让内容超出320px也就不会出现滚动。 缺点是宽度大于320px的设备两边会留白，但也是可以接受。可以正常访问。 百分比宽度width和height都是相对于父元素的高和宽，但实际height写百分比没什么意义，通常都是被内容撑开 padding的百分比是相对于父元素的width值 margin的百分比是相对于父元素的width值 border不支持百分比的宽度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[clipboard]]></title>
      <url>%2F2017%2F08%2F30%2Fclipboard%2F</url>
      <content type="text"><![CDATA[这里传入的参数是复制按钮的选择器。 12// 一键复制var clipboard = new Clipboard('#copy'); 复制成功的回调函数： 1234// 复制成功clipboard.on('success', function(e) &#123; // 这里可以显示复制成功的提示&#125;); 复制失败的回调函数： 1234// 复制失败clipboard.on('error', function(e) &#123; // 复制失败的提示，复制失败时可以让用户手动复制&#125;); 根据之前的测试，安卓和ios上都没遇到什么问题，安卓都是6.0以上的机器，ios都是8.0以上，手上并没有旧机器测试，总之不能复制时还是可以给出提示让其手工全选复制的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》十三、jQuery加载并解析XML]]></title>
      <url>%2F2017%2F08%2F23%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%8D%81%E4%B8%89%E3%80%81jQuery%E5%8A%A0%E8%BD%BD%E5%B9%B6%E8%A7%A3%E6%9E%90XML%2F</url>
      <content type="text"><![CDATA[语法XML(eXtensible Markup Language)，于HTML一样，都属于SGML标准通用语言。 XML的语法如下： 任何起始标签都必须有一个结束标签 标签必须按照合理的顺序嵌套，和HTML相同的道理。 所有属性都需要有值，并且需要在值上加上双引号。 XML文件只能有一个顶层元素，好比HTML的&lt;html&gt;元素。 很多时候XML不能正常解析是因为Content-Type没有设置好。要设置为text/xml，否则会按照默认的text/html方式处理，导致解析失败 解析XML解析XML文档与解析DOM一样，也可以用find()、children()等函数来解析和用each()方法来进行遍历，另外也可以用text()和attr()方法来获取节点文本和属性（类似HTML的行内属性）。 12345678910success: function(xml)&#123; var frag = $('&lt;ul&gt;&lt;/ul&gt;') $(xml).find('student').each(function()&#123; // 查找所有&lt;student&gt;节点并且遍历 var id = $(this).children('id'); // 取得所有&lt;id&gt;&lt;/id&gt;子节点 var id_value = id.text(); // 取得子节点文本 var email = $(this).attr('email'); // 获取&lt;student&gt;元素上的email属性 frag.append('&lt;li&gt;' + id_value + '-' + email + '&lt;/li&gt;'); // 构造html字符串 &#125;) frag.appendTo('#load'); // 最后添加到html文档中&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》九、$.ajax()的方法]]></title>
      <url>%2F2017%2F08%2F22%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B9%9D%E3%80%81%24-ajax()%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[参数名称 类型 说明 accepts Map 内容类型发送请求头，告诉服务器什么样的响应会接受返回。如果accepts设置需要修改，推荐在$.ajaxSetup()方法中做一次。 async Boolean 默认设置下（默认为true），所有请求均为异步请求。如果需要发送同步请求，要将此选项设置为false，跨域不支持同步操作。 beforeSend Function 发送请求前可修改XMLHttpRequest对象的函数，返回false可取消本次请求，function(XMLHttpRequest){ this是请求时传递的option参数 } cache Boolean 默认true，当跨域时默认为false，false时将不会从浏览器缓存中加载请求信息 complete Function 请求完成后的回调函数，function(XMLHttpRequest, textStatus){ this是请求时传递的option参数 } contents Map 以”{ 字符串: 正则表达式 }”配对的对象，用来确定jQuery将如何解析响应，给定其内容类型。 contentType String 当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded” context Object 这个对象用于设置Ajax相关回调函数的上下文，也就是回调函数this的设置，默认是传递的option参数 converters Map 一个数据类型对数据类型转换器的对象。每个转换器的值是一个函数，返回相应的转化值。 crossDomain 同域请求为false，跨域请求为true，如果要通过JSONP请求同域应该设置为true。 data Object或String 发送到服务器的数据 dataFilter Function 给Ajax返回的原始数据进行预处理的函数。function(data, type){ data是Ajax返回的原始数据，type是调用$.ajax时提供的dataType参数，最后需要return data } dataType String 预期服务器返回的数据类型。如果不指定将根据MIME信息返回，可用类型：xml、html、script、json、jsonp、text error Function 请求失败时被调用的函数 function(XMLHttpRequest, textStatus, errorThrown){ this是请求时传递的option参数 } global Boolean 是否触发全局Ajax事件，默认为true。 Headers Map 一个额外的”{ 键: 值 }”对映射到请求一起发送，此设置被设置之前beforeSend函数被调用，因此，消息头中的值设置可以在覆盖beforeSend函数范围内的任何设置 ifModified Boolean 默认:false 仅在服务器数据改变时获取新数据，使用HTTP包Last-Modified头信息判断，也会检查服务器指定的’etag’来确定数据没有被修改过 isLocal Boolean 允许当前环境被认定为”本地”(比如系统文件)，即使jQuery默认情况下不会承认它。以下协议目前目前公认为本地：file、*-extension、widget。如果要修改isLocal，建议在$.ajaxSetup()中做 jsonp String 在一个jsonp请求中重写回调函数的名字，这个值用来替代在”callback=?”这种GET货POST请求中URL参数里的”callback”部分，jsonp可是设置为false，为了阻止在URL中加入callback参数，但仍然要设置jsonpCallback参数。 jsonpCallback String，Function 为jsonp请求指定一个回调函数名，这个值将用来取代jQuery自动生成的随机函数名。 mimeType String 一个mime类型用来覆盖XHR的MIME的类型 password String 用于响应HTTP访问认证请求的密码 processData Boolean 默认为true，默认情况下，发送的数据将被转换为对象(实际上是非字符串)以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，要设置为false。 scriptCharset String 只有当请求dataType为”jsonp”或者”script”，并且type时GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。 statusCode Map 一组数值的HTTP代码和函数对象，当响应时调用了相应的代码，例如，如果响应状态是404，将触发以下报警：statusCode: { 404: function(){ alert(&#39;page not found&#39;) } } success Function 请求成功后的回调函数，三个参数，返回的数据、描述状态的字符串、jqXHR对象 timeout Number 设置请求超时时间(毫秒)，此设置将覆盖$.ajaxSetup方法的全局设置。 traditional Boolean 如果想要用传统的方法来序列化数据，那么就设置为true，可以参考jQuery.param方法。 Type String 请求方式(POST或GET)，默认为GET，跨域只能是GET方式。 url String 发送请求的地址，默认为当前页面 username String 用于响应HTTP访问认证请求的用户名 xhr Function 回调创建XMLHttpRequest对象，当可用时默认为ActiveObject（IE）中，否则为XMLHttpRequest xhrFields Map 一对”文件名-文件值”在本机设置XHR对象。例如，如果需要德华，可以用它来设置withCredentials为true的跨域请求]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》十二、jQuery的技巧]]></title>
      <url>%2F2017%2F08%2F18%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%8D%81%E4%BA%8C%E3%80%81jQuery%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[禁用页面的右键菜单12345$(function()&#123; $(document).on('contextmenu',function()&#123; return false; &#125;)&#125;) 返回头部动画123456789101112$.fn.scrollTo = function(speed,elem)&#123; var targetOffset = $(this).offset().top; elme.stop().animate(&#123; scrollTop: targetOffset, &#125;,speed); return this;&#125;$('.goto').click(function()&#123; $('body').scrollTo(500,$('html body')); return false;&#125;) 模拟输入框的placeholder1234567891011121314151617$(function()&#123; $('input.text1').val('输入搜索内容'); textFill($('input.text1')); function textFill(input)&#123; var originalvalue = input.val(); input.focus(function()&#123; if($.trim(input.val()) == originalvalue)&#123; input.val(''); &#125; &#125;).blur(function()&#123; if($.trim(input.val()) == '')&#123; input.val(originalvalue); &#125; &#125;) &#125;&#125;) 获取鼠标位置12345$(function()&#123; $(document).mousemove(function(e)&#123; $('#xy').html('x: ' + e.pageX + '| y: ' + e.pageY); &#125;)&#125;) 判断元素是否存在12345$(function()&#123; if($('#id').length)&#123; // do something &#125;&#125;) 点击div也可以跳转1&lt;div&gt;&lt;a href="index.html"&gt;index&lt;/a&gt;&lt;/div&gt; 1234$('div').click(function()&#123; window.location = $(this).find('a').prop('href'); return false;&#125;) 根据浏览器大小添加不同样式1234567891011$(function()&#123; function checkWindowSize()&#123; if($(window).width() &gt; 1200)&#123; $('body').addClass('large'); &#125;else&#123; $('body').removeClass('large'); &#125; &#125; $(window).resize(checkWindowSize)&#125;) 设置div在屏幕中央12345$.fn.center = function()&#123; this.css('position','absolute'); this.css('top',($(window).height() - this.height()) / 2 + $(window).scrollTop() + 'px' ); this.css('left',($(window).width() - this.width()) / 2 + $(window).scrollLeft() + 'px' );&#125; 关闭所有动画效果1234$(function()&#123; $.fx.off = true;&#125;) 检测鼠标左键和右键123$('#xy').mousedown(function(e)&#123; alert(e.which) // 1是鼠标左键 2是鼠标中键 3是鼠标右键&#125;) 设置全局Ajax参数123456789$('#load').ajaxStart(function()&#123; showLoading(); // 显示 loading disableButtons(); // 禁用按钮&#125;);$('#load').ajaxComplete(function()&#123; hideLoading(); // 隐藏loading enableButtons(); // 启用按钮&#125;) 获取选中的下拉框12$('#someElement').find('option:selected');$('#someElement option:selected'); $.proxy()的使用123&lt;div id="panel" style="display:none;"&gt; &lt;button&gt;Close&lt;/button&gt;&lt;/div&gt; 123456$('#panel').fadeIn(function()&#123; $('#panel button').click(function()&#123; $(this).fadeOut(); console.log(this); &#125;)&#125;) 以上代码中因为 this 指向了 button 所以会隐藏 button 元素，而不是 #panle 元素。 123456$('#panel').fadeIn(function()&#123; $('#panel button').click($.proxy(function()&#123; $(this).fadeOut(); console.log(this); &#125;,this));&#125;) 这样利用 $.proxy() 方法可以将this改变为 #panel 。 限制输入框的字数123456789101112131415161718$.fn.maxLength = function(max)&#123; this.each(function()&#123; var type = this.tagName.toLowerCase(); var inputType = this.type ? this.type.toLowerCase() : null; if(type == 'input' &amp;&amp; inputType == 'text' || inputType == 'password')&#123; // 标准的maxLength this.maxLength = max; &#125;else if(type == 'textarea')&#123; this.onkeyup = function(e)&#123; console.log(this.value.length); if(this.value.length &gt; max)&#123; console.log(11); this.value = this.value.substring(0,max); &#125; &#125; &#125; &#125;)&#125; 删除元素内部的html标签，只留下文本内容1234567$.fn.stripHTML = function()&#123; var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi; this.each(function()&#123; $(this).html($(this).html().replace(regexp,'')); &#125;) return $(this);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》十一、jQuery性能优化]]></title>
      <url>%2F2017%2F08%2F16%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%8D%81%E4%B8%80%E3%80%81jQuery%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[使用合适的选择器以下选择器是按照性能由高到低排序的 $(‘#id’)使用id来定位DOM元素无疑是最佳提高性能的方式，因为jQuery将直接调用document.getElementById()方法，如果用id无法直接获取元素那么可以用$(&#39;#id&#39;).find()方法。为了提高性能，最好从最近的id开始找。 $(‘div’)标签选择器性能也是不错的，是第二选择。jQuery将直接调用document.getElementsByTagName()。 $(‘.class’)这个方法如果是ie9以上或标准浏览器会调用document.getElementsByClassName()，对于旧的浏览器将使用DOM搜索的方式，所以相比前两个比较耗费性能。 $(‘[attribute=value]’)对于利用属性来定位DOM元素，没有js方法直接实现。基本是通过querySelectorAll()方法实现，如果是旧浏览器会使用DOM搜索的方法。总体来说性能并不理想，尽量避免使用。 $(‘:hidden’)和上面用属性定位DOM元素类似，这种伪类选择器也没有js方法直接实现，并且jQuery需要搜索每一个元素来定位这个选择器，同样性能不理想，如果必须要用可以在前面加一个id选择器缩小搜索范围。 如果要查看性能区别，可以使用一个在线工具jsPerf。 缓存对象在书写jQuery代码时经常看到如下代码： 1234$('#traffic_light input.on').on('click',function()&#123;...&#125;);$('#traffic_light input.on').css('border','1px solid yellow');$('#traffic_light input.on').css('background-color','orange');$('#traffic_light input.on').fadeIn('show'); 这种思维是无可厚非的，但这样导致的结果是jQuery会在创建每一个选择器的过程中，查找DOM，创建多个jQuery对象。比较好的书写方式如下： 12345var $active = $('#traffic_light input.on'); // 缓存对象$active.on('click',function()&#123;...&#125;);$active.css('border','1px solid yellow');$active.css('background-color','orange');$active.fadeIn('show'); 当然如果采用链式操作将更加简洁，但这里只是强调缓存对象。总之不要让同样的选择器多次出现在代码中。 循环时的DOM操作使用jQuery可以很方便的添加、删除或修改DOM节点，但是在一些循环，比如for()、while()、或者$.each()中处理节点时，下面有个实例指的注意： 12345var top_100_list = [...], // 假设这里是100个独一无二的字符串$myList = $('#myList'); // jQuery选择到&lt;ul&gt;元素for(var i = 0, l = top_100_list.length; i &lt; l; i++)&#123; $myList.append('&lt;li&gt;' + top_100_list[i] + '&lt;/li&gt;');&#125; 上面的代码中将每个遍历生成的新元素都作为节点添加到容器$(&#39;#myList&#39;)中，这样操作也是非常耗性能的，更好的方法是尽可能的减少DOM操作，这里应该将整个遍历生成的元素都拼接成字符串，最后统一添加到$(&#39;#myList&#39;)中： 1234567var top_100_list = [...],$myList = $('#myList'),top_100_li = '';for(var i = 0, l = top_100_list.length; i &lt; l; i++)&#123; top_100_li += '&lt;li&gt;' + top_100_list[i] + '&lt;/li&gt;';&#125;$myList.html(top_100); 这里如果不使用缓存对象，对性能的损耗将更加严重，将会产生100个jQuery对象。 数组方式使用jQuery对象jQuery对象会感觉像是一个定义了索引和长度的数组，在性能方面，建议使用for或while循环来处理，而不是使用$.each()，这样能使代码更快。 另外，检查长度也是检查jQuery对象是否有效的的方式： 12345var $content = $('#content');if($content.length)&#123; // do something&#125; 事件代理假设有一张表格，要为每个&lt;td&gt;增加一个事件，点击变色： 123$('#myTable td').click(function()&#123; $(this).css('background','red');&#125;) 假设有100个&lt;td&gt;元素，在使用方式上将绑定100个事件，这将带来很负面的性能影响。更好的方式是利用事件冒泡。向它们的父级绑定一次一次事件： 1234$('#myTable').click(function(e)&#123; var $clicked = $(e.target); $clicked.css('background','red');&#125;) 也可以使用on方法来绑定： 123$('myTable').on('click','td',function()&#123; $(this).css('background','red');&#125;) 使用join()来拼接字符串可以用join()的方式来代替+的方式来拼接字符串，更有助于性能优化，尤其是长字符串处理的时候。 12345var arr = [];for(var i = 0; i &lt;= 1000; i++)&#123; arr[i] = '&lt;li&gt;' + i + '&lt;/li&gt;'&#125;$('#list').html(arr.join('')); 尽量使用原声的js方法下面的代码是用来判断多选框是否被选中： 123456var $cr = $('#cr');$cr.click(function()&#123; if($(this).is(':checked'))&#123; console.log('被选中') &#125;&#125;) 这里用了is()方法来判断多选框是否被选中，但其实可以直接使用原声的js方法： 1234567var $cr = $('#cr');$cr.click(function()&#123; if(this.checked)&#123; console.log('被选中') &#125;&#125;) 第二种方法不需要拐外抹角的去调用许多函数。还有更多类似的操作： $(this).css(&#39;color&#39;,&#39;red&#39;);优化成this.style.color = &#39;red&#39;;。 $(&#39;&lt;p&gt;&lt;/p&gt;&#39;)优化成$(document.createElement(&#39;p&#39;))。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》八、XMLHttpRequest对象]]></title>
      <url>%2F2017%2F08%2F15%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%85%AB%E3%80%81XMLHttpRequest%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[XMLHttpRequest对象是Ajax的核心，它有许多的属性、方法和事件以便于js处理和控制HTTP的请求与响应。 readyState属性当一个XMLHttpRequest被创建后，通过readyState属性可以查看此次请求的状态。 值 说明 0 初始化状态：此时，已经创建了一个XMLHttpRequest对象，但是没有初始化。 1 准备发送状态：已经调用了open()方法，并且XMLHttpRequest对象已经准备好将一个请求发送到服务器。 2 已发送状态：已经通过send()方法把一个请求发送到服务器端。 3 正在接受状态：已经接到HTTP的响应头部信息，但是消息体部分还没有完全接收到。 4 完成响应状态：已经完成了HttpResponse响应的接收。 responseText属性包含客户端接收到的HTTP响应的文本内容。readyState为0、1、2时是一个空字符串，readyState为3时响应中包含客户端还未完成的响应信息，readyState为4时才是完整的信息。 responseXML属性只有当readyState为4时，并且响应头部的Content-Type的MIME类型被指定为XML(text/xml)时，该属性才会有值并且被解析为一个XML文档。 status属性描述了HTTP的状态码，只有在readyState为3或者4时才可以使用该属性，否则会报错。 statusText属性和上面相同，只是描述了HTTP的状态码文本，而不只是状态码。 open()方法XMLHttpRequest对象是通过调用open()方法来进行初始化工作的。调用该方法将得到一个可以用来进行发送的对象。 该方法有五个参数 open(method,uri,async,username,password)。 method：该参数是必须提供的，用于确定GET发送还是POST发送，该参数要大写。 uri：用于指定XMLHttpRequest对象把请求发送到的服务器相应的URI。 async：用于指定是否请求是异步的，默认值是true，发送同步请求需要设置为false。 如果服务器要验证访问用户的情况，那么可以设置username及password。 send()调用send()方法可以将open()方法设定的参数请求进行发送。send()方法在readyState属性值为1时，即是在open()之后才可以调用。 send()的参数可以作为POST方式发送的参数，在调用send()之前，先使用setRequestHeader()方法设置Content-Type的头部。 abort()方法该方法可以暂停一个HttpRequest的请求发送或者HttpResponse的接收，并将XMLHttpRequest设置为初始化状态。 setRequestHeader()方法用来设置头部信息，当readyState属性值为1时，可以在调用open()方法后调用这个方法，该方法的格式为：setRequestHeader(header, value)。 getRequestHeader()方法检索响应的头部值，仅当readyState值为3或者4时才可以调用这个方法，否则会返回一个空字符串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[6、列表渲染]]></title>
      <url>%2F2017%2F08%2F01%2F6%E3%80%81%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%2F</url>
      <content type="text"><![CDATA[遍历数组for指令根据一组数据的选项列表进行渲染，需要以item in tiems或item of tiems形式的特殊写法，item是数组的每一项，items是源数据数组。也有(item,index) in items的写法index是该item在数组中的索引。实际就是用for去遍历items数组。 12345&lt;ul id="example-1"&gt; &lt;li v-for="(item,index) in items"&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var app = new Vue(&#123; el: '#example-1', data:&#123; items:[ &#123;message:'foo'&#125;, &#123;message:'bar'&#125; ] &#125;&#125;) 这里items是一个数组。 遍历对象遍历的数据不仅可以是数组形式，也可以是对象的形式。 12345678910111213141516&lt;div id="app"&gt; &lt;ul&gt; &lt;!--只渲染value到列表中--&gt; &lt;li v-for="value in object"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;!--将key和value都渲染到列表中--&gt; &lt;li v-for="(value,key) in object"&gt; &#123;&#123;key&#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;!--将index、key和value都渲染到列表中--&gt; &lt;li v-for="(value,key,index) in object"&gt; &#123;&#123; index &#125;&#125; : &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910var app = new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;) 也可以不通过数据去遍历，比如：12345&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="n in 10"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123var app = new Vue(&#123; el: '#app'&#125;) 这样最终就是10个&lt;li&gt;元素，内容分别就是1-10的数字。 通过模板渲染v-for也可以通过模板渲染，而不是直接写在展示在页面中的html元素里。 1234567&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt; &#123;&#123; item.msg &#125;&#125; &lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; &lt;template&gt;模板元素不会展示在页面中，只起到了遍历的作用。这个和上面只是两种写法，实际效果相同。 key属性当Vue用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。是一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 如果不想用这种“就地复用”策略，就需要为每项提供一个唯一key属性。理想的key值是每项都有唯一id。它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。 12345&lt;div id="app"&gt; &lt;div v-for="item in items" v-bind:key="item.id"&gt; &#123;&#123; item.msg &#125;&#125; &lt;/div&gt;&lt;/div&gt; 12345678910var app = new Vue(&#123; el: '#app', data: &#123; items: [ &#123; id: '1',msg:'第一个' &#125;, &#123; id: '2',msg:'第二个' &#125;, &#123; id: '3',msg:'第三个' &#125; ] &#125;&#125;) 变异方法变异方法指的是这些方法名字和作用与原来相同，除此之外还可以在Vue中可以触发视图的更新。触发更新的原因是这些方法都会改变原数组，也就是改变了数据。 常用的变异方法包括：push() 、pop()、shift()、unshift()、splice()、sort()、reverse()。 123456789101112var app = new Vue(&#123; el: '#app', data: &#123; items: [ &#123; msg:'第一个' &#125;, &#123; msg:'第二个' &#125;, &#123; msg:'第三个' &#125; ] &#125;&#125;)app.items.push(&#123; id: '4',msg:'BAZ' &#125;) // push之后触发视图更新 非变异方法如果是不改变原数组的方法就无法自动触发视图更新，比如：filter()、concat()、slice()。但可以通过重新赋值的方式触发。 123app1.items = app1.items.fliter(function(item)&#123; return item.msg.match(/foo/)&#125;) 这里替换旧数组并不会丢弃原有DOM重新渲染整个列表，相反这种替换原来数组的方法是很高效的操作 需要注意的是，由于js的限制，Vue不能检测以下变动的数组： 当利用索引直接设置一个项时，例如： app.items[index] = {...} 当你修改数组的长度时，例如：app.items.length = num 当然也有替代的方法，效果相同，同时也将触发状态更新 代替第一个有两种方式： Vue.set(app.items, index , {...}) app.items.splice(index , 1 , {...}) 代替第二类问题，可以使用splice： app.items.splice(num) 数组数据的过滤和排序有时，想要显示一个数组的过滤或排序的结果，而不想实际改变或重置原始数据，在这种情况下，可以创建返回过滤或排序数组的计算属性 123&lt;ul id="app"&gt; &lt;li v-for="n in eventNumbers"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 12345678910111213var app = new Vue(&#123; el: '#app', data: &#123; numbers: [1,2,3,4,5] &#125;, computed: &#123; eventNumbers: function()&#123; // 不改变number，只产生一个新的数组，最终渲染2和4 return this.numbers.filter(function(number)&#123; return number % 2 === 0 &#125;) &#125; &#125;&#125;) 最终不会改变numbers数组，只产生一个新的数组，最终渲染2和4。 在计算属性不适用的情况下(例如在嵌套v-for循环中)，可以使用一个methods方法 123&lt;ul id="app1"&gt; &lt;li v-for="n in even(numbers)"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 12345678910111213var app1 = new Vue(&#123; el: '#app1', data: &#123; numbers: [1,2,3,4,5] &#125;, methods: &#123; even: function(numbers)&#123; return numbers.filter(function(number)&#123; return number % 2 === 0 &#125;) &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[5、条件渲染]]></title>
      <url>%2F2017%2F07%2F31%2F5%E3%80%81%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%2F</url>
      <content type="text"><![CDATA[v-if在vue中使用v-if实现判断12&lt;h1 v-if="ok"&gt;Yes&lt;/h1&gt;&lt;h1 v-else&gt;No&lt;/h1&gt; 上面这种方式只能给一个元素判断，如果是多个元素可以按照下面的写法，&lt;template&gt;元素当做包装元素，但是最终渲染不会包含这个元素。 12345&lt;template v-if="ok"&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;p&gt;paragraph 1&lt;/p&gt; &lt;p&gt;paragraph 2&lt;/p&gt;&lt;/template&gt; v-else或者v-else-if必须跟在v-if或者v-else-if的后面。 12345678910111213&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt;``` htnmlvar vm = new Vue({ var vm = new Vue({ el:’#app’, data: { // 只打印No和C ok: false, type: ‘C’ }})1234567891011121314## 用key管理可复用元素这里虽然可以切换输入用户名和email，但是每次切换之后`input`输入的内容是不变的，改变的只是`placeholder`的内容，也就是说这两个`input`元素并不是相互独立的```html&lt;template v-if=&quot;loginType === &apos;username&apos;&quot;&gt; &lt;label for=&quot;&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Enter your username&quot;&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label for=&quot;&quot;&gt;Email&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Enter you mail address&quot;&gt;&lt;/template&gt; 有时这样会比较麻烦，所以Vue提供了一种方式来声明这两个元素是完全独立的，不要复用他们，只需要添加一个具有唯一的key属性即可 12345678&lt;template v-if="loginType === 'username'"&gt; &lt;label for=""&gt;Username&lt;/label&gt; &lt;input type="text" placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label for=""&gt;Email&lt;/label&gt; &lt;input type="text" placeholder="Enter your email" key="email-input"&gt;&lt;/template&gt; v-show另一个用于根据条件展示元素的是v-show指令，用法大致一样 1&lt;h1 v-show="ok"&gt;Hello!&lt;/h1&gt; show不支持&lt;template&gt;语法，而且v-show的元素始终会被渲染并保留在DOM中，v-show只是简单的切换元素的display属性。 v-if和v-show比较 v-if是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建。 v-if也是有惰性的，如果在初始渲染时条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件。 相比之下，v-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单的基于css进行切换。 一般来说，v-if有更高的切换开销，而v-show有更高的初始渲染开销，因此，如果需要非常频繁的切换，则使用v-show比较好，如果运行时条件不太可能改变，则使用v-if比较好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[4、class与style]]></title>
      <url>%2F2017%2F07%2F29%2F4%E3%80%81class%E4%B8%8Estyle%2F</url>
      <content type="text"><![CDATA[数据绑定一个常见需求是，操作元素的class列表，和它的style时，因为他们都是属性所以可以用 v-bind 处理他们 但是字符串拼接麻烦又易错。因此在v-bind用于class和style时，Vue专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。 绑定class这里class是否为active取决于isActive是否为真12&lt;!--class="active"--&gt;&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 可以在对象中传入更多属性用来动态切换多个class，此外，v-bind:class指令可以与普通的class属性共存123&lt;!--class="static active",如果为true就是class="static active text-danger"--&gt;&lt;div class="static" v-bind:class="&#123; active: isActive, text-danger: hasError &#125;"&gt;&lt;/div&gt; 通过一个对象获取class名12&lt;!--class="active text-danger"--&gt;&lt;div v-bind:class="classObject"&gt;&lt;/div&gt; 通过一个数组获取class名12&lt;!--class="active text-danger"--&gt;&lt;div v-bind:class="[activeClass,errorClass]"&gt;&lt;/div&gt; 上面三种写法在Vue中的数据处理：1234567891011121314151617181920var app = new Vue(&#123; ... data: &#123; isActive: true, hasError: false, activeClass: 'active', errorClass: 'text-danger', classObject: &#123; active: true, text-danger: true &#125; &#125;, computed:&#123; classObject:function()&#123; return &#123; active:this.isActive &amp;&amp; !this.error, &#125; &#125; &#125;&#125;) 需要注意的是，class中如果包括用-连接的类名。一定要写为字符串的形式。 绑定stylev-bind:style的语法十分直观，看着非常像css，但其实是一个js对象。css属性名可以用驼峰式，或者配合引号的短横分隔命名。另外对于css3的前缀，vue会自动添加。 最直接的方式12&lt;!--color: red; font-size: 30px;--&gt;&lt;div v-bind:style="&#123;color:activeColor,fontSize:fontSize + 'px'&#125;"&gt;&lt;/div&gt; 直接绑定一个对象通常更好,也可以将多个对象用在一个元素上12&lt;!--color: red; font-size: 13px;--&gt;&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 在Vue中的数据处理1234567891011var app = new Vue(&#123; ... data:&#123; activeColor:'red', fontSize:30, styleObject:&#123; color:'red', fontSize:'13px' &#125; &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[3、计算属性]]></title>
      <url>%2F2017%2F07%2F27%2F3%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[之前说过，模板内在插值中写表达式很方便，但是如果放太多逻辑会让模板过重难以维护。所以在模板内只适合简单的运算，稍微复杂的语句就需要计算属性了。 computed和methods计算属性应该放到computed属性中，函数放到methods中，而实际上计算属性的语句也是写到函数里，所以其实写到methods也是可以的，但两者还是有区别的。 12345&lt;div id="app"&gt; &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt;Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"&lt;/p&gt; &lt;p&gt;Methods reversed message: "&#123;&#123; reversedMessage1() &#125;&#125;"&lt;/p&gt;&lt;/div&gt; 12345678910111213141516var vm = new Vue(&#123; el:'#app', data:&#123; message:'hello' &#125;, computed:&#123; reversedMessage: function()&#123; return this.message.split('').reverse().join('') &#125; &#125;, methods:&#123; reversedMessage1: function()&#123; return this.message.split('').reverse().join('') &#125; &#125;&#125;) 对于最终的结果，methods和computed是相同的， 不同的是computed是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值，这就意味着只要message还没有发生改变，多次访问reversedMessage计算属性会立即返回之前的计算结果，而不必再次执行函数(假如函数里有获取当前时间的语句也不会执行)。 相比而言，只要发生重新渲染，methods调用总会执行该函数。 所以假如有一个性能开销比较大的计算属性A，而且可能别的计算属性还依赖于A的返回值，那么有缓存可以节省性能。但是不需要缓存时可以用methods代替。 watchVue提供了一种更通用的方式来观察和响应Vue实例上的数据变动，就是watch属性。 但是当有一些数据需要随着其他数据变动而变动时，很容易滥用watch，通常更好的方法是使用computed属性而不是命令式的watch。 1234567&lt;div id="app1"&gt; &#123;&#123; fullName &#125;&#125;&lt;/div&gt;&lt;div id="app2"&gt; &#123;&#123; fullName &#125;&#125;&lt;/div&gt; watch的方式，只要data中的数据发生变化，watch就会监测到，并执行相对应的方法。 1234567891011121314151617var app1 = new Vue(&#123; el:'#app1', data:&#123; firstName:'Foo', lastName:'Bar', fullName:'Foo Bar' &#125;, watch:&#123; firstName: function(val)&#123; this.fullName = val + ' ' + this.lastName; &#125;, lastName:function(val)&#123; this.fullName = this.firstName + ' ' + val; &#125; &#125;&#125;)app1.firstName = 'tim'; computed的方式，这里就是上面说的，fullName会随着firstName和lastName的改变而改变。很明显在这里使用computed的方法更简洁。 12345678910111213var app2 = new Vue(&#123; el:'#app2', data:&#123; firstName:'Foo', lastName:'Bar' &#125;, computed:&#123; fullName: function()&#123; return this.firstName + ' ' + this.lastName; &#125; &#125;&#125;)app2.firstName = 'tom'; get和setcomputed中不仅有get，还有set方法。 之前介绍的都是get方法，也就是data中的数据作为参数，通过函数内部计算，返回一个新的数据。而set方法是将计算后得新数据的值作为参数，改变原本data中的数据。 123&lt;div id="app1"&gt; &#123;&#123; fullName &#125;&#125;&lt;/div&gt; 1234567891011121314151617181920212223var app1 = new Vue(&#123; el:'#app1', data:&#123; firstName:'Foo', lastName:'Bar' &#125;, computed:&#123; fullName:&#123; get:function()&#123; return this.firstName + ' ' + this.lastName; &#125;, // 这里会将fullName的值最为参数传进来。 set:function(newValue)&#123; var name = newValue.split(' '); this.firstName = name[0]; this.lastName = name[name.length - 1]; &#125; &#125; &#125;&#125;)// 这里更改fullName的值会调用set()，然后会改变firstName和lastName的值。在通过get展示在html中app1.fullName = 'john Doe'; 在使用Vue的时候，get会在改变data的数据时被调用，而set会在改变computed中新数据的返回值的时候被调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2、指令和模板]]></title>
      <url>%2F2017%2F07%2F26%2F2%E3%80%81%E6%8C%87%E4%BB%A4%E5%92%8C%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[指令什么是指令指令是一种特殊的自定义行间属性，指令的职责就是当其表达式的值改变时，响应的将某些行为应用到DOM上，在Vue中，指令以v-开头。以v-bind指令为例： 1234&lt;div id="app"&gt; &lt;!--v-bind是指令，作用是动态的绑定数据，简写为':'，id是它的参数--&gt; &lt;span v-bind:id="&#123;&#123; id &#125;&#125;"&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;/div&gt; 1234567var vm = new Vue(&#123; el: '#app', data: &#123; message: 'hello,Vue!', id:'123' &#125;&#125;) 还有很多常用指令可以查看官网的API。 模板Vue中有三种模板可以使用，html模板、字符串模板(template)、render函数。 html模板基于DOM的模板，只要是有效的可解析的html就可以。 html模板的插值插值就是写在 { {} } 内部的内容。有以下四种情况可以使用： 文本：就是 { {key} }，替换实例上的data里的属性值，插值内容会自动更新。 原生的html： 上面 { {} } 输出的是文本，不会解析html，如果在data中有html: &#39;&lt;div&gt;hello Vue&lt;/div&gt;&#39;这样的数据，直接{ {html} }只会将其当做文本而不是html元素。如果需要被当做dom渲染，需要在父元素设置v-html=&quot;html&quot;。 行内的属性：使用v-bind进行绑定，可以响应变化。 使用javascript表达式：{ {} }内部可以写简单的表达式(不要写复杂语句)，可以写比如{ { true?&#39;yes&#39;:&#39;noe&#39; } }或者{ {&#39;data&#39;+message} }，如果复杂的就写到计算属性中去。 字符串模板(template)template是Vue实例中的选项的一个属性。 模板将会替换挂载的元素，挂载元素的内容都将被忽略，根节点只能有一个，也可以将html结构写在一对&lt;script&gt;标签中，设置type=”X-template” 字符串的方式替换挂载元素：123&lt;div id="demo1"&gt; &lt;span&gt;hi Vue&lt;/span&gt;&lt;/div&gt; 12345678var str = '&lt;span&gt;&#123;&#123; message ]&#125;&#125;&lt;/span&gt;'new Vue(&#123; el: '#demo1', data:&#123; message: 'hello Vue' &#125;, template:str&#125;) 最终页面会显示hello Vue，会将新渲染的字符串模板替换掉原来的元素 需要注意的是：根节点只能有一个，var str = &#39;&lt;span&gt;{ {message} }&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&#39;这种写法是错误的，因为最外层的根节点只能是一个。只能去包含别的元素，比如var str = &#39;&lt;span&gt;{ {message} }&lt;span&gt;11&lt;/span&gt;&lt;/span&gt;&#39;这样就是对的。 script标签的方式这种模板也可以写在&lt;script&gt;标签中，就和平时用的模板文件是相同的。 123456&lt;script type="X-template" id="temp"&gt; &lt;span&gt; &#123;&#123; message &#125;&#125; &lt;span&gt;11&lt;span&gt; &lt;/span&gt;&lt;/script&gt; 1234567new Vue(&#123; el: '#demo1', data:&#123; message: 'hello Vue' &#125;, template: '#temp'&#125;) render函数render是Vue实例中的属性，在写组件会经常使用。 通过上面字符串方式创建的元素不会直接放到页面上，而是要通过render函数编辑，虚拟DOM树到真实DOM树就是通过render实现的。 render函数需要传入createElement参数，用这个参数创建模板并return。createElement也是一个方法。 第一个参数是要创建模板的根元素。 第二个参数是可选参数，表示该根元素上的属性，这里的属性遵循的是指令的规则而不是普通DOM中的写法。其中类名是class、样式属性是style、自定义属性是attrs、绑定事件时on、dom元素属性是domProps。其中dom元素属性不是标签里的属性，而是元素对象身上的。就好比length一样。 第三个参数是数组，数组的元素是模板中的子元素。同样使用createElement创建。 123456789101112131415161718192021222324252627282930313233var vm = new Vue(&#123; el: '#demo', data: &#123; class: true &#125;, render: function(createElement)&#123; return createElement( 'ul', // 根元素 &#123; class: &#123; // 这里的属性是遵循v-bind:class而不是dom中的那种class。 bg: true // 添加class名为bg &#125;, style: &#123; // 设置行内样式,也是和v-bind:style一样的 fontSize: '50px' &#125;, attrs: &#123; // 设置自定义属性 abc: 'miaov' &#125;, domProps: &#123; innerHTML: '&lt;li&gt;我是html&lt;/li&gt;' // 这里创建了innerHTML相当于是ul.innerHTML='&lt;li&gt;我是html&lt;/li&gt;'，下面数组里的那些就会被覆盖了 &#125;, on: &#123; // 这里绑定事件，和v-on是一样的 &#125; &#125;, [ // 子元素写在数组里， createElement('li',1), createElement('li',2), createElement('li',3) ] ) &#125;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[1、创建Vue实例]]></title>
      <url>%2F2017%2F07%2F25%2F1%E3%80%81%E5%88%9B%E5%BB%BAVue%E5%AE%9E%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[一个最简单的Vue的例子Vue的核心是：允许采用简洁的模板语法、声明式的将数据渲染进DOM(与声明式相对应的是命令式)。 首先要创建一个模板，这是html模板(最简单的一种模板) 123&lt;div id="app"&gt; &lt;p v-on:click="clickHandle"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 下面是创建Vue的实例，参数是一个选项对象，可以包含数据、模板、挂载元素、方法、声明周期钩子等选项。 123456789101112var app = new Vue(&#123; el: '#app', // 挂载元素 data: &#123; // 代理数据,这里所有数据都具有响应的功能，新添加的就没有响应功能。 message: 'Hello Vue' &#125;, methods: &#123; // 定义方法，用于执行函数，key:fun的格式 // 可以把事件处理函数都放在这里 clickHandle: function()&#123; alert('click') &#125; &#125;&#125;) 这样就渲染生成了一个简单的Vue应用，现在数据和DOM已经被绑定到了一起，所有元素都是响应式的。 数据是可以动态的修改的，修改之后页面中的显示也会随之渲染。 1app.message = '123' 这样页面中的Hello Vue就会变为123。这是利用的Object.delinedProperty中的getter和setter代理数据，监控对数据的操作。 Vue渲染DOM树的过程 读取html模板 用Vue中的渲染函数，根据html模板的元素生成标签的节点、属性、子节点 根据渲染函数生成一个虚拟的DOM树对象。 将虚拟的DOM树编译为html中的DOM结构，在整个html的DOM结构中，只会改变虚拟DOM树对应的部分，DOM树的其他部分不受影响，但是如果是通过原生js修改的话，会导致整个DOM树重新加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》十、jQuery插件的使用和写法]]></title>
      <url>%2F2017%2F07%2F24%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%8D%81%E3%80%81jQuery%E6%8F%92%E4%BB%B6%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
      <content type="text"><![CDATA[编写插件的目的是给已有的一系列方法或函数做一个封装，以便在其他地方重复使用，方便后期维护和提高开发效率。 插件的种类1.封装对象方法的插件这种插件是将对象方法封装起来，用于通过选择器获取jQuery对象进行操作，是最常见的一种插件。比如parent()、appendTo()、addClass()等。 2.封装全局函数的插件可以将独立的函数加载到jQuery的命名空间之下。例如$.ajax()、$.trim()等。 3.选择器插件个别情况下，会需要使用到选择器插件，虽然jQuery的选择器十分强大，但还是会需要扩充一些自己喜欢的选择器。 插件的基本要点插件的文件名推荐命名为jquery.[插件名].js。 所有的对象方法都应该附加到jQuery.fn对象上，而所有的全局函数都应该附加到jQuery对象本身上。 在插件内部，this只想的是当前通过选择器获取的jQuery对象，例如click()方法指向的是DOM元素。可以通过this.each来遍历所有元素。 插件应该返回一个jQuery对象，以保证插件的可链式操作。除非插件需要返回的是一些需要获取的量，例如字符串或者数组。 避免在插件内部使用$作为jQuery对象的别名，而应该用完整的jQuery来表示。这样可以避免冲突，如果使用$作为jQuery的别名，要用必报来避免冲突。 插件中的闭包利用闭包的特性，既可以避免内部临时变量影响全局空间，又可以在插件内部继续使用$作为jQuery别名。 12345678910(function($)&#123; // 将$作为匿名函数的形参 // 这里编写插件的代码 var foo; var bar = function()&#123; // 在匿名函数内部的函数都可以访问foo，即便是在匿名函数的外部调用bar()的时候，也可以在bar()的内部访问到foo，但在匿名函数的外部直接访问foo是做不到的。 &#125; // 下面的语句让匿名函数内部的函数bar()返回到全局可访问的范围内，这样就可以在匿名函数的外部通过调用jQuery.BAR()来访问内部定义的函数bar()，并且内部函数bar()也能访问匿名函数内的变量foo。 $.BAR = bar;&#125;)(jQuery) // jQuery作为实参传递给匿名函数 jQuery的插件机制jQuery提供了两个用于扩展jQuery功能的方法，jQuery.fn.extend()方法和jQuery.extend()方法。第一个方法用于封装对象方法的插件，第二个适用于封装全局函数插件和选择器插件。这两个方法都接收一个参数，类型是Object。 jQuery.extend()除了扩展插件能用到，还有一个用处是扩展已有的对象，也就是传递两个参数，类型都是object，第二个对象会和第一个对象合并，相同的属性第二个会覆盖第一个。 1234var settings = &#123; validate: false , limit: 5 , name: 'foo' &#125;;var options = &#123; validate: true , name: 'bar' &#125;;var newObj = jQuery.extend(settings,options);console.log(newObj) // &#123; validate: true , limit: 5 , name: 'bar' &#125; 所以jQuery.extend()方法经常用于设置插件方法的一些默认参数。 编写jQuery插件封装jQuery对象插件设置和获取颜色的插件首先编写设置和获取颜色的插件color。该插件的功能是： 设置匹配元素的颜色 获取匹配的元素(元素集合中的第一个)的颜色。 由于是在jQuery对象上扩展方法所以使用jQuery.fn.extend，这里要注意的是插件扩展内部的this指的是jQuery对象而不是普通的dom对象，然后插件如果不是返回字符串之类的特定值，应当使其具有可链接性，为此要直接返回这个this对象。12345678910111213(function($)&#123; $.fn.extend(&#123; 'color': function(value)&#123; if(value == undefined)&#123; return this.css('color'); // 获取颜色。css方法本身就默认返回第一个的颜色 &#125;else&#123; return this.each(function()&#123; $(this).css('color',value); // 设置颜色，由于this是jQuery对象，所以不需要each遍历 &#125;) &#125; &#125; &#125;);&#125;)(jQuery) 表格隔行变色插件12345678910111213141516171819202122(function($)&#123; $.fn.extend(&#123; 'alterBgColor': function(options)&#123; options = $.extend(&#123; odd: 'odd', // 偶数行样式 even: 'even', // 奇书行样式 selected: 'selected' // 选中行样式 &#125;,options); $('tbody&gt;tr:odd' , this).addClass(options.odd); $('tbody&gt;tr:even' , this).addClass(options.even); $('tbody&gt;tr' , this).click(function()&#123; // 判断当前是否选中 var hasSelected = $(this).hasClass(options.selected); // 如果选中，则移出selected类，否则就加上selected类 $(this)[hasSelected ? 'removeClass' : 'addClass'](options.selected).find(':checkbox').prop('checked',!hasSelected); &#125;); // 如果单选框默认情况下是选择的，则高亮 $('tbody&gt;tr:has(:checked)' , this).addClass(options.selected); return this; // 返回this，可以继续链式操作 &#125; &#125;);&#125;)(jQuery) 需要注意的是上面两个插件内部this都是可以匹配多个元素，但是如果遇到只能匹配一个元素的时候，要each遍历匹配的jQuery对象，而在each内部，this就是dom对象不是jQuery对象了。 封装全局函数这类插件是在jQuery命名空间内部添加一个函数。 增加两个函数，用于去除左侧空格和右侧空格。1234567891011(function($)&#123; $.extend(&#123; ltrim: function(text)&#123; // 假如text是undefined等非正确参数，就取空字符串，防止replace方法报错 return (text || '').replace(/^\s+/g,''); &#125;, rtrim: function(text)&#123; return (text || '').replace(/\s+$/g,''); &#125; &#125;)&#125;)(jQuery) 由于是全局函数，所以要由jQuery或者$调用，不能用jQuery对象去调用。 12$.ltrim(' text');$.rtrim('text '); 自定义选择器jQuery提供了一套方法让用户客户以通过制作选择器插件来使用自定义选择器。jQuery选择器执行的步骤如下： jQuery的选择符解析器首先会使用一组正则表达式来解析选择器 针对解析出的每个选择符执行一个选择器函数 根据这个函数返回的是true还是false来决定是否保留这个元素。 按照上面的步骤，以$(&#39;div:gt(1)&#39;)来举例： 选择器首先获取所有的div元素 逐个将这些div元素作为参数，连同括号里的1等一些参数一起传递给gt对应的选择器函数进行判断 如果gt对应的选择器函数返回true则这个div元素保留，如果返回false则不保留，这样得到的结果就是一个符合要求的div元素集合 现在来看一下最关键的gt的选择器函数： 123gt: function(a,i,m)&#123; return i &gt; m[3] - 0;&#125; 选择器一共接受三个参数： 第一个参数为a，指向的是当前遍历到的dom元素。 第二个参数为i，指的是当前遍历到的dom元素的索引值，从0开始。 第三个参数m最为特别，它是由jQuery正则解析引擎进一步解析后的产物(用match匹配出来的)，m是一个数组。在这时m[3]的值就是’1’。m[0]的值是:gt(1)m[1]的值是:m[2]的值是gtm[4]在上面的例子没有体现，假如是div:l(ss(dd))这样一个选择器，m[4]就指向了(dd)这部分，另外这里的m[3]的值就是ss(dd)。 编写一个between选择器例如使用$(&#39;div:between(2,5)&#39;)能实现获取索引3、4元素的功能。 选择器仅仅是jQuery.expr[&#39;:&#39;]对象的一部分，所以这里是将between函数扩展到jQuery.expr[&#39;:&#39;]对象中。12345678(function($)&#123; $.extend(jQuery.expr[':'],&#123; between: function(a,i,m)&#123; var tmp = m[3].split(','); // 将m[3]'最小值,最大值'改为['最小值','最大值'] return tmp[0] - 0 &lt; i &amp;&amp; i &lt; tmp[1] - 0; // 将索引与最小和最大值进行比较，符合要求的返回true，这里-0 是隐式转换的意思 &#125; &#125;)&#125;)(jQuery)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》六、jQuery的表单与表格]]></title>
      <url>%2F2017%2F07%2F23%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%85%AD%E3%80%81jQuery%E7%9A%84%E8%A1%A8%E5%8D%95%E4%B8%8E%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[表单的应用表单的组成部分 表单标签：包含处理表单数据所用的服务器端程序URL以及数据提交到服务器的方法。 表单域：包含文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮，用于将数据传送到服务器上或者取消传送，还可以用来控制其它定义了处理脚本的处理工作。 文本框单行文本框有失去和获取焦点事件。 12345$('input').focus(function()&#123; &#125;).blur(function()&#123; &#125;) 也可以不传参数直接focus()和blur()，可以直接让文本框失去和获得焦点。 复选框jQuery可以控制复选框的就是是否被选择，checked属性如果为true就是被选中，为false就是没有选中。而最常用的就是全选、反选、全不选这三种按钮控制复选框的状态。 123456789101112// 全选$('input:checkbox').prop('checked','true');// 全不选$('input:checkbox').prop('checked','false');// 反选$('input:checkbox').each(function()&#123; $(this).prop('checked',!$(this).prop('checked')); // 这里也可以直接用原生来写 // this.checked = !this.checked;&#125;) 还有一种复选框是 全选/全不选，这是用一个复选框控制其他复选框选项的状态。 12345678910111213// 全选和全不选$('#allChecked').click(function()&#123; $('input:checkbox').prop('checked',$(this).prop('checked'))&#125;)// 在其他选项被取消勾选后，全选的状态也应该改为false$('input:checkbox').click(function()&#123; var flag = true; if(!$(this).prop('checked'))&#123; flag = false; &#125; $('#allChecked').prop('checked',flag);&#125;) 下拉框下拉框的应用通常是在左右两个&lt;select&gt;元素中相互移动&lt;option&gt;选项，常用的包括将选中项添加到右边/左边，全部添加到右边/左边。还有双击移动选中的选项。 选项从左边&lt;select&gt;移动到右边&lt;select&gt; 1234// 获取选中的选项var $options = $('#select1 option:selected');// 追加给对方，appendTo方法会移动且删除原来的元素。$options.appendTo($('#select2')); 全部添加到右边 1234// 获取全部选项var $options = $('#select1 option');// 追加给对方$options.appendTo($('#select2')); 双击某个选项添加给对方1234$('#select1').dblclick(function()&#123; var $options = $(this).find('option:selected'); $options.appendTo('#select2')&#125;) 表单验证表单注册最常用的地方就是登录注册，比如有些设置为required的必填项要检查其是否填写正确。 123456789101112131415161718192021222324252627282930$('form:input').blur(function()&#123; var $parent = $(this).parent(); // 需要先将上次的提示删除 $parent.find('span').remove(); // 验证用户名 if($(this).is('#username'))&#123; if(this.value == '' || this.value.length &lt; 6)&#123; var errMsg = '至少要输入6位的用户名'; $parent.append('&lt;span class="tips error"&gt;' + errMsg + '&lt;/span&gt;'); &#125;else&#123; var okMsg = '输入正确'; $parent.append('&lt;span class="tips success"&gt;' + okMsg + '&lt;/span&gt;'); &#125; &#125; // 其他密码、邮箱等验证都是类似的，只是判断规则不同 ......&#125;)// 表单提交时对整个表单再做一次验证$('#submit').click(function()&#123; $('form:input').blur(); var numErr = $('form:input .error').length; if(numErr)&#123; // 阻止表单提交 return false; &#125; alert('注册成功')&#125;) 除了在表单blur时判断，也可以在其输入文字时进行实时判断。 123456$('form:input').blur(function()&#123; // 上面的事件处理程序，这里就不再重复写了&#125;).keyup(function()&#123; // 输入文字时执行blur的事件处理程序，triggerHandler不会触发blur的浏览器默认事件，所以不会真的失去焦点导致无法输入 $(this).triggerHandler('blur') &#125;) 表格的应用表格变色普通的隔行变色css部分123456.even &#123; background:#fff38f;&#125;.odd &#123; background:#ffffff;&#125; js部分12$('tbody &gt; tr:odd').addClass('odd'); // 奇数行$('tbody &gt; tr:even').addClass('even'); // 偶数行 :odd和:even选择器的索引是从0开始，所以第一行是偶数。 单选框控制表格行高亮有种表格的选择是，点击当前行之后，当前行会变色，有可能在第一列是一个单选框，也需要被选中。 123456$('tbody&gt;tr').click(function()&#123; // 给当前行增加selected样式 $(this).addClass('selected').siblings().removeClass('selected').end().find(':radio').attr('checked',true);&#125;)// 初始化表格时让默认选中的行业要变色$('table :radio:checked').parent().parent().addClass('selected') 这里使用了end()方法，当执行siblings()时，this已经被改变为当前元素的兄弟元素，而使用end()则会让this重新回归原本的元素。 复选框控制表格高亮和上面的样式相似，只是单选改为复选框 12345678910$('tbody&gt;tr').click(function()&#123; // 判断是否被选中，有selected类名就是被选中了 var hasSelected = $(this).hasClass('selected'); // 如果选中移除selected类，否则就加上 $(this)[hasSelected?'removeClass':'addClass'].('selected'); // 查找内部的checkbox，设置相对应的属性 $(this).find(':checkbox').attr('checked',!hasSelected);&#125;)// 初始化表格时让默认选中的行业要变色$('table :checkbox:checked').parent().parent().addClass('selected') 表格的内容筛选相对是在表格内部进行姓名的搜索，输入’王’就显示出所有名字带有’王’字的行。 123$('#inputName').keyup(function()&#123; $('table tbody tr').hide().filter(':contains("' + ( $(this).val() ) + '")').show();&#125;).keyup(); // 打开页面时自动执行一次 :contains()是匹配包含指定文本的元素，在这里指的是输入的文字，filter()是在this中筛选出符合条件的元素集合 其他应用网页字体大小假设字体的放大和缩小都是span标签，文字内容元素的id为para。 1234567891011121314$('span').click(function()&#123; var thisEle = $('#para').css('font-size'); var textFontSize = parseInt(thisEle,10); // 获取现在的字号的单位 var unit = thisEle.slice(2); var cName = $(this).attr('class'); // 根据按钮的类名判断是放大还是缩小 if(cName == 'bigger')&#123; textFontSize += 2; &#125;else if(cName == 'smaller')&#123; textFontSize -= 2; &#125; $('#para').css('font-size',textFontSize + unit);&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》七、jQuery和Ajax的应用]]></title>
      <url>%2F2017%2F07%2F23%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B8%83%E3%80%81jQuery%E5%92%8CAjax%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[在jQuery中对Ajax进行了封装，在jQuery中$.ajax()属于最底层方法，第二层是$.post()、load()、$.get()方法，第三层是$.getScript()和$.getJson()方法。通常第二层的方法使用频率最高。 load()方法load()方法能载入远程html页面到dom中。 格式为：load( url , [data] , [callback] ) url：请求html页面的地址。 data: 可选参数，发送至服务器的数据。 callback：可选参数，请求完成后的回调，不论请求成功或者失败。 载入html文档假设有一个test.html的页面，那么只需要这样写就能引入这个test到当前页面。 当前页面的html部分1&lt;div id=""resText&gt;&lt;/div&gt; 当前页面发送请求 1$('#resText').load('text.html'); 筛选载入html文档上面是将test.html的所有内容都加载进来，如果只需要加载一部分那么只需要改变url参数即可，格式为：url selector。 只将test.html页面中类名为.para的元素加载进来。 1$('#resText').load('text.html .para') 回调函数load()的回调有三个参数，分别是： responseText：请求返回的内容。 textStatus：请求状态：success、error、notmodified、timeout 四种。 XMLHttpRequest： XMLHttpRequest对象。 $.get()和$.post()方法使用get的方式进行异步请求，格式为：$.get( url , [data] , [callback] , [type] )。 url：请求的文件地址。 data：可选参数，发送至服务器的数据，会附加到url地址中。 callback：可选参数，载入成功时回调函数，只有当Response返回的状态是success才能调用。 type：可选参数，服务器返回的格式，包括 xml、html、script、json、text、_default。 回调函数回调函数只有当数据成功返回(success)才能被调用，这点和load()方法不同，回调函数有两个参数，分别是data、textStatus。 data是成功后返回的数据，textStatus是请求状态。 $.getScript()和$.getJson()方法$.getScript()用于加载一个新的js文件，和写一个&lt;script&gt;标签的效果是一样的，但因为在页面初次加载时就取得所有js文件是没有必要的，所以就需要这个方法。 $.getScript()的第一个参数是js文件的地址，第二个参数是回调函数，回调只会在js文件成功加载后才会运行。 $.getJson()用于获取json文件，使用方法和$.getScript()相同。只是在回调函数中可用一个参数来获取json的内容。 $.ajax()方法$.ajax()是jQuery最底层的ajax实现，上面的所有方法都可以用这个方法代替。 $.ajax()的参数是一个对象，对象中的每个参数都是可选的，具体的参数如下： 参数名称 类型 说明 url string 默认是当前页面，发送请求的地址 type string 请求方式，默认为get方式 timeout number 设置请求超时的时间，单位是毫秒 data object或string 发送到服务器的数据 dataType string 预期服务器返回的数据类型，如果不指定，jQuery将自动根绝http的MIME信息返回responseXML或responseText，可选择的格式有：xml(xml文档)、html(纯html文本，包含的script标签会在插入dom时执行)、script(返回纯文本js代码，不会自动缓存结果，如果是跨域请求，则post方式都会转为get方式)、json(返回json数据)、jsonp(跨域获取数据，使用jsonp形式调用函数时，url地址的最后一个参数名是callback，值是?，这个?将由jQuery替换为正确的函数名，用以执行回调函数)、text(纯文本) beforeSend function 发送请求前可以更改XMLHttpRequest对象的函数，例如添加自定义http头，在beforeSend中返回false可以取消本次ajax的请求，改函数的唯一参数就是XMLHttpRequest对象，this是本次ajax请求时传递的options参数 complete function 请求完成后调用的回调函数，失败和成功都会调用，第一个参数是XMLHttpRequest对象，第二个参数是描述成功请求类型的字符串，this是本次ajax请求时传递的options参数 success function 请求成功后的回调函数，第一个参数是返回的数据，第二个参数是描述状态的字符串，this是本次ajax请求时传递的options参数 error function 请求失败时调用的函数，第一个参数是XMLHttpRequest对象，第二个参数是错误信息，第三个参数是捕获的错误对象，this是本次ajax请求时传递的options参数 global boolean 默认为true，表示是否触发全局ajax事件，设置为false将不会触发。 需要注意的是，如果将传递给服务器的数据使用字符串拼接的方式拼接到url上，必须使用encodeURIComponent()方法转码，如果是写到data属性则不需要。 序列化元素serialize()方法在提交表单的时候，需要给服务器传表单中的数据，如果表单的内容比较多，一个个获取比较麻烦，jQuery提供了一个简化的方法serialize(),它能够将dom元素的内容序列化为字符串，用于ajax请求。例如表单的id为form，那么可以将ajax的data属性直接写为$(&#39;#form&#39;).serialize()。 serializeArray()方法和serialize()方法类似，但是serializeArray()方法不是返回字符串，而是将DOM元素序列化后，返回json格式的数据。 html代码1234&lt;input type="checkbox" name="user" value="1" checked&gt;&lt;input type="checkbox" name="user" value="2" checked&gt;&lt;input type="checkbox" name="user" value="3"&gt;&lt;input type="checkbox" name="user" value="4"&gt; js代码12var fields = $(":checkbox").serializeArray();console.log(fields); // 打印一个数组[ &#123;name:'user',value:'1'&#125; , &#123;name:'user',value:'2'&#125; ] $.param()方法这是serialize()方法的核心，用以将一个数组或对象按照key/value进行序列化。比如将一个普通对象序列化 123var obj = &#123; a:1,b:2,c:3 &#125;;var k = $.param(obj);console.log(k); // 输出a=1&amp;b=2&amp;c=3 Ajax全局事件通过jQuery提供的一些自定义全局函数，能够为各种与Ajax相关的事件注册回调函数。 例如当请求开始时，会触发ajaxStart()方法的回调函数，当请求结束时，会触发ajaxStop()方法的回调函数。这些都是全局方法，因此无论创建它们于代码何处，只要有Ajax请求发生时，就会触发它们。 html代码1&lt;div id="loading"&gt;加载中...&lt;/div&gt; js代码 1234567$('#loading').ajaxStart(function()&#123; $(this).show();&#125;)$('#loading').ajaxStop(function()&#123; $(this).hide();&#125;) 还有另外几个方法： 方法名称 说明 ajaxComplete(callback) Ajax请求完成时执行的函数 ajaxError(cakkback) Ajax请求发生错误时执行的函数，捕捉到的错误可以作为最后一个参数传递 ajaxSend(callback) Ajax请求发送前执行的函数 ajaxSuccess(callback) Ajax请求成功时执行的函数 如果不想让Ajax触发这些全局方法，可以将global设置为false，在jQuery1.5版本之后可以设置：123$.ajaxPrefilter(function(options)&#123; options.global = true;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》五、jQuery的动画]]></title>
      <url>%2F2017%2F07%2F14%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%BA%94%E3%80%81jQuery%E7%9A%84%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[show()和hide()hide()方法是让元素隐藏，执行时候其实有两步，第一步是记住元素隐藏前的display属性值，第二步是将display设置为none。 show()方法会获取hide()第一步获取的那个属性并重新设置给元素的display属性。 这两个方法可以接收一个速度参数，显示和隐藏的毫秒值，$(&#39;#box&#39;).hide(1000)这样$(&#39;#box&#39;)元素从显示到隐藏会经过1000毫秒的动画过度，不会突然消失，执行过渡时，会同时改变元素的高度、宽度和不透明度，直至这三个属性都为0最后元素css会改为display: none。 参数也可以直接传入&#39;slow&#39;、&#39;normal&#39;、&#39;fast&#39;，分别代表600毫秒、400毫秒、200毫秒。也可以传入毫秒数。 fadeIn()和fadeOut()与show()方法不同的是，这两个方法只改变不透明度。fadeOut()方法会在指定的一段时间内降低元素的不透明度，直到display:none。fadeIn()方法则相反。 slideUp()和slideDown()改变元素的高度，如果一个元素是display:none，当调用slideDown()时，这个元素将由上至下延伸显示。slideUp()方法正好相反。元素将由下至上缩短隐藏。 以上几种动画第一个参数是速度，都可以传&#39;slow&#39;、&#39;normal&#39;、&#39;fast&#39;参数或者直接传入毫秒数。第二个参数是easing，是动画的运动方式，可选&#39;swing&#39;、&#39;linear&#39;分别是慢-快-慢和匀速。第三个参数是callback回调函数。 自定义动画animate()常用格式为animate(params,speed,easing,callback)。 params:一个包含样式属性及值的对象。例如{top:&#39;200px&#39;,left:&#39;200px&#39;} speed:速度参数，可选参数。 easing:设置动画的节奏，可选值是swing慢-快-慢和linear匀速，可选参数。 callback:在动画完成时执行的函数，可选参数。 定义一个普通的动画123$('#box').click(function()&#123; $(this).animate(&#123;left:'500px'&#125;,3000);&#125;) 累加、累减动画123$('#box').click(function()&#123; $(this).animate(&#123;left:'+=500px'&#125;,3000);&#125;) 在当前位置累加500px;当然也可以累减。 多重动画同时改变元素的高度的位置。 123456$('#box').click(function()&#123; $(this).animate(&#123; left:'500px', height:'200px' &#125;,3000);&#125;) 先改变元素的位置，移动完成后再改变元素的高度。在left执行完之前不会改变height的值。这种有先后顺序执行的动画称为动画队列。 1234567$('#box').click(function()&#123; $(this).animate(&#123; left:'500px' &#125;,3000).animate(&#123; height:'200px' &#125;,3000);&#125;) 这里如果在最后直接写.css(...)，那么会不等动画执行，直接执行css的改变。css()方法不会加入队列，只有动画的方法才能加入队列。如果想让非动画方法方法加入队列就要写在回调函数里。 停止动画格式为：stop([clearQueue],[gotoEnd]) clearQueue和gotoEnd都是可选参数，布尔值。 clearQueue代表是否要清空未执行完的动画队列。gotoEnd代表是否将正在执行的动画跳转到末状态。 判断动画执行状态使用animate要避免动画重复累计的执行，可以提前进行判断。 123if(!$('#box')is(':animate'))&#123; // 如果没有动画正在执行就加入新动画。&#125; 延迟动画在动画执行过程中，如果想延迟执行，可以使用delay()方法。可以将队列中的函数延迟执行，参数是毫秒值。 123456789$('#box').click(function()&#123; $(this).animate(&#123; left:'500px' &#125;,3000) .delay(1000) .animate(&#123; height:'200px' &#125;,3000);&#125;) 用于交互的动画方法toggle()格式为：toggle(speed,easing,callback) toggle()方法可以切换元素的可见状态。如果元素是可见的，则切换为隐藏的；如果元素是隐藏的，则切换为可见的。相当于先后执行了show()和hide()。 slideToggle()格式为：slideToggle(speed,easing,callback) 通过高度变化来切换匹配元素的可见性，这个动画效果只调整元素的高度。相当于先后执行了slideUp()和slideDown()方法。 可以设置参数speed、callback。 fadeTo()格式为：fadeTo(speed,opacity,easing,callback) 把元素的不透明度以渐进的方式调整到指定的值。只调整元素的不透明度。 fadeToggle()格式为：fadeToggle(speed,easing,callback) 通过不透明度来切换匹配元素的可见性，只能调整不透明度，相当于先后执行了fadeOut()和fadeIn()方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局]]></title>
      <url>%2F2017%2F07%2F07%2Fflexbox%20%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[flexbox是什么即使不知道视窗大小或者未知元素情况之下都可以智能的、灵活的调整和分配元素和空间两者之间的关系。简单的理解，就是可以自动调整，计算元素在容器空间中的大小。 使用flexbox要开始使用flexbox，必须先让父元素变成一个flex容器，而此时子元素就变成了flex项目。 可以在父元素中设置display:flex或者display:inline-flex。这样一个flexbox格式上下文就启动了。 html结构12345&lt;ul&gt; &lt;!--parent element--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--first child element--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--second child element--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--third child element--&gt;&lt;/ul&gt; css样式1234567891011ul &#123; display: flex; border: 1px solid pink;&#125;li &#123; list-style: none; width: 100px; height: 100px; background-color: #8cacea; margin: 8px;&#125; flex容器属性 flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content 当父元素设置为一个flex容器后，这几个属性可以直接使用在flex容器上。 flex-directionflex-direction属性控制flex项目沿着主轴(Main Axis)的排列方向。 这个属性具有四个值，分别是水平、垂直、水平反向、垂直反向 row(默认) || column || row-reverse || column-reverse 简单来说就是flex-direction属性让你决定flex项目如何排列，其实水平和垂直在flex中不是方向概念，它们常常被称为主轴(Main-Axis)和侧轴(Cross-Axis) 如果把flex-direction属性改为column，这时flex项目将沿着Cross-Axis从上到下垂直排列。 html结构12345&lt;ul&gt; &lt;!--parent element--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--first child element--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--second child element--&gt; &lt;li&gt;&lt;/li&gt; &lt;!--third child element--&gt;&lt;/ul&gt; css样式12345678910111213ul &#123; display: flex; flex-direction: column; border: 1px solid pink;&#125;li &#123; list-style: none; width: 100px; height: 100px; background-color: #8cacea; margin: 8px;&#125; 在flex-direction改变方向后，实际上是改变的Main-Axis和Cross-Axis两个轴的方向，如果设置flex-direction: column;，那么实际上就是Main-Axis和Cross-Axis调换了位置。这将会影响之后基于Main-Axis和Cross-Axis的所有flex属性的设置。 flex-wrapflex-wrap属性有三个属性值，分别是换行、不换行、反向换行 wrap || nowrap(默认) || wrap-reverse flex的默认行为会在一行内容纳所有的flex项目，即使浏览器出现滚动条(当flex项目的总体宽度大于浏览器窗口宽度)。默认是不换行的。 当flex项目过多时，也不会换行，所以每个项目会被压缩。而且如果flex项目元素内有类似文字等内容会撑开flex项目，那么浏览器就会出现滚动条。 如果希望flex容器在其flex项目达到一定数量能换行，将flex-wrap设置为wrap即可。当一行再不能包含所有列表项的默认宽度，就会多行排列。 除此之外，还有一个值wrap-reverse。它让flex项目在容器中多行排列，只是方向是相反的。 flex-flowflex-flow是flex-direction和flex-wrap两个属性的连写属性。 就好比border: 1px solid red的概念 flex-flow: row wrap相当于flex-direction: row; flex-wrap: wrap;的写法。 justify-contentjustify-content属性主要定义了flex项目在Main-Axis上的对齐方式，有五个值可选： flex-start(默认) || flex-end || center || space-between || space-around justify-content: flex-start;是让所有flex项目靠Main-Axis开始边缘(左对齐)，也就是默认。 justify-content: flex-end;是让所有flex项目靠Main-Axis结束边缘(右对齐)。 justify-content: center;让所有flex项目排在Main-Axis的中间(居中) justify-content: space-between; 让除了第一个和最后一个flex项目的两者间间距相同(两端对齐) justify-content: space-around;让每个flex项目具有相同的空间，相当于是给每个flex项目相同的margin-left和margin-right align-itemsalign-items属性类似于justify-content属性，主要是控制flex项目在Cross-Axis对齐方式，有五个可选值： flex-start || flex-end || center || stretch(默认) || baseline align-items: stretch;在没有设置flex高度的情况下，让所有的flex项目高度和flex容器高度一样。 align-items: flex-start;让所有flex项目靠Cross-Axis开始边缘(顶部对齐) align-items: flex-end;让所有flex项目靠Cross-Axis结束边缘(底部对齐) align-items: center;让flex项目在Cross-Axis中间(居中对齐) align-items: baseline;让所有flex项目在Cross-Axis上沿着他们自己的基线对齐 align-contentalign-content必须用于多行的flex容器，也是用来控制flex项目在flex容器里的排列方式，效果和align-items相似，可选五个值： flex-start || flex-end || center || stretch(默认) align-content: stretch;会拉伸flex项目，让他们沿着Cross-Axis适用flex容器可用的空间。 align-content: flex-start;让多行flex项目靠Cross-Axis开始边缘。 align-content: flex-end;让多行flex项目靠Cross-Axis结束位置 align-content: center;让多行flex项目在Cross-Axis中间 flex项目属性 order || flex-grow || flex-shrink || flex-basis order允许flex项目在一个flex容器中重新排序，基本上可以改变flex项目的顺序从一个位置移到另一个地方。 这也意味着flex项目的位置改变在html中不需要改变源代码。 order的默认值是0，也可以接收一个正值或一个负值。数值越大的flex项目排序越往后，如果两个以上flex项目有相同的order值，flex项目重新排序是基于html源文件的位置进行排序 1234567&lt;ul&gt; &lt;li style="font-size:24px;"&gt;列表项1&lt;/li&gt; &lt;li style="font-size:24px;"&gt;列表项2&lt;/li&gt; &lt;li style="font-size:24px;"&gt;列表项3&lt;/li&gt; &lt;li style="font-size:24px;"&gt;列表项4&lt;/li&gt; &lt;li style="font-size:24px;"&gt;列表项5&lt;/li&gt;&lt;/ul&gt; 123456789101112li:nth-child(1) &#123; order: 2;&#125;li:nth-child(2) &#123; order: 1;&#125;li:nth-child(3) &#123; order: 3;&#125;li:nth-child(4) &#123; order: 3;&#125; flex-grow和flex-shrinkflex-grow属性控制flex项目在容器有多余的控件如何放大。默认值0。 flex-shrink属性控制flex项目在容器没有额外空间又如何缩小。默认值1。 取值范围是0或者大于0的任何正数值，这个数值是设置flex项目在容器中所占比。 首先来看flex-grow: 0;的效果 flex容器有多余的空间，这时将flex-grow: 1;即可让flex忽略自己本身的宽度，平均分配flex内部的空间，通过这个数值也可以改变每个flex项目所占空间的占比。 而flex-shrink属性和flex-grow属性是相反的，现在设置flex-shrink: 0;看一下。 如果像是这样flex项目的宽度多出了flex容器，那么就需要将flex-shrink: 1;，这样会压缩flex项目的宽度，让其平均分配flex容器的空间，数值也是flex的占比。 flex-basisflex-basis属性可以指定flex项目的初始大小，也就是在flex-grow和flex-shrink调整之前的大小。 flex-basis默认值是auto，可以取任何用于width属性的值，比如% || em || rem || px等等。但是如果要设置为0的话也要带有单位，flex-basis: 0;这种写法是错误的。 flex-basis: auto; 这是默认情况flex项目的宽度。 可以看出flex项目的宽度就是由内容撑开，而使用flex-basis: 150px;这样flex的宽度就被设置为了固定的150px; flex连写flex是flex-grow、flex-shrink、flex-basis三个属性的连写。 flex: 0 1 auto;相当于flex-grow: 0; flex-shrink: 1; flex-basis: auto; align-selfalign-self可以改变一个弹性项目沿着侧轴的位置，而不影响相邻的弹性项目。该属性的可选值为： auto(默认) || flex-start || flex-end || center || baseline || stretch。 align-self: flex-end;、align-self: center;、align-self: flex-start;三个值的效果。 align-self: stretch;会将目标flex项目拉伸，以沿着Cross-Axis填满flex容器的可用空间。 align-self:baseline;将目标flex项目沿着基线对齐，在这里效果和flex-start效果相同。 最后一个是align-self: auto;是将目标flex项目的值设置为父元素的align-items的值，或者如果该元素没有父元素的话，就设置为stretch。 相对和绝对flex项目相对和绝对flex项目主要区别在于间距和如何计算间距，相对flex项目内的间距是根据它的内容大小来计算的，而在觉得flex项目中，只根据flex属性来计算。 先来看相对flex，flex项目设置flex: auto，这个设置和flex: 1 1 auto;是相同的，这样flex项目就是基于其包含内容的大小而计算的。下面的图中每个flex项目的内容不同，其占的宽度也不相同。 下面来设置成绝对的flex项目，flex: 1;这个设置和flex: 1 1 0;效果是一样的。flex-basis: 0;的情况下，flex项目会基于flex-grow来计算自己的空间，而flex-grow: 1;，所以每个flex所占空间相同。 从上面可以得出结论，绝对flex项目的宽度只基于flex属性，相对flex的宽度基于内容的大小。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》四、jQuery的事件]]></title>
      <url>%2F2017%2F07%2F06%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%9B%9B%E3%80%81jQuery%E7%9A%84%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[加载DOMjQuery中$(document).ready()方法运行时代表DOM已经加载完毕，用此方法代替window.onload方法可以极大地提高web应用程序的响应速度。 此方法的另一种写法是$(function(){})。 事件绑定使用bind()来进行事件绑定。格式为bind( type,[data],fn )。 第一个参数是事件类型，不需要加on。 第二个参数是可选参数，是传递给事件对象的额外数据对象。 第三个参数是事件处理函数。 123$('#box').bind('click',function()&#123; &#125;) 还有一种简写方式 123$('#box').click(function()&#123; &#125;) bind()还可以为一个元素绑定多个事件：$(&#39;#box&#39;).bind(&#39;mouseover mouseout&#39;,function(){})。 合成事件hover()用于模拟光标悬停事件，格式为hover(enter,leave)，当光标移动到元素上时，会触发指定的第一个函数，当光标移出这个元素时，会触发指定的第二个函数。 12345$('#box').hover(function()&#123; // 光标移入&#125;,function()&#123; // 光标移出&#125;) toggle()用于模拟鼠标连续单击事件，格式为toggle(fn1,fn2...fnN)，第一次单机触发指定的第一个函数，再点击同一元素时，触发第二个函数，如果有更多函数则依次触发直到最后一个函数，随后的每次单机都重复对这几个函数的轮番调用 1234567$('#box').toggle(function()&#123; // 第一次点击&#125;,function()&#123; // 第二次点击&#125;,function()&#123; // 第三次点击，下次点击将从第一次开始&#125;) 这个方法还有另一种用法，可以切换元素的可见状态，如果元素是可见的，点击后则为隐藏，如果是隐藏的，点击后则为可见的。 12345$('#box').toggle(function()&#123; $(this).next().toggle();&#125;,function()&#123; $(this).next().toggle();&#125;) 事件冒泡通过事件对象的stopPropagation()方法来阻止事件冒泡。 123$('span').bind('click',function(event)&#123; event.stopPropagation();&#125;) jQuery中并不支持事件捕获 阻止默认行为通过事件对象的preventDefault()方法来阻止元素的默认行为。 有时候元素的默认行为需要阻止，比如阻止链接的跳转和阻止表单的提交，此时就需要用到此方法。 123$('span').bind('click',function(event)&#123; event.preventDefault();&#125;) 如果既需要阻止冒泡也需要阻止默认行为，可以在事件处理函数中简写为return false。 事件对象的属性jQuery对事件对象进行了封装，不存在兼容性问题，下面介绍几个常用的属性 event.type该方法的作用是可以获取到事件的类型 123$('#box').click(function(event)&#123; console.log(event.type) // 打印'click'&#125;) event.preventDefault()阻止默认的事件行为 event.stopPropagation()阻止事件的冒泡行为 event.target获取到触发事件的元素 123$('#box').click(function(event)&#123; console.log(event.target) // 打印整个$('#box')元素&#125;) event.reatedTarget获取比如mouseover和mouseout事件发生所相关的元素，对于mouseout，event.relatedtarget指向将进入的页面元素；而mouseover, 指向的是刚掠过的页面元素。 和event.target的区别是，一个是触发事件的主体元素，一个是存在过渡的事件的相关主体之一。 event.pargeX和event.pageY获取到光标相对于页面的x坐标和y坐标 event.which在鼠标点击事件中获取到鼠标的左、中、右键，在键盘相关事件中获取键盘的按键。 1234567$('#box').mousedown(function(event)&#123; console.log(event.which) // 1=鼠标左键 2=鼠标中键 3=鼠标右键&#125;)$('#box').keydown(function(event)&#123; console.log(event.which) // 获取按下的那个按键&#125;) event.metaKey在键盘事件中获取ctrl按键。 移除事件通过unbind()方法来移除元素的方法，格式为unbind([type],[data]) 第一个参数是事件类型，第二个参数是将要移除的函数 如果没有参数则删除所有绑定事件 如果提供了事件类型作为参数，则只删除该类型的绑定事件。 如果把在绑定时传递的处理函数作为第二个参数，则只有这个特定的事件处理函数会被删除。 1234567$('#box').bind('click',fun1 = function()&#123; // 绑定一个点击事件&#125;)$('#btn').click(function()&#123; $('#box').unbind('click',fun1); // 删除绑定函数fun1 &#125;) 另外jQuery还提供了一种简写方法，当事件处理函数触发一次后，立即删除，就是one()方法，使用方法和bind()相同。 模拟操作常用模拟以上的事件都是需要用户去操作才能触发的，jQuery中还可以模拟用户的操作，可以使用trigger()方法完成模拟操作。 $(&#39;#btn&#39;).trigger(&#39;click&#39;);这样就模拟了点击事件，也可以直接简写为$(&#39;#btn&#39;).click(); trigger(type,[data])方法有两个参数，第一个参数是要出发的事件类型，第二个参数是要传递给事件处理函数的附加数据，以数组形式传递。通常可以通过传递一个参数给回调函数来区别这次事件是代码触发的还是用户触发的。 12345$('#btn').click(function(event,msg1,msg2)&#123; alert(msg1 + msg2); // 页面加载时打印12,&#125;)$('#btn').trigger('click',['1','2']) trigger()方法有一个问题，那就是会触发事件的浏览器默认行为，比如$(&#39;input&#39;).trigger(&#39;focus&#39;);，我想触发表单的focus事件处理函数，但是不想真的让表单获取焦点，这时就可以使用triggerHandler()方法，$(&#39;input&#39;).triggerHandler(&#39;focus&#39;);这样既会触发表单的获取焦点的处理函数，还不会让表单获取焦点。 事件的命名空间可以把为元素绑定的多个事件类型用命名空间规范起来。 123456789101112131415$('#box').bind('click.plugin',function()&#123; &#125;)$('#box').bind('mouseover.plugin',function()&#123; &#125;)$('#box').bind('dbclick',function()&#123; &#125;)$('#btn').click(function()&#123; $('#box').unbind('.plugin'); // 删除$('#box')元素带有.plugin命名空间的事件&#125;) 这样添加命名空间后，在删除事件时只需要删除指定命名空间即可，没有指定该命名空间的事件不会被删除。 命名空间还有另外一种用法，元素绑定相同的事件类型，然后以命名空间的不同可以按需调用。 123456789101112$('#box').bind('click',function()&#123; &#125;)$('#box').bind('click.pligin',function()&#123; &#125;)$('#btn').click(function()&#123; $('#box').trigger('click!');&#125;) 如果点击$(&#39;#box&#39;)会同时触发click事件和click.plugin事件。如果点击$(&#39;#btn&#39;)元素则只触发click事件，因为trigger(&#39;click!&#39;);中的叹号是匹配所有不包含命名空间的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IScroll-5的文档]]></title>
      <url>%2F2017%2F07%2F03%2FIScroll-5%E7%9A%84%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[结构使用IScroll这个脚本库时，DOM树的结构要足够简单，移除不必要的标签，尽量避免过多的标签嵌套使用。 最优的使用iScroll的结构如下所示 123456&lt;div id="wrapper"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ..... &lt;/ul&gt;&lt;/div&gt; 只有wrapper里的第一个子元素才可以滚动，如果你想要更多的元素可以滚动，那么你可以试试下面的这种写法 123456789101112&lt;div id="wrapper"&gt; &lt;div id="scroller"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ... &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ... &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 实例化IScroll123&lt;script&gt; var myscroll=new IScroll("wrapper",&#123;hScrollbar:false, vScrollbar:false&#125;);&lt;/script&gt; 第一个参数是滚动元素外层容器的选择器字符串，也可以是元素对象。 注意，IScroll使用的是querySelector 而不是 querySelectorAll，所以IScroll只会作用到选择器选中元素的第一个。如果你需要对多个对象使用IScroll，你需要构建自己的循环机制。 第二个参数是一个对象。 在初始化之后，可以通过options对象访问标准化值。如果设置了浏览器不支持的属性，那么即使在初始化时设置为true，在这里也会显示为false。 1console.log(myScroll.options); IScroll的核心参数options.useTransform默认值是true 如果设置为false，将使用top/left属性这种老的方式进行滚动。 这个属性在滚动器感知到Flash，iframe或者视频插件内容时会有用，但是需要注意：性能会有极大的损耗。 options.useTransition默认是true 使用css的transition实现动画效果(动量和弹力)，如果设置为false，将使用requestAnimationFrame代替，在旧设备上transition执行的更好 options.HWCompositing默认是为true 这个选项尝试使用translate(0)来把滚动器附加到硬件层，以此来改变css属性，在移动设备上将提高性能 如果不确定IScroll的最优配置，从性能角度出发，上面的所有选项都应该设置为true IScroll的基本参数options.bounce默认值true 滚动到边界反弹动画，在旧的设备上禁用对实现平滑滚动有帮助。 options.click默认值是false 为了重写原生滚动条，iScroll禁止了一些默认的浏览器行为，比如鼠标的点击。如果你想你的应用程序响应click事件，那么该设置次属性为true。 options.disableMouse、options.disablePointer、options.disableTouch默认值是false 可以把你不需要的事件禁用（鼠标，指针、触摸事件），设置为true是禁用。 options.eventPassthrough有些时候你想保留原生纵向滚动条，但是想为横向滚动条增加IScroll功能。就可设置为true。 实现横向滚动的代码如下： js部分 12345var myScroll = new IScroll('#wrapper', &#123; eventPassthrough: true, scrollX: true, scrollY: false&#125;); html部分 12345678&lt;div id="wrapper"&gt; &lt;div id="scroller"&gt; &lt;ul&gt; &lt;li&gt;11111111111&lt;/li&gt; ...... &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; css部分 123456789101112131415161718#wrapper &#123; width: 100%; background: #eeeeee; overflow: hidden;&#125;#scroller &#123; z-index: 1; width: 1010px;&#125;#scroller li &#123; width: 100px; float: left; font-size: 14px; overflow: hidden; text-align: center;&#125; options.freeScroll默认值是false 可以横轴和纵轴同时滚动，需要设置为true。代码实例如下： js部分 1234myScroll = new IScroll('#wrapper', &#123; scrollX: true, freeScroll: true&#125;); html部分 123456&lt;div id="wrapper"&gt; &lt;div id="scroller"&gt; &lt;p&gt;111111111111111111111111111111111111&lt;/p&gt; ...... &lt;/div&gt;&lt;/div&gt; css部分 1234567891011121314151617181920#wrapper &#123; position: relative; height: 200px; width: 200px; background: #666; overflow: hidden;&#125;#scroller &#123; position: absolute; z-index: 2; width: 2000px; background: #fff;&#125;p &#123; font-size: 16px; line-height: 1; overflow: hidden;&#125; options.keyBindings默认值false 设置为true时可以激活键盘绑定。 options.invertWheelDirection默认为false 当鼠标滚轮支持激活后，在有些情况下需要反转滚动的方向。（比如，鼠标滚轮向下滚动条向上）。 options.momentum默认值true 在用户快速触摸屏幕时，你可以开/关势能动画。关闭此功能将大幅度提升性能。 options.mouseWheel默认值false 是否监听鼠标滚轮事件。 options.preventDefault默认值true 当事件触发时是否执行preventDefault()。此属性应该设置为true。 options.preventDefault默认值false 是否显示为默认的滚动条。 options.scrollX、options.scrollYscrollX默认值false，scrollY默认值true scrollX为是否进行横向滚动，scrollY为是否进行纵向滚动 options.startX、options.startY默认值0 默认情况下iScroll从0, 0 (top left)00位置开始，通过此属性可以让滚动条从不同的位置开始滚动。 options.tap默认false 设置此属性为true，当滚动区域被点击或者触摸但并没有滚动时，可以让iScroll抛出一个自定义的tap事件。 滚动条滚动条不只是像名字所表达的意义一样，在内部它们是作为indicators的引用。 一个指示器侦听滚动条的位置并且现实它在全局中的位置，但是它可以做更多的事情。 options.scrollbars激活滚动条，代码如下： 123var myScroll = new IScroll('#wrapper', &#123; scrollbars: true&#125;); options.fadeScrollbars默认值false 设置为true则滚动条使用淡入淡出的方式，不适用淡入淡出比较节省资源。 options.interactiveScrollbars默认值false 设置为true可以让滚动条能拖动 options.resizeScrollbars默认值true 滚动条尺寸改变基于容器和滚动区域的宽/高之间的比例。此属性设置为false让滚动条固定大小。这可能有助于自定义滚动条样式 options.shrinkScrollbars有效值是clip和scale clip是移动指示器到它容器的外面，效果就是滚动条收缩起来，简单的移动到屏幕以外的区域。属性设置为此值后将大大的提升整个iScroll的性能。 scale关闭属性useTransition，之后所有的动画效果将使用requestAnimationFrame实现。指示器实际上有各种尺寸，并且最终的效果最好。 如果页面在多种设备上运行最好使用scale，在旧的设备上应该设置为clip。 滚动条样式如果不喜欢默认的滚动条样式，可以自定义。 第一步是设置选项scrollbars的值为custom。 以下内容是自定义滚动条需要设置的css类名 .iScrollHorizontalScrollbar这个样式应用到横向滚动条的容器。这个元素实际上承载了滚动条指示器。 .iScrollVerticalScrollbar和上面的样式类似，只不过适用于纵向滚动条容器。 .iScrollIndicator真正的滚动条指示器。 .iScrollBothScrollbars这个样式将在双向滚动条显示的情况下被加载到容器元素上。通常情况下其中一个（横向或者纵向）是可见的。 指示器上面所有关于滚动条的选项实际上是包装了一个底层的选项indicators。它看起来或多或少像这样 1234567891011121314var myScroll = new IScroll('#wrapper', &#123; indicators: &#123; el: [element|element selector] fade: false, ignoreBoundaries: false, interactive: false, listenX: true, listenY: true, resize: true, shrink: false, speedRatioX: 0, speedRatioY: 0, &#125;&#125;); options.indicators.el这是一个强制性的参数，它保留了指向滚动条容器元素的引用，容器里的第一个子元素就是指示器，而且滚动条可以在文档的任何地方，它不需要在滚动条包装器内。 格式如下： 123indicators: &#123; el: document.getElementById('indicator')&#125; 或者 123indicators: &#123; el: '#indicator'&#125; options.indicators.ignoreBoundaries默认值false 这个属性告诉指示器忽略它容器所带来的边界，比如想让指示器是滚动条速度的两倍，指示器将很快到达它的结尾，这个属性被用在视差滚动。 options.indicators.listenX、options.indicators.listenY默认值true 指示器的横向和纵向被侦听。可以设置一个或者都设置 options.indicators.speedRatioX、options.indicators.speedRatioY默认值0 指示器移动的速度和主要滚动条大小的关系，默认情况下是设置为自动。基本不需要改变的参数。 options.indicators.fade、options.indicators.interactive、options.indicators.resize、options.indicators.shrink这几个选项和已经介绍过的滚动条中的一样，可以参考下面这个案例 js部分 123456789101112myScroll = new IScroll('#wrapper', &#123; startX: -359, // 初始位置 startY: -85, scrollY: true, // 横向纵向可同时滚动 scrollX: true, freeScroll: true, mouseWheel: true, indicators: &#123; el: document.getElementById('minimap'), // 指向滚动条容器元素的引用，容器里的第一个子元素就是指示器 interactive: true // 让指示器可滚动 &#125;&#125;); html部分 12345678&lt;div id="wrapper"&gt; &lt;div id="scroller"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id="minimap"&gt; &lt;div id="minimap-indicator"&gt; &lt;/div&gt;&lt;/div&gt; css部分 12345678910111213141516171819202122232425262728293031323334#wrapper &#123; position: absolute; z-index: 1; width: 235px; height: 321px; top: 0; left: 0; background: #555; overflow: hidden;&#125;#scroller &#123; position: absolute; z-index: 1; width: 797px; height: 1087px; background: url(ermine.jpg);&#125;#minimap &#123; position: absolute; z-index: 1; width: 235px; height: 321px; background: url(ermine.jpg); background-size: 235px 321px; top: 0px; left: 245px;&#125;#minimap-indicator &#123; position: absolute; z-index: 1; border: 1px solid #fe0; box-shadow: 0 0 5px #000; background: rgba(255,255,255,0.15);&#125; 视差滚动视差滚动时指示器的一个功能，指示器是一个遵循主滚动条移动和动画的层。增加这个功能就可以创建任意数量的指示器和视差滚动。 js部分 1234567891011121314myScroll = new IScroll('#wrapper', &#123; mouseWheel: true, indicators: [&#123; el: document.getElementById('starfield1'), resize: false, ignoreBoundaries: true, speedRatioY: 0.4 &#125;, &#123; el: document.getElementById('starfield2'), resize: false, ignoreBoundaries: true, speedRatioY: 0.2 &#125;]&#125;); html部分 12345678910&lt;div id="wrapper"&gt; &lt;div id="scroller"&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id="starfield1" class="starfield"&gt; &lt;div id="stars1"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="starfield2" class="starfield"&gt; &lt;div id="stars2"&gt;&lt;/div&gt;&lt;/div&gt; css部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#wrapper &#123; position: absolute; z-index: 3; width: 100%; top: 0; left: 0; bottom: 0; overflow: hidden;&#125;#scroller &#123; position: absolute; z-index: 3; width: 100%; height: 4000px; overflow: hidden; background: url(galaxies1.png);&#125;#starfield1 &#123; z-index: 2;&#125;.starfield &#123; position: absolute; width: 100%; top: 0; left: 0; bottom: 0; overflow: hidden;&#125;.starfield div &#123; position: absolute; width: 100%; overflow: hidden;&#125;#stars1 &#123; z-index: 2; height: 3000px; background: url(galaxies2.png);&#125;#stars2 &#123; z-index: 1; height: 2000px; background: url(stars.jpg);&#125; 滚动的接口可以通过下面的方法滚动到指定位置 scrollTo(x, y, time, easing)初始化IScroll之后会创建一个myScroll实例(名字是自己定义的变量)，可以通过myScroll.scrollTo(0, -100)滚动到任意位置。因为左上角永远是0，所以向下滚动一定是负数 参数time和easing是可选项，他们控制滚动周期（毫秒）和动画的擦除效果。动画擦除对象是IScroll.utils.ease，可擦除动画类型有quadratic, circular, back, bounce, elastic。 示例：myScroll.scrollTo(0, -100, 1000, IScroll.utils.ease.elastic); scrollBy(x, y, time, easing)和上面一个方法类似，但是可以传递X和Y的值从当前位置进行滚动。 myScroll.scrollBy(0, -10)会在当前位置向下滚动10个像素。 scrollToElement(el, time, offsetX, offsetY, easing)在这个方法中只有一个强制的参数就是el。传递一个元素或者一个选择器，IScroll将尝试滚动到这个元素的左上角位置。 time是可选项，用于设置动画周期。 offsetX 和 offsetY定义像素级的偏移量，如果把这两个参数设置为true，元素将会位于屏幕的中间。 easing和之前的一样。 对齐iScroll能对齐到固定的位置和元素。 options.snap按照页面容器大小自动分割滚动条 123var myScroll = new IScroll('#wrapper', &#123; snap: true&#125;); 也可以设置滚动条将要对齐的元素的选择器 123var myScroll = new IScroll('#wrapper', &#123; snap: 'li'&#125;); goToPage(x, y, time, easing)x和y呈现想滚动到横向轴或者纵向轴的页面数，如果需要咋单个纬度上使用滚动条，只需要为你不需要的轴上传递0值。 time属性是动画周期，可选项 easing属性是滚动到指定点使用的擦除功能类型，参照option.bounceEasing对象，可选项 在一秒钟内沿着横向滚动到第10页 myScroll.goToPage(10, 0, 1000); 缩放为了使用缩放功能，你最好使用iscroll-zoom.js脚本。 options.zoom默认值false 此属性设置为true启用缩放功能。 options.zoomMax默认值4 最大缩放级数 options.zoomMin默认值1 最小缩放级数 options.startZoom默认值1 初始的缩放级数 options.wheelAction鼠标滚轮的动作可以设置为zoom，这样在滚动滚轮时缩放操作会代替原来的滚动操作。 放大的示例： js部分 1234567myScroll = new IScroll('#wrapper', &#123; zoom: true, scrollX: true, scrollY: true, mouseWheel: true, wheelAction: 'zoom'&#125;); html部分 123456&lt;div id="wrapper"&gt; &lt;div id="scroller"&gt; &lt;p&gt;111111111111111111111111111&lt;/p&gt; ...... &lt;/div&gt;&lt;/div&gt; css部分 12345678910111213141516#wrapper &#123; position: absolute; z-index: 1; top: 50px; bottom: 50px; left: 50px; right: 50px; background: #ccc; overflow: hidden;&#125;#scroller &#123; position: absolute; z-index: 1; width: 100%;&#125; zoom(scale, x, y, time)scale是缩放因子 x 和 y是缩放关注点，即缩放的中心。如果没有指定，这个中心就是屏幕中心。 time是毫秒级别的动画周期,可选 缩放功能使用的CSS的转换功能。iScroll只能在支持此CSS功能的浏览器上执行。一些浏览器（特别是基于webkit的）采取的快照缩放区域就放在硬件合成层(比如当你申请转换)。该快照作为纹理的缩放区域,它几乎不能被更新。这意味着您的纹理将基于 scale 1 进行缩放,将导致文本和图像模糊,清晰度低。一个简单的解决方案是使用实际分辨率双倍（或者三倍）装载内容，然后 放到一个按照scale(0.5)比例缩小的div中。这种方法大多数情况下能适用。 刷新IScroll需要知道包装器和滚动器确切的尺寸，在IScroll初始化的时候进行计算，如果元素大小发生了变化，需要告诉IScroll DOM发生了变化。 12345678ajax('page.php', onCompletion);function onCompletion () &#123; // 更新DOM setTimeout(function () &#123; myScroll.refresh(); &#125;, 0);&#125;; 这里调用refresh()使用了零秒等待，如果你需要立即刷新IScroll边界就是如此使用。当然还有其他方法可以等待页面重绘，但零超时方式相当稳定。 自定义事件使用on(type, fn)方法注册事件 12myScroll = new IScroll('#wrapper');myScroll.on('scrollEnd', doSomething); 可用的事件列表如下： beforeScrollStart，在用户触摸屏幕但还没有开始滚动时触发。 scrollCancel，滚动初始化完成，但没有执行。 scrollStart，开始滚动 scroll，内容滚动时触发，只有在scroll-probe.js版本中有效，请参考onScroll event。 scrollEnd，停止滚动时触发。 flick，用户打开左/右。 zoomStart，开始缩放。 zoomEnd，缩放结束。 滚动条信息iScroll存储了很多有用的信息，您可以使用它们来增强应用场景，可以说要用IScroll做一个功能这个信息是必不可少的。 最常用到的信息有 myScroll.x / y 当前位置 myScroll.directionX / Y 最后的方向（-1 down / right，0 still，1 up / left） myScroll.currentPage 当前对齐捕获点 在回调中，通过this就可获取到所有的滚动条信息。123456myScroll = new IScroll('#wrapper');myScroll.on('scrollEnd', function () &#123; if ( this.x &lt; -1000 ) &#123; // do something &#125;&#125;); 销毁在不需要使用iScoll的时候调用iScroll实例的公共方法destroy()可以释放一些内存。 12myScroll.destroy();myScroll = null;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》三、jQuery的DOM操作]]></title>
      <url>%2F2017%2F07%2F03%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B8%89%E3%80%81jQuery%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[插入节点append()向每个匹配的元素内部追加内容 $(&#39;p&#39;).append(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;);结果为&lt;p&gt;一个p元素&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;。 appendTo()将所有的匹配元素追加到指定的元素中，和append是相反的。$(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).appendTo(&#39;p&#39;);结果为&lt;p&gt;一个p元素&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;。 prepend()向每个匹配的元素内部前置内容 $(&#39;p&#39;).prepend(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;) 结果为 &lt;p&gt;&lt;b&gt;你好&lt;/b&gt;一个p元素&lt;/p&gt;。 prependTo()将所有匹配的元素前置到指定的元素中。和prepend是相反的。 $(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).prependTo(&#39;p&#39;) 结果为 &lt;p&gt;&lt;b&gt;你好&lt;/b&gt;一个p元素&lt;/p&gt;。 after()在每个匹配的元素之后插入内容。$(&#39;p&#39;).after(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;) 结果为 &lt;p&gt;一个p元素&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; insertAfter()将所有匹配的元素插入到指定元素的后面，和after是相反的。$(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).insertAfter(&#39;p&#39;) 结果为 &lt;p&gt;一个p元素&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; before()在每个匹配的元素之前插入内容。 $(&#39;p&#39;).before(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;) 结果为 &lt;b&gt;你好&lt;/b&gt;&lt;p&gt;一个p元素&lt;/p&gt; insertBefore()将所有匹配的元素插入到指定的元素的前面，和before是相反的。$(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).insertBefore(&#39;p&#39;) 结果为 &lt;b&gt;你好&lt;/b&gt;&lt;p&gt;一个p元素&lt;/p&gt; 删除节点remove()删除匹配元素本身和所有后代节点。返回值是所有删除的节点的引用，因此可以在以后再使用这些删除的元素。 $(&#39;ul li:eq(1)&#39;).remove() 获取第2个&lt;li&gt;元素节点后，将它从网页中删除。 该方法还可以传递参数，通过参数选择性的删除元素。 $(&#39;ul li&#39;).remove(&#39;li[title!=&quot;菠萝&quot;]&#39;); 将&lt;li&gt;元素中属性title不等于菠萝的&lt;li&gt;元素删除。 detach()和remove()一样也是从DOM中去掉匹配的元素，但是不会从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。和remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。 empty()empty()并不是删除节点，而是清空节点，清空匹配元素的所有后代节点。 $(&#39;ul li:eq(1)&#39;).empty() 获取第2个&lt;li&gt;元素节点后，清空此元素里的内容。 复制节点clone()通过clone()克隆一个节点，默认不可隆节点的事件，需要传参数true就可以同时复制节点中绑定的事件。 替换节点replaceWith() 和 replaceAll()替换节点是replaceWith()和replaceAll()。如果在替换之前，已经为元素绑定事件，替换后原先绑定的事件将会与被替换的元素一起消失，需要在新元素上重新绑定事件。 $(&#39;p&#39;).replaceWith(&#39;&lt;span&gt;替换为span元素&lt;/span&gt;&#39;) 将页面中的p元素替换为span元素。 $(&#39;&lt;span&gt;替换为span元素&lt;/span&gt;&#39;).replaceAll(&#39;p&#39;) 用span元素去替换页面中的p元素。 包裹节点wrap()将匹配的每个元素用其他标记包裹起来，而且它不会破坏原始文档的语义。 $(&#39;strong&#39;).wrap(&#39;&lt;b&gt;&lt;/b&gt;&#39;); 用&lt;b&gt;标签把&lt;strong&gt;元素包裹起来。结果为&lt;b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/b&gt; &lt;b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/b&gt; &lt;b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/b&gt;。 wrapAll()将所有匹配的元素用一个标签包裹起来。 $(&#39;strong&#39;).wrapAll(&#39;&lt;b&gt;&lt;/b&gt;&#39;); 用&lt;b&gt;标签把页面中所有&lt;strong&gt;元素包裹起来。结果为&lt;b&gt;&lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/b&gt;。 wrapInner()将匹配的每个元素的子内容用其他标签包裹起来。 $(&#39;strong&#39;).wrapAll(&#39;&lt;b&gt;&lt;/b&gt;&#39;); 元素&lt;strong&gt;内的内容被一对&lt;b&gt;标签包裹了。结果为`&lt;strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/strong&gt; &lt;strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/strong&gt; &lt;strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/strong&gt;。 属性操作attr()和prop()用于获取和设置属性，只传一个参数是获取一个属性的值，传两个参数是设置属性，要设置多个属性可以传入一个对象。 prop()比较适合用于设置和获取html元素的固有属性，而attr()比较适合设置和获取自定义属性。 最主要的区别是表单元素的属性，比如checked和selected，这也是固有属性，这种通常我会希望如果没有设置或者用户操作没有选中则返回false，设置了或者选中了则返回true。 1234// 用input这个标签举例子来看一下两者主要区别&lt;input type="checkbox" name="" id="ipt"/&gt;console.log($("input").attr("checked")) // 打印undefinedconsole.log($("input").prop("checked")) // 打印false 123&lt;input type="checkbox" name="" id="ipt" checked/&gt;console.log($("input").attr("checked")) // 打印checkedconsole.log($("input").prop("checked")) // 打印true removeAttr()和removeProp()只需要传一个参数，要删除的属性名。 removeAttr()会删除整个属性，而remobeProp()只会让该属性的值变为undefined，而且removeProp()对自定义属性无效。 样式操作addClass()此方法用来追加样式，在匹配元素原有类名基础之上追加一个类名，$(&#39;p&#39;).addClass(&#39;active&#39;) removeClass()删除类名，当不传参数时是删除匹配元素对象的所有类名，$(&#39;p&#39;).removeClass();就是删除所有p元素的所有类名。 也可以删除指定类名，$(&#39;p&#39;).removeClass(&#39;high&#39;);删除所有p元素的high类名。 toggleClass()替换类名，即如果传入的类名存在便删除，如果不存在就追加，$(&#39;p&#39;).toggleClass(&#39;active&#39;) hasClass()判断匹配的元素对象中是否还有某个类名，返回的是布尔值，$(&#39;p&#39;).hasClass(&#39;active&#39;) 设置和获取内容html()用于读取和设置匹配元素的html内容，和innerHTML方法的效果类似。不传参数即是获取。 text()用于读取和设置匹配元素的文本内容，和innerText方法类似，但是text()兼容所有浏览器，而innerText不兼容firefox。 val()用于读取和设置文本框、下拉列表、单选框、多选框元素的值，其中如果元素为多选，则会返回一个包含所有选择的值的数组。 如果不传参数则是获取值，传入参数是设置元素的值，由于val()专门针对表单元素，所以可以对下拉列表、单选框、多选框进行操作。 12$('#multiple').val('选项二'); //让下拉列表默认选择第二个选项，参数就是选项的文本内容$(':checbox').val(['check2','check3']) // 多选框，默认选择第二和第三项，多个参数用数组形式设置。 遍历节点children()此方法用来获取匹配元素的所有子元素的个数，这个方法只考虑子元素而不考虑后代元素。 next()获取匹配元素后面紧邻的同辈元素。 prev()获取匹配元素前面紧邻的同辈元素。 siblings()获取匹配元素前后所有的同辈元素，不包含自己。 closest()获取最近的匹配元素，首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则逐级向上查找直到找到匹配元素，如果什么都没找到返回一个空jQuery对象。 parent()、parents()parent()是获取匹配元素的父级元素，只返回一个节点。 parents()是获取匹配元素的祖先元素，返回多个节点。 find()搜索所有匹配元素下的指定的元素。 filter()获取匹配元素中符合参数表达式的元素，和find()不同的是find()是去后代中匹配，而filter()是在当前元素中去匹配。 还可以传入一个函数，函数内部return一个判断表达式，若为true，则返回表达式匹配的元素。 nextAll()获取匹配元素之后的所有同辈元素 prevAll()获取匹配元素之前的所有同辈元素 CSS-DOMcss()传入一个css属性就可以获取匹配元素的css属性值，不论行内还是外部引用的都可以获取。 传入两个参数，第一个是属性，第二个是属性值则可以设置匹配元素的css样式，也可以直接传入一个对象。对于带-符号的属性要用驼峰的写法，并且属性最好加上引号。 width()、height()直接获取匹配元素的宽度和高度，不带单位，而且这里获取的宽高和css设置无关，是元素在页面中实际的宽高。 也可以传递一个值设置高度和宽度，值的格式是字符串。 offset()获取元素在当前视窗的相对偏移，返回值是一个对象，即top和left，只对可见元素有效。 position()获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，也是返回一个对象并且又top和left。 scrollTop()、scrollLeft()获取元素的滚动条距顶端的距离和距左侧的距离。 可以给这两个方法指定一个参数，控制元素的滚动条滚动到指定位置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象三、作用域]]></title>
      <url>%2F2017%2F06%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[instanceof 运算符语法object instanceof fn 如果运算符后面的函数的prototype属性引用的对象出现在运算符面前对象的原型链上的话就返回true，否则返回false。 123456789101112131415function foo ()&#123;&#125;var f = new foo;console.log(f instanceof foo); // 返回true 判断f是不是foo函数的实例console.log(f instanceof Object); // 返回true f也是在Object的原型链上function fn ()&#123;&#125;foo.prototype = new fn;var ff = new foo;console.log(ff instanceof fn) // true 因为fn创建的对象就是foo.prototype,所以foo.prototype的原型就是fn.prototype。console.log(ff instanceof Object) // true//ff -&gt; foo.prototype -&gt; fn.prototype -&gt; Object.prototype -&gt; null 作用域链绘制作用域链的规则 将这个script标签的全局作用域定义为0级作用域链，将全局作用域上的所有数据（变量、对象、函数），绘制在这条链上 由于在词法作用域中，只有函数可以分割作用域，那么只要遇到函数就再引申出新的作用域链，级别为当前链级别+1，将数据绘制到新链上 重复步骤二，直到没有遇到函数为止 以下面的函数举例来绘制作用域链： 12345678910111213var n = 123;function f()&#123; var n = 12; function f1()&#123; var n = 1; function f2()&#123; var n = 0; &#125; function f3()&#123; var n = 0; &#125; &#125;&#125; 变量的搜索原则 当访问一个变量时，首先在当前变量所处的作用域上查找，如果找到就直接使用，并停止查找 如果没有找到就向上一级链(T-1)上去查找，如果找到就直接使用并停止查找 如果没有找到就继续向上一级链查找，直到0级链 如果没有找到就报错 如果访问的变量不存在，会搜索整个作用域链（不仅性能低，而且抛出异常） 在实际开发不推崇所有数据都写在全局上。尽量使用局部变量，推荐使用沙箱。 如果在开发中，所有js变量都写在全局上，会造成全局污染 同级别的链上的变量互不干扰 1234567891011function f (a)&#123; var a ; function a ()&#123; console.log(a); &#125; a(); a = 10; console.log(a);&#125;f(100);// 在这个题中 var a 不会覆盖a的参数100，但是function会改变，a=10这个赋值操作也会覆盖，因为都相当于赋值。 补充在函数执行时候，会创建一个执行的环境，这个环境包括：activeObject（活动对象）以及作用域链 activeObject存储的是所有在函数内部定义的变量，以及函数的形参; 会将变量名字以及形参名字作为该对象的属性来存储，比如有个变量a，那么就等于有了a这个属性，这时a的属性值就是100； 因为之前已经传了a这个参数，传了参数也相当于在函数内声明了a这个变量，也就是说此时在activeObject中已经有了a这个属性，所以这时在函数内声明a就不管用了，只有赋值才管用。只能改属性值但属性不会再创建。上述代码先将函数赋值给了a，又将100赋值给了a 查找对象也是在activeObject中查找，也就是查找里边的属性和属性值，没有的话就找上一级函数的activeObject。直到找到为止，没有找到就报错。 闭包定义 指一个函数有权去访问另一个函数内部的参数和变量。 创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。 应用闭包主要是为了设计私有的方法和变量。 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域，但是闭包的情况不同，不会被垃圾回收机制回收。 为了防止闭包导致的内存泄漏，用完闭包之后手工赋值为null，就会被回收。 闭包结构和闭包引用写在同一个函数里，出了函数就自动删除该缓存了。 缺点 闭包会造成函数内部的数据常驻内存，会增大内存使用量，从而引发内存泄漏问题。每创建一个闭包都会创建一个缓存数据，这样就会造成内存泄漏（内存满了后其他数据写不进去） 闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。 1234567891011121314151617function fn ()&#123; var n = Math.random(); function getN ()&#123; return n; // 这个作用域中没有n所以会向上寻找。 &#125; return getN; //这里是要返回整个getN函数，所以不加括号。&#125;var ff = fn(); // 这个ff就是闭包，通过它可以访问fn内部的数据。var nn = ff();var mm = ff(); // fn()实际上是getN这个函数体，那么ff()就是调用了getN这个函数，这样会返回n。console.log(nn);console.log(mm); // nn和mm的数是相同的console.log(nn === mm); //true,ff = null; // n被回收 优点 希望一个变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在 闭包的应用下面通过几个案例来了解闭包的优点： 统计某个构造函数创建多少个对象，变量可以长驻内存123456789101112131415161718192021222324252627282930//统计某个构造函数创建多少个对象function counter() &#123; var n = 0; return &#123; add:function()&#123; n+=1; &#125;, getCounts:function()&#123; return n; &#125; &#125;&#125;// 创建一个闭包,相当于初始化计时器，因为重新调用会让n=0.// 然后创建闭包时，n=0和return的对象会被缓存。// 那么为什么闭包环境能缓存数据呢：// 因为 var n = 0相当于n进入环境，在局部作用域创建了一个对象和n 最后把对象和n返回给外部作用域，相当于已出执行环境，通过全局变量就能找到返回的对象，通过返回的对象就能找到n，通过这个路径就能找到变量n，// 所以得出结论因为在函数内部有方法（函数）对其有引用，并且又将其返回到外部作用域上的一个变量接收。创建之后就缓存了，这时再通过这个变量访问闭包里的环境，那么只会访问该变量的缓存区域。var PresonCount = counter();function Preson()&#123; PresonCount.add();&#125;//用Preson这个构造函数创建对象，每创建一次都相当于调用了一次该构造函数。var p = new Preson()var p1 = new Preson()var p2 = new Preson()var p3 = new Preson()console.log(PresonCount.getCounts()); // 打印4 局部变量的累加,怎样做到变量a即是局部变量又可以累加12345678910111213141516171819202122232425262728293031323334// 1、全局变量var a = 1function abc()&#123; a++ console(a)&#125;abc() // 2abc() // 3// 可以累加但问题是a是全局变量 容易被污染// 2、局部变量function abc () &#123; var a = 1; a++; console(a);&#125;abc() // 2abc() // 2// 放到局部里又不能累加，因为每次执行函数都相当于把a重新声明// 3、局部变量的累加function outer () &#123; var a = 1; return function () &#123; a++; console.log(a); &#125;&#125;var y = outer();y() // 2y() // 3// 这样即实现了累加，又能把变量a藏起来。 模块化代码，减少全局变量的污染。a是局部变量，全局变量有a也没关系12345678910var abc = (function () &#123; var a = 1; return function()&#123; a++ console(a) &#125;&#125;()); // 函数在这里自调用一次，所以abc得到的是abc里返回的函数abc(); // 2abc(); // 3 函数的私有成员调用123456789101112131415161718var aaa = (function()&#123; var a = 1; function bbb()&#123; a++; console.log(a); &#125; function ccc()&#123; a++; console.log(a); &#125; return &#123; b:bbb, c:ccc // json格式，也就是返回一个对象。b是bbb的函数体 &#125;&#125;()); // 自调用一下，这样aaa就是函数体内的返回值，也就是那个json格式的对象aaa.b(); //2aaa.c(); //3 在循环中直接找到对应元素的索引123456789101112131415//这是以前的写法var lis = document.getElementsByTagName('li');for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function()&#123; console.log(i); // 由于进入函数时i已经循环完毕，所以i变为常量4&#125;// 用闭包的方式来写for (var i = 0; i &lt; lis.length; i++) &#123; (function(i)&#123; lis[i].onclick = function()&#123; console.log(i); &#125; &#125;(i)) //在这里调用一次，将i作为参数传进去，这时里边的i就不会是执行完之后的i值&#125; 内存泄漏问题由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素 12345678function closure()&#123; var oDiv = document.getElementById('oDiv'); //用完之后会一直待在内存中 var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); // 这里用oDiv导致内存泄漏 &#125;; oDiv = null; //最后应该将oDiv解除来避免内存泄漏&#125; 多闭包结构像上边的案例只需要一个n的值一个闭包就可以解决，而很多时候需要返回的变量大于1。 如下需要访问函数内部的多个变量n和m，就需要多个闭包。闭包的实质就是一个函数。 12345678910111213141516171819function foo()&#123; var n = 1,m = &#123;age:20&#125;; // n是变量，m是对象 function getN()&#123; return n; &#125; function getM()&#123; return m; &#125; return &#123;getM:getM,getN:getN&#125;; // :前的是属性名，:后的是属性值也就是函数体。&#125;var obj = foo(); // 这就是一次闭包obj.getM().age = 22;console.log(obj.getM().age); // 22console.log(obj.getN()); // 1var obj1 = foo(); // 这是第二次闭包，每闭包一次就是重新调用一次。不会被上次obj闭包调用并且更改属性值而改变函数本身的值，这和原型的不可变特性比较像。console.log(obj1.getM().age); // 20 对象的私有属性1234567891011121314151617181920212223242526272829303132333435363738394041// 用下面这个案例来说明构造函数的问题。function Preson (name,age) &#123; this.name = name; this.age = age;&#125;// 这是创建对象并且传参姓名var xiaohong = new Preson("小红",20)// 这时如果一不小心，就能随意将姓名改成小绿了。xiaohong.name = "小绿"// ---------------------------------------------------------------------------------------// 为了解决这个问题,可以用这种写法function Preson (name,age) &#123; return &#123; getName:function()&#123; return name; &#125;, getAge:function()&#123; return age; &#125; // name通常不能更改，但是age 可以改，给了这样一个接口就可以直接改了 setAge:function(val)&#123; age = val; &#125; &#125; &#125;// 还是创建对象并且传参// 这样就没法随意更改了，除非更改构造函数的函数。var xiaohong = new Preson("小红",20)xiaohong.serAge(19);xiaohong.getAge(); // 先传一个参数19，让age改为19.再调用一下getAge函数。就将年龄属性改为了19// 但是还有个问题，那就是通过下面的语句可以创建一个name的属性。这样也是不太好的xiaohong.name = "小绿"//通过下面这个属性可以解决。但是要写在上面创建属性的语句的前面Object.preventExtenions(xiaohong)xiaohong.name = "小绿" console.log(xiaohong.name) // 这时就返回undefined了。 用闭包来解决递归函数性能问题12345678910111213141516171819202122232425 // 利用闭包可以缓存数据的特性，改善递归性能 // 这个函数是为了缓存var fib = (function() &#123; var cache = []; // 这个函数是求fib的第n项值 return function(n) &#123; if (n &lt; 1) &#123; return undefined; &#125; // 1、看缓存里有没有 // 如果有，直接返回值 if (cache[n]) &#123; return cache[n] &#125; else // 如果没有重新计算 if (n === 1 || n === 2) &#123; cache[n] = 1; &#125; else &#123; cache[n] = arguments.callee(n - 1) + arguments.callee(n - 2); &#125; return cache[n]; &#125;&#125;())console.log(fib(10)); 垃圾回收机制定义GC(Garbage Collection)，专门负责一些无效的变量所占有的内存回收销毁。 原理垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但这个过程不是实时的，因为其开销比较大，所以垃圾回收器会照固定的时间间隔周期性的执行。 为什么闭包会造成内存常驻，并且让垃圾回收机制不能回收不再使用的变量（生命周期结束的变量），当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 123456789101112131415161718function fn1 () &#123; // body... var obj = &#123; name:'tom', age:20 &#125;&#125;function fn2 () &#123; // body... var obj = &#123; name:'tom', age:20 &#125; return obj&#125;var a = fn1();var b = fn2(); 当fn1被调用时，进入fn1环境，会开辟一块内存存放对象obj，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放， 而在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。那么问题出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：计数清除和引用清除。 引用计数法跟踪记录每个值被引用的次数，如果一个变量被另外一个变量引用了， 那么该变量的引用计数+1，如果同一个值又被赋值给另一个变量，则引用次数再+1。相反，当这个变量不再引用该变量时，这个变量的引用计数-1；GC会在一定时间间隔去查看每个变量的计数，如果为0就说明没有办法再访问这个值了就将其占用的内存回收。 123456function test () &#123; var a = &#123;&#125;; // a的引用次数为0 var b = a ; // a的引用次数+1，为1 var c = a ; // a的引用次数再+1， 为2 var b = &#123;&#125; // a的引用次数减1，为1&#125; 引用计数的缺点123456function test () &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125; 以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象已经离开环境，在标记清除方式下是没问题，但在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。只能手动让a和b=null才能被识别并回收 1234window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;;&#125;; 这段代码看起来没什么问题，但是obj引用了document.getElementById(“element”)而document.getElementById(“element”)的onclick方法会引用外部环境值中的变量，自然也包括obj。解决办法：自己手工解除循环引用。 12345window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;; obj = null;&#125;; 将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 标记清除法从当前文档的根部（window对象）找一条路径，如果能到达该变量，那么说明此变量有被其他变量引用，也就说明该变量不应该被回收掉，反之，应该被回收其所占的内存 当变量进入某个执行环境（例如，在函数中声明一个变量），那么给其标记为“进入环境”，此时不需要回收，但是如果上述执行环境执行完毕，便被销毁，那么该环境内的所有变量都被标记为“已出环境”，如果被标记为已出环境，就会被回收掉其占用的内存空间。 12345function test() &#123; var a = 10; // 被标记，进入环境 var b = 20; // 被标记，进入环境&#125;test() // 执行完毕后，a,b被标记离开环境，被回收。 垃圾回收器在运行时会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。目前IE,Firefox,Opera,Chrome,Safari的js实现使用的都是标记清除的垃圾回收策略，只不过时间间隔不相同。 沙箱变量不写在全局上，但又想达到写在全局的目的，就用沙箱 特点： 能分割作用域，不会污染全局（函数） 在分割后的作用域的内部的代码要自执行。（匿名函数） 1234567891011121314151617// 结构：(function()&#123; //代码块&#125;());// 经典的沙箱模式：var n = 2(function () &#123; // 这个n不会污染外部的n。所以这样能保证自己的代码安全执行（别人也污染不了我），也不会污染全局变量或其他作用域的变量 var n = 1; function foo () &#123; console.log(n); &#125; //window.fn 相当于设定了一个全局变量 window.fn = foo;&#125;())fn();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象二、函数]]></title>
      <url>%2F2017%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[创建方式声明式123function foo ()&#123; &#125; 表达式123var foo = function () &#123; &#125; 构造函数方式格式:new Function(arg1,arg2,......,argn,body) arg1,arg2,……,argn是可选的形参列表，表达为创建出来函数的形参列表，数据类型是字符串 body 字符串类型，表达为创建出来的函数的函数体部分 12345678var foo = new Function('val1','val2','return val1 + val2');console.log(foo(1,2)); // 3console.log(foo);/* function anonymous(val1,val2)&#123; return val1 + val2&#125;*/ 函数的原型链由于函数也可以通过构造函数来创建，那么函数也是对象，对象都具有proto属性，有了proto属性也就说明它也具有原型链。 1234567console.log(Object.constructor)console.log(Array.constructor)console.log(Date.constructor)console.log(RegExp.constructor)var foo = function()&#123;&#125;console.log(foo.constructor)// 打印的全都是 function Function() &#123; [native code] &#125; 以上内置函数和自定义函数的构造函数都是Function() 结论： 所有函数都是Function的实例 那么也就是说，所有的函数的构造函数为Function 所有函数的原型对象为Function.prototype 1234567console.log(foo.__proto__ === Function.prototype)console.log(Object.__proto__ === Function.prototype)console.log(Array.__proto__ === Function.prototype)console.log(RegExp.__proto__ === Function.prototype)console.log(Date.__proto__ === Function.prototype)console.log(Date.__proto__ === Function.prototype) // 打印的全都是true 以上结构都为true,也就是说这些内置函数和自定义函数都是通过Function这个构造函数创建的，他们的原型对象proto也就是Function.prototype 函数原型链的绘制绘制原型链时将函数（内置函数和自定义函数）成为函数对象，为了避免混淆，其他对象称为普通对象 Function.prototype 即是函数也是对象类型，而所有的原型对象都没有 prototype 属性，并且只有原型对象才有 constructor 属性 arguments对象arguments对象属性length：实参的个数 callee：返回正在执行的函数；应用在匿名函数递归调用 123456789function foo ()&#123; console.log(arguments);&#125;foo()/*[callee: function, Symbol(Symbol.iterator): function] callee:function foo() length:0*/ 函数相关属性caller：返回调用当前函数的函数 length：形参的个数 name：存的函数的名字 123456789function foo ()&#123; console.log(foo.caller); // function fn()&#123;foo()&#125; console.log(foo.length); // 0 console.log(foo.name); // foo&#125;(function fn ()&#123; foo()&#125;)() 函数重载在Javascript中函数是不能重载的，如果有函数重载Javascript会认为这是两个不同的函数，第二个会覆盖第一个，如下： 123456function foo () &#123;&#125;function foo (arguments) &#123; // 这个函数会覆盖上一个函数&#125; 但是Javascript可以模拟函数的重载，以前一直是这样写的，只是没有灌输重载这个概念。如下： 12345678910111213141516function foo() &#123; // 如果函数没有传递实参就打印false if (arguments.length == 0) &#123; return false; &#125; // 如果传递两个实参，就将两个实参拼接起来在打印出来 if (arguments.length &gt;= 2) &#123; var str = ""; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; str = str + arguments[i]; &#125; return str; &#125;&#125;//每个功能都是函数的重载 函数递归递归就是在函数体里自己调用自己 需要注意的是递归调用时要有递归调用的开始条件和结束条件，不然会死循环。 1234function fn()&#123; fn()&#125;//这就是递归函数，在内部调用自己，但是此时没有条件显示，所以会死循环 下面通过两个案例来解释递归函数的用法和条件限制 求等差数列的第n项的值步骤：得知道开始项的值，用v代替，每次增加的数字也就是差值，用d代替，要查找的第几项，用n代替 在这个例子中，n的值每次递减，递减到n===1的时候return v, 这就相当于整个函数有了值。也就是终止了再次进入调用函数本身。然后一步一步的把值返回。因为每次return都会+d,函数循环的次数也就是+d的次数。 每次函数调用自己都相当于进栈一次，循环调用了几次,栈里就有几个函数，当n===1时开始return，也就开始依次出栈。我们实际return的是v的值，每次出栈让v+d，然后根据d来确定是出几次栈，也就是做几次操作。 1234567891011121314function dengCha(v, d, n) &#123; // 过滤n小于1的无效值 if (n &lt; 1) &#123; return undefined; &#125; // 如果n为1，就直接返回V 此时不要继续递归,让函数从v的值开始每次+d，加的次数就是循环调用的次数。 else if(n === 1)&#123; return v; &#125; // 此时如果传入的n值&gt;1,就需要递归了 else &#123; return dengCha(v,d,n-1) + d &#125;&#125; 用一张图来表示函数执行过程： 斐波那契函数案例2：fib数列 1,1,2,3,5,8,13,21,34，…fib的规律：1: 12: 13: 24: 35: 5n: n-1+n-2 1234567891011// 这是一个匿名函数，用v来接收匿名函数的返回值var v = (function(n)&#123;if(n &lt; 1)&#123; return undefined;&#125;else if(n === 1 || n ===2)&#123; return 1;&#125;else &#123; return arguments.callee(n-1) + arguments.callee(n-2);&#125;&#125;(6))console.log(v); 用一张图来表示函数内部操作步骤 函数的四种调用模式普通函数执行这声明一个函数后，就直接调用。这种模式下this指向window对象 12345function foo () &#123; console.log(1); console.log(this === window);&#125;foo(); 方法调用模式通过一个对象来调用方法。把某一个函数当做对象的方法，this指向该方法的调用者 1234567var obj = &#123; sayHi:function()&#123; console.log("hello"); console.log(this === obj); // true &#125; &#125;obj.sayHi(); 构造函数模式配合new操作符来调用函数。this指向当前函数创建的对象 12345function fn (name) &#123; this.name = name; console.log(this); // fn &#123;name: "tom"&#125;&#125;var f = new fn("tom"); call/apply模式(上下文模式)this是用户动态指定的，指定call or apply方法的第一个参数。只有函数对象才有call和apply方法 fn.call(thisobj,arg1,arg2,...,argN) thisobj是fn在执行时this指向的对象，arg1…argN是fn在执行时传入的实参列表 fn.apply(thisobj,[fn的实参]) 和call不同点是最后是以数组的形式传递实参的 注意：在非严格模式下，如果thisobj赋值为null或者不传实参，此时this -&gt; window对象，就相当于普通函数执行模式。 12345678function fn (name) &#123; this.name = name;&#125;// 此时要借用构造函数的name属性var o = &#123;&#125;;fn.call(o,"Jack") // 调用fn并将fn中的this指向对象o,传参'Jack'console.log(o.name); // 打印了Jackfn.apply(o,['tim']) // 用apply方法达到相同作用 call/apply模式的应用数组的合并123456// 将arr2上的所有元素合并到arr1中var arr1 = [1,2,3];var arr2 = [4,5,6];// 下面两种方法都可以,只要用数组调用push方法并改变this指向就可以[].push.apply(arr1,arr2); // 原本push是改变[],现在是改变arr1Array.prototype.push.apply(arr1,arr2); // 原本push是改变Array,现在是改变arr1 借调方法（函数）借用构造函数1234567891011121314function parent(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 借用构造函数（和对象冒充作用类似）function child(name, age, gender, address) &#123; parent.call(this, name, age, gender); this.address = address; &#125;var c = new child('c',19,'女','地球');//这样c就借用了parent的属性并且传了值。 借调原生方法1234// 求data中的最大值var data = [67,89,190,23,10,100];var max = Math.max.apply(null,data); // this指向无所谓时可以填null// 想让括号里传的参数做怎样的操作就调用怎样的方法 获取内置对象类型12console.log(typeof new Array); // 打印objectconsole.log(typeof new Date); // 打印object 上面都是打印的object，这是弱类型的特点，但是我们有时需要打印array和date。 要实现这个功能要判断如果是内置对象，返回其类型名。如果是自定义对象，就返回object 123456function getType(obj)&#123; var t = Object.prototype.toString.call(obj).slice(8,-1); // 想让括号里传的参数做怎样的操作就调用怎样的方法 return t.toLowerCase();&#125;getType(new Array) // 返回array 将伪数组变成真数组12345// 借用上面的函数getTypevar doms = document.getElementsByTagName('div');var domArr = Array.prototype.slice.call(doms);console.log(getType(doms)); // 打印htmlcollection，伪数组console.log(getType(domArr)); // 打印array，真数组 数组去重123456789101112131415161718192021222324252627var arr = [1, 2, 2 , '1'];function unique(a) &#123; var ret = []; // 如果不支持indexOf方法 // 自己实现数组的indexOf方法，并添加到数组的原型对象上。 if(!ret.indexOf)&#123; Array.prototype.indexOf = function(val) &#123; // this指向的就是 indexOf的调用者 （数组对象） // 如果循环顺利执行完，就表示没有val值，返回-1； // 否则返回val在当前数组中的下标值。 for(var i = 0,l = this.length; i &lt; l; i++)&#123; if(this[i] === val) return i; &#125; return -1; &#125;; &#125; for(var i = 0,l = a.length;i &lt; l; i++)&#123; // 如果ret中不存在当前遍历到的元素，就添加到ret中 // 否则就不要添加 if( ret.indexOf(a[i]) === -1 )&#123; ret.push(a[i]); &#125; &#125; return ret;&#125;console.log(unique(arr)); // 打印[1,2,'1']]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象一、原型]]></title>
      <url>%2F2017%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%80%E3%80%81%E5%8E%9F%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[面向对象的概念面向对象是一种编程思想，核心是解决任何问题的时候首先试图去找到一个对象来帮助解决问题 在编程中，面向对象是调度者，从根本上是将面向过程封装，所以面向过程不可弃之不用。面向过程是执行者，执行顺序一般情况不能打乱。 面向对象的优点： 代码的灵活度高，代码执行顺序可以打乱。面向过程的代码不能打乱。 可维护性高，出现bug只需要在对象上去调试。 扩展性高，扩展时只需要维护局部模块。 面向对象的缺点： 可能会造成代码复杂度提高 代码可读性相对不好 js语言的特点 弱类型 多范式 基于对象的语言： 在Javascript中，一切的根源都是对象，并没有面向对象的一些概念，所以说是基于对象的语言，通常把构造函数当做一个模板，通过模板对建立对象 在其他面向对象的语言中，有类这个概念，Javascript用构造函数来模拟类，类和构造函数都是起到了模板的作用 不是面向对象的语言，只是用面对象向这种思想来模拟 基于原型的语言： 弱类型的语言基本都有原型存在，在面向对象的语言中，是类和类之间继承，而Javascript中只能让对象和对象之间继承， 原型的介绍原型的概念就是一个函数的prototype属性所引用的对象，原型是Javascript内置的，只要声明了一个函数，那么原型就自动存在了。 1234function fn ()&#123;&#125; // 这是一个构造函数console.log(fn.prototype) // 这个构造函数的原型console.log(fn.prototype.constructor) //这个构造函数// 所以构造函数和它的原型是能互相访问的。 原型的意义通过同一个构造函数创建出的所有对象都共享这个构造函数的原型，也就是说上述创建出的所有对象，可以直接访问到原型上的任何成员(属性和方法)。 123function fn ()&#123;&#125;var f = new fnf.constructor //就是fn这个构造函数，所以在fn这个构造函数里增加属性和方法对象f是可以直接访问的 原型的本质就是一个对象。在原型中创建方法就和给对象加方法一样。 原型的好处可以实现数据共享。用下面的代码列举问题来看一下原型的好处 123456789101112function Preson () &#123; this.talk = function()&#123; console.log("talk") &#125;&#125;var jim = new Preson;jim.talk();var john = new Preson;john.talk();// 问题：以上创建的两个对象访问了两次构造函数的talk()方法，这样对象每次访都是创建一个新的只属于这个对象的函数，每创建一个方法都是占用一块内存，而方法中的逻辑实际上都是一样的。这就相当于浪费了一块内存的位置// 解决方法：把建立在构造函数内的方法放在一个公共的地方，而这个公共的地方必须是该构造函数创建出来的，这样对象才能访问到，也就是该构造函数的原型上，实现数据共享fn.prototype.talk = function()&#123; console.log("talk") &#125; 获取原型的方式：函数：函数名.prototype 对象：对象.__proto__ 对象的组成部分：对象本身和它的原型组成 每个对象都有__proto__属性，也就是说每个对象都有原型，所以说Javascript是基于原型的语言， 对象的类型：就是该对象的构造函数的名字，Javascript虽然是弱类型语言，并不是没有类型，而是不注重类型的存在，体现在所有对象用typeof去检测都是object,所以也可以说所有对象的原型都是Object.prototype。 自定义一个数组对象的原型还是一个数组对象。他们的构造函数就是Array内置函数，包括Object,Array,Date都是内置函数。new后边的都是函数。 原型的归属：原型的属性：给原型一个归属，也就是什么什么的原型，通常说原型是站在函数的角度去认识原型，那么站在函数的角度来说，原型可以被称为该函数的原型属性。 原型的对象：是站在对象的角度来看原型，此时原型可称为是这个对象的原型对象。 这两者只是称谓不同，实际上都是同一个原型。 __proto__的兼容性处理：两个下划线的属性是有兼容性的，这不是W3C的标准属性，只是浏览器给提供的便利的东西。 123456789101112131415function getPrototype(obj) &#123; // 判断浏览器是否兼容__proto__ if (obj.__proto__) &#123; // 如果支持 return obj.__proto__; &#125; else &#123; // 如果不支持 // 获取该对象的构造函数 // 在通过此函数的prototype属性获取其原型对象 return obj.constructor.prototype; &#125;&#125;// 三元表达式写法function getPrototype(obj) &#123; return !!obj.__proto__ ? obj.__proto__ : obj.constructor.prototype;&#125; 标准构造函数写法主要就是要考虑哪些属性应该保留在构造函数内部，哪些属性提取出来放在原型上。 和对象息息相关的属性，这些属性都要写在构造函数内部。像姓名、年龄这些属性，是随着对象不同而改变的，所以没法放在原型上，而是要放到构造函数内部。 而那些为了共享的属性并且是每个对象都具有的属性，值也不会随对象变化而变化是确定的值。可以写在原型上。比如每个人都生活在地球上。 在一般情况下，方法被认为是所有对象所共有的。比如一般情况下人都会说话。所以所有方法都应该放在原型上。 原型的特性动态性给原型扩展成员会直接反应到已创建的对象身上。 12345678function A() &#123;&#125;A.prototype.color = 'black';var a = new A;var ad = new A;// 已经创建对象之后再去扩展原型上的属性，也会反应到对象身上A.prototype.makefood = function ()&#123; console.log('做饭')&#125;a.makefood(); // 做饭ad.makefood(); // 做饭 置换原型对象，不会反映到已创建出来的对象。但是会直接影响之后创建出来的对象。 1234567891011121314function A() &#123;&#125;A.prototype.color = 'black';var a = new A;A.prototype = &#123; constructor: A, makeup: function() &#123; console.log('我会化妆.'); &#125;&#125;;var na = new A;console.log(a.color); // black，因为a是置换对象之前创建的，所以它的原型就是A置换之前的原型。a.makeup(); // 报错，因为a是在置换原型之前创建的对象。na.makeup(); // 我会化妆.因为na是在置换原型之后创建的对象console.log(na.color); // undefined 因为这是在置换之前扩展的。扩展之后color属性就没了 唯一性由同一函数创建出来的所有对象，共享同一个原型对象。 123456789// 由同一个构造函数创建出的对象都共享同一个原型。function A() &#123;&#125;A.prototype.color = 'black';var a = new A;var ad = new A;// 这两个对象的原型对象全等，也就是同一个，并且共享原型对象的属性。console.log(a.__proto__ === ad.__proto__); // trueconsole.log(ad.color); // blackconsole.log(a.color); // black 不可变性对象是无法改变原型对象上的任何成员 123456789function A() &#123;&#125;A.prototype.color = 'black';var a = new A;// 更改a的color属性只能改变自身不会改变其他成员，并不会改变它的原型上的color属性，所以也不会改变ad的color。a.color = 'goldyellow';var ad = new A;console.log(ad.color); // blackconsole.log(A.prototype.color); // blackconsole.log(a.color); // goldyellow 继承性所有对象都继承自它的原型对象 123456function A() &#123;&#125;A.prototype.color = 'black';var a = new A; // a和na都是构造函数A创建出的对象，,都继承了A的原型var na = new A;console.log(a.color); // blackconsole.log(na.color); // black 面向对象的三大特性封装性把复杂的实现过程包装并隐藏起来，然后提供一个接口来给用户使用。 封装的好处 实现代码的重复利用。 实际使用中，只要出现重复代码逻辑就要考虑封装成一个函数，如果该函数和一些变量关联性比较大，那么就可以将函数封装成一个对象。 私密性（安全性），封装后用户看不到复杂的内部代码，不会误操作覆盖封装的变量。 封装时尽量保持函数或对象功能的单一性，便于日后维护。 继承性 概念：就是指一个对象有权去访问另一个对象的属性和方法，自己没有的属性和方法可以去访问另一个对象去获得，在js中只要让一个对象去访问另一个对象的属性和方法的话就必须要建立继承，任何对象都继承自己的原型对象。 在js中继承是对象与对象之间，其他面向对象语言(c,java,objectC等)都是类与类之间的继承。类在其他语言里就相当于模板的意义，在js中模板是构造函数，那么通过同一个构造函数（模板）创建出来的对象都继承函数里的属性和方法（ES6之前的方式） 在实际开发中两种继承方式可以组合起来应用。 集成的实现方式1：基于原型扩展原型：在原有的原型上进行相应的扩展，实现继承。 在对象的构造函数的原型上进行扩展，那么该对象也就继承了扩展的内容 12345function A () &#123;&#125; var a = new A;// a本身没有printA这个方法，但是它的模板创建了这个方法，所以a也继承了这个方法A.prototype.printA = function () &#123; console.log("扩展原型") &#125;a.printA(); 置换原型：将要被继承的对象，直接替换掉原有的原型。 假如b要继承a，就把b构造函数的原型直接替换成new a(传参) 12345678910111213141516171819// 首先创建了这个构造函数用parent代表 child要继承自parentfunction parent () &#123; this.name = 'tom';&#125;// 给这个模板的原型创建了一个方法parent.prototype.printC = function () &#123; console.log("c"); console.log(this.name);&#125;// 又创建了一个构造函数。child代表继承自parent。function child () &#123;&#125;// 让child的原型 = 模板parent创建的对象。parent函数的name和printC也继承给了child，同时传参数也不影响parent函数child.prototype = new parent();//创建对象c,因为child的原型已经和函数parent一样，所以用c可以直接访问name和printC了var c = new child;c.printC(); // 打印cconsole.log(c.name); // 打印tom 集成的实现方式2： 拷贝继承拷贝继承：将别的对象上的所有成员拷贝一份添加到的当前对象本身，拷贝继承没有任何对原型的操作。 123456789101112131415161718192021// 创建一个对象parentvar parent = &#123; print: function() &#123; console.log('i am parent'); &#125;, name: 'parent'&#125;// 创建一个对象childvar child = &#123; name: 'child'&#125;// child没有print方法，那么可以拷贝一份过来// 拷贝步骤：// 1、遍历parent。for (var k in parent) &#123; //这样就将parent的所有属性都拷贝了过来,k就是name和print，child依次更改和创建了这两个属性，并且将parent对应的属性值赋值给child. child[k] = parent[k];&#125;child.print(); // 打印i am parent// 拷贝继承概念部分结束 下面是一个问题，就是代码重复的问题，当child还要继承parent1的时候就要再写一遍遍历，造成了代码重复 12345678910var parent1 = &#123; print1:function()&#123; console.log('print1'); &#125;&#125;for (var k in parent1) &#123; child[k] = parent1[k];&#125;child.print1(); // 打印print1，但是如果要拷贝多个parent那么代码会重复 所以可以封装成一个函数，封装为child对象的一个方法extend，谁调用extend方法就是给谁实现继承 123456789101112131415161718192021222324252627282930313233343536// 新建一个child对象var child = &#123;&#125;// 给child创建一个名为extend方法，里边的函数就是封装的拷贝方法child.extend = function(parent) &#123; var k; // parent是传的参数 for (k in parent) &#123; this[k] = parent[k] &#125;&#125;// 第一步封装完成，但是问题是只能往里传一个对象// 实现继承多个对象child.extend = function() &#123; // arguments是传入参数的数据的数组，在这里也就是传入的对象数量 var args = arguments; //遍历atguments上的所有对象 //依次将遍历的每个对象的成员添加到child for (var i = 0, l = args.length; i &lt; l; i++) &#123; //判断传入的是否为对象 if (typeof obj === 'object') &#123; for (var k in args[i]) &#123; this[k] = args[i][k] &#125; &#125; &#125;&#125;// 调用这个对象的拷贝方法并且传一个参数，参数是对象child.extend(&#123; name: 'child', print: function() &#123; console.log(this.name); &#125;&#125;)child.print(); // 打印child 集成的实现方式3：对象冒充对象冒充：在一个构造函数中可以动态的添加一个parent方法指向，用已有的构造函数，然后调用parent方法去实例化当前对象的一部分成员（或全部成员），这种方式被称为对象冒充。 12345678910111213function parent (name,age,gender) &#123; this.name = name; this.age = age; this.gender = gender&#125;function child(name,age,gender) &#123; this.parent = parent; this.parent(name,age,gender); delete this.parent; // child通过这个属性冒充parent,通过这个构造函数创建对象也会有parent里的成员 // 注意：child利用完parent属性后记得删除&#125; 集成的实现方式4：借调函数12345678910111213function parent (name,age,gender) &#123; // body... this.name = name; this.age = age; this.gender = gender;&#125;// 和冒充类似，这是用call方法实现的function child (name,age,gender,address) &#123; // body... parent.call(this,name,age,gender); this.address = address;&#125;var c= new child('tom',28,'男','yueqiu'); 集成的实现方式5：Object.create(parent) （置换原型的原理）123456789101112131415161718192021222324// 方法的介绍 Object.create(parent); 返回一个对象并继承自传入参数parent// 用基于原型：置换原型的方式来继承var obj = &#123; name:'tom', print:function()&#123; console.log(this.name); &#125;&#125;// 将obj当做参数传进来,newObj就继承了obj// 声明一个新变量来接收继承自parent的对象var newObj = Object.create(obj)newObj.print();// 下面是Object.create解决兼容性问题if(!Object.create)&#123; Object.create = function(parent)&#123; function F () &#123; F.prototype = parent; return new F; &#125; &#125;&#125; 多态性体现在继承中的概念。比如某对象A继承自某对象B，B对象的某个方法在A中并不适用。然后A对象重写该方法，那么这个就是多态性。 具体体现在子对象和父对象之间，在父对象中的同一方法在各个子对象中的实现行为不同。 原型链原型链是从当前对象到Object.prototype之间，存在一条层次分明，逐级递进的体现继承关系的链式结构 所有对象都有__proto__属性 原生对象继承自Object.prototype,具有constructor属性；如果置换了原型，记得要添加constructor属性 函数具有prototype属性 123456789101112131415161718192021222324var o = &#123;&#125;; //Object对象，对象都有__proto__属性// 对象的__proto__是它的原型对象console.log(o.__proto__)// 对象的constructor是它的数据类型Objectconsole.log(o.constructor)// 对象的原型就是Object.prototypeconsole.log(Object.prototype === o.__proto_);console.log(o.__proto__.__proto__); // 也就是console.log(Object.prototype.__proto__);// 返回null// 所以 o -&gt; Object.prototype -&gt; null// Object对象的继承层次：// obj -&gt; Object.prototype -&gt; null// 以数组为例var arr = [];console.log(arr.constructor === Array); // trueconsole.log(arr.__proto__ === Array.prototype); // true// arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null 用一张图来表示原型链：这是最简单最基础的原型链 用两个例子来深入体会原型链： 12function parent() &#123;&#125;var p = new parent; 1234function A() &#123;&#125;function B() &#123;&#125;B.prototype = new A; // 这时B.prototype的构造函数就是A()，var b = new B; 属性搜索原则当访问对象成员时，首先在当前对象上查找，如果找到就直接返回（调用）并且停止查找 如果没有找到就向其原型对象上去查找，如果找到就直接返回（调用） 如果还是没有找到，就继续向原型对象的原型对象上查找，直到Object.prototype。 如果找到了，就直接返回（调用），并停止查找，否则返回undefined（报错：xxx is not a function） 注意： 如果访问对象的某个属性不存在的话，会搜索整个原型链，有可能会导致js性能降低。 在实际开发中尽量保持一个适度的原型链长度。 兼顾js性能以及代码的可读性和扩展性 Object.prototype介绍constructor就是自己的构造函数（function Object( ) { [native code] }） hasOwnProperty()hasOwnProperty() 判断指定的属性是否为当前对象自己的（自己的就是指不是继承过来的） 构造函数里的就是对象自己的，原型上的就是继承的。 格式：obj.hasOwnProperty(‘属性名’) 123var o = &#123;name:'tom'&#125;;console.log(o.hasOwnProperty('name')); //返回trueconsole.log(o.hasOwnProperty('toString')); //返回false isPrototypeOf()isPrototypeOf() 用来判断当前对象是否是指定对象的原型对象 格式：obj1.isPrototypeOf(obj2) 1234567891011121314// 只要对象A出现在B对象的原型链上就返回true,否则返回falsefunction A () &#123;&#125;function B () &#123;&#125; var a = new A; var b = new B;//现在没有任何关系 console.log(a.isPrototypeOf(b)); //返回falsevar a = new AB.prototype = a;var b = new B// b -&gt; a -&gt; a.prototype -&gt; Object.prototype -&gt; null propertyIsEnumerable()propertyIsEnumerable() 判断对象指定的属性是否可枚举，并且指定的属性必须是自己的，两者都满足才能返回 true 123456789101112131415161718function foo(name, age, address) &#123; // body... this.name = name; this.age = age; this.address = address;&#125; foo.prototype.talk = function()&#123; console.log(this.name);&#125;console.log(f.propertyIsEnumerable('name')); // 返回trueconsole.log(f.propertyIsEnumerable('talk')); // 返回false// 可枚举就是用 for in 遍历出来的属性都是可枚举的。内置的属性(__proto__)都是不可枚举的var obj = &#123; name:'tom'; age:18;&#125; 构造函数的执行过程12345678// 构造函数的执行过程function Fn (name,age) &#123; this.name = name; this.age = age;&#125;var Fn = new Fn(); 创建了一个空对象 将obj赋值给this (让this指向上面创建空对象,也就是Fn) 将当前作用域交给this 执行构造函数内部的代码 将this返回 new的时候函数内部会默认return this]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》二、jQuery的选择器]]></title>
      <url>%2F2017%2F06%2F13%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%BA%8C%E3%80%81jQuery%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基本选择器 选择器 描述 返回 示例 #id 根据给定的id匹配一个元素 单个元素 $(&#39;#test&#39;)选取id为test的元素 .class 根据给定的类名匹配元素 集合元素 $(&#39;.test&#39;)选取所有class为test的元素 element 根据给定的元素名匹配元素 集合元素 $(&#39;p&#39;)选取所有&lt;p&gt;元素 * 匹配所有元素 集合元素 $(&#39;*&#39;)选取所有元素 selector1,selector2…` 将每个选择器匹配到的元素合并后一起返回 集合元素 $(&#39;div,span,p.myClass&#39;)选取所有&lt;div&gt;``&lt;span&gt;和拥有class为myClass的&lt;p&gt;标签的一组元素 层次选择器层次选择器用来获取后代元素、子元素、相邻元素和同级元素等。 选择器 描述 返回 示例 $(‘ancestor descendant’) 选取ancestor元素里所有的descendant(后代)元素 集合元素 $(&#39;div span&#39;)选取&lt;div&gt;里的所有的&lt;span&gt;元素 $(‘parent&gt;child’) 选取parent元素下的child(子)元素 集合元素 $(&#39;div&gt;span&#39;)选取&lt;div&gt;元素下元素名是&lt;span&gt;的子元素 $(‘prev + next’) 选取紧接在prev元素后的next元素 单个元素 $(&#39;.one + div&#39;)选取class为one的下一个&lt;div&gt;同级元素，可以用$(&#39;.one&#39;).next(&#39;div&#39;)代替 $(‘prev~siblings’) 选取prev元素之后的所有siblings元素 集合元素 $(&#39;#two~div&#39;)选取id为two的元素后面的所有&lt;div&gt;同级元素，可以用$(&#39;#two&#39;).nextAll(&#39;div&#39;)代替 过滤选择器通过特定的过滤规则来选定元素。 基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(&#39;div:first&#39;)选取所有&lt;div&gt;元素中第1个&lt;div&gt;元素 :last 选取最后一个元素 单个元素 $(&#39;div:last&#39;)选取所有&lt;div&gt;元素中的最后一个&lt;div&gt;元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(&#39;input:not(.myClass)&#39;)选取class不是myClass的&lt;input&gt;元素 :even 选取索引是偶数的所有元素 集合元素 $(&#39;input:even&#39;)选取索引是偶数的&lt;input&gt;元素 :odd 选取索引是奇数的所有元素 集合元素 $(&#39;input:odd&#39;)选取索引是奇数的&lt;input&gt;元素 :eq(index) 选取索引等于index的元素 单个元素 $(&#39;input:eq(1)&#39;)选取索引等于1的&lt;input&gt;元素 :gt(index) 选取索引大于index的元素(不包括index本身) 集合元素 $(&#39;input:gt(1)&#39;)选取索引大于1的&lt;input&gt;元素 :lt(index) 选取索引小于index的元素(不包括index本身) 集合元素 $(&#39;input:lt(1)&#39;)选取索引小于1的&lt;input&gt;元素 :header 选取所有标题元素 集合元素 $(&#39;:header&#39;)选取网页中所有标题元素 :animated 选取当前正在执行动画的所有元素 集合元素 $(&#39;div:animated&#39;)选取正在执行动画的&lt;div&gt;元素 :focus 选区当前获取焦点的元素 集合元素 $(&#39;:focus&#39;)选取当前获取焦点的元素 内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为’text’的元素 集合元素 $(&#39;div:contains(&#39;我&#39;)&#39;)选取含有文本’我’的&lt;div&gt;元素 :empty 选取不包含子元素或者文本的空元素 集合元素 $(&#39;div:empty&#39;)选取不包含子元素(包含文本元素)的&lt;div&gt;空元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $(&#39;div:has(p)&#39;)选取还有&lt;p&gt;元素的&lt;div&gt;元素 :parent 选取含有子元素或者文本的元素 集合元素 $(div:parent)选取拥有子元素(包含文本元素)的&lt;div&gt;元素 可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见的元素 集合元素 $(&#39;:hidden&#39;)选取所有不可见的元素，包括visibility:hidden、display:none、type=&#39;hidden&#39; :visible 选取所有可见的元素 集合元素 $(&#39;div:visible&#39;)选取所有可见的&lt;div&gt;元素 属性过滤选择器 选择器 描述 返回 示例 [attribute] 选取拥有此属性的元素 集合元素 $(&#39;div[id]&#39;)选取拥有属性id的&lt;div&gt;元素 [attribute=value] 选取属性的值为value的元素 集合元素 $(&#39;div[title=test]&#39;)选择属性title为’test’的&lt;div&gt;元素 [attribute!=value] 选取属性的值不等于value的元素 集合元素 $(&#39;div[title!=test]&#39;)选取属性title不等于’test’的&lt;div&gt;元素(没有title属性的元素也会被选取) [attribute^=value] 选取属性的值以value开始的元素 集合元素 $(&#39;div[title^=test]&#39;)选取属性title以’test’开始的&lt;div&gt;元素 [attribute$=value] 选取属性的值以value结束的元素 集合元素 $(&#39;div[title$=test]&#39;)选取属性title以’test’结束的&lt;div&gt;元素 [attribute*=value] 选取属性的值含有value的元素 集合元素 $(&#39;div[title*=test]&#39;) 选取属性title含有’test’的&lt;div&gt;元素 [attribute¦=value] 选取属性等于给定字符串或以该字符串为前缀(该字符串后跟一个连字符’-‘的元素) 集合元素 $(div[title¦=’en’])选取title属性等于en或以en为前缀的&lt;div&gt;元素 [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $(div[title~=&#39;uk&#39;])选取属性title用空格分隔的值中包含字符uk的元素 [attributeN] 用属性选择器合并成一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围 集合元素 $(&#39;div[id][title$=&#39;test&#39;]&#39;)选取拥有属性id，并且属性title以’test’结束的&lt;div&gt;元素 子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素(index从1算起) 集合元素 :eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的，而:eq(index)是从0算起的 :first-child 选取每个父元素的第1个子元素 集合元素 :first只返回单个元素，而:first-child选择符将为每个父元素匹配第1个子元素。例如$(&#39;ul li:first-child&#39;);选取每个&lt;ul&gt;中第1个&lt;li&gt;元素 :last-child 选取每个父元素的最后一个子元素 集合元素 区别和上面相同，$(&#39;ul li:last-child&#39;);选取每个&lt;ul&gt;中最后一个&lt;li&gt;元素 :only-child 如果某个元素是它父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(ul li:only-child)在&lt;ul&gt;中选取是惟一子元素的&lt;li&gt;元素 表单属性过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(&#39;#form1 :enabled&#39;);选取id为form1的表单内所有可用的元素 :disabled 选取所有不可用元素 集合元素 $(&#39;#form1 :disabled&#39;);选取id为form2的表单内的所有不可用的元素 :checked 选取所有被选中的元素 集合元素 $(&#39;input:checked&#39;);选取所有被选中的&lt;input&gt;元素 :selected 选取所有被选中的选项元素 集合元素 $(select option:selected);选取所有被选中的选项元素 表单选择器为了使用户能够更加灵活的操作表单，可以使用表单选择器，更加方便的获取到表单的某个类型的元素。 选择器 描述 返回 示例 :input 选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;button&gt;元素 集合元素 $(&#39;:input&#39;)选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;button&gt;元素 :text 选取所有的单行文本框 集合元素 $(&#39;:text&#39;)选取所有的单行文本框 :password 选取所有的密码框 集合元素 $(&#39;:password&#39;)选取所有的密码框 :radio 选取所有的单选框 集合元素 $(&#39;:radio&#39;)选取所有的单选框 :checkbox 选取素有的多选框 集合元素 $(&#39;:checkbox&#39;)选取素有的多选框 :submit 选取所有的提交按钮 集合元素 $(&#39;:submit&#39;)选取所有的提交按钮 :image 选取所有的图像按钮 集合元素 $(&#39;:image&#39;)选取所有的图像按钮 :reset 选取所有的重置按钮 集合元素 $(&#39;:reset&#39;)选取所有的重置按钮 :button 选取所有的按钮 集合元素 $(&#39;:button&#39;)选取所有的按钮 :file 选取所有的上传域 集合元素 $(&#39;:file&#39;)选取所有的上传域 :hidden 选取所有不可见元素 集合元素 $(&#39;:hidden&#39;)选取所有不可见元素 使用选择器的注意事项含有’·’、’#’、’(‘或’]’等特殊字符碰到id或者class属性值带有这些特殊字符的需要转译之后才能使用，不能直接写 $(&#39;#box#b&#39;)这种不经过转译的写法是错误的，应该写为$(&#39;#box\\#b&#39;)，通过\\进行转译。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》一、认识jQuery]]></title>
      <url>%2F2017%2F06%2F13%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86jQuery%2F</url>
      <content type="text"><![CDATA[window.onload和$(document).ready()window.onload：必须等网页中所有的内容加载完毕后(包括图片)才能执行，不能同时编写多个。 $(document.ready())：网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完，可以同时编写多个，可以简写为$(function(){}) jQuery对象和DOM对象的转换jQuery转为DOM对象有两种方法，即[index]和get(index)。 123var box = $('#box')[0];var box1 = $('#box1').get(0); DOM转为jQuery对象,只需要用$()把DOM对象包装起来,$()就是一个jQuery对象的制造工厂。 123var box = document.getElementById('box');var $box = $(box); $快捷方式的更改$是jQuery的快捷方式，为防止冲突，也可以自定义这个快捷方式。 交给其他js库假如jQuery库在其他库之后引入，在其他库和jQuery库加载完成后就可以使用jQuery.noConflict()将变量$的控制权交给其他js库，如果先引入jQuery就不需要jQuery.noConflict()方法，直接写$即可。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery.noConflict(); // 将变量$的控制权移交给prototype.js jQuery(function()&#123; // 使用jQuery jQuery('p').click(function()&#123; alert( jQuery(this).text() ) &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 防止$冲突第一种方法：想确保jQuery不会与其他库冲突，可以自定义一个快捷方式。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; var $j = jQuery.noConflict(); // 自定义一个快捷方式 $j(function()&#123; // 利用刚自定义的快捷方式使用jQuery $j('p').click(function()&#123; alert($j(this).text()); &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 第二种方法：如果不想自定义名称，同时又想避免冲突可以这样。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery.noConflict(); // 将变量$的控制权移交给prototype.js jQuery(function($)&#123; // 将$通过参数传入 $('p').click(function()&#123; alert($(this).text()); &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 判断是否获取到了某元素在原生javascript中通过这样来判断页面中是否有这个元素 123if(document.getElementById('tt'))&#123; document.getElementById('tt').style.color = 'red';&#125; 在jQuery中因为$()获取的是一个对象，所以不能直接判断这个对象是否存在 123if($('#tt'))&#123; // 这里将永远判断为true，因为jQuery对象一直存在&#125; 应该这样判断 123if($('#tt').length &gt; 0)&#123; &#125; 或者 123if($('#tt')[0])&#123; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css的ie6兼容问题]]></title>
      <url>%2F2017%2F06%2F13%2Fcss%E7%9A%84ie6%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[png图片的兼容性png的图片在ie6下默认不是透明的，所以需要处理一下。 使用DD_belatedPNG插件，需要在script中调用，DD_belatedPNG.fix(&quot;selector1,selector2&quot;)，缺点是不支持body元素。 第二种方法是使用ie6的滤镜属性，这个属性body也可以使用。_background-image:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;XX.png&quot;,sizingMethod=&quot;crop&quot;);，因为只需要ie6支持所以用了hack。 float在ie6的兼容问题有如下结构 123456789101112131415161718192021222324252627282930&lt;style&gt;.box &#123; width: 400px; border: 1px solid #000000; overflow: hidden;&#125;.left &#123; float: left; background-color: red;&#125;.right &#123; float: right; background-color: blue;&#125;h2 &#123; height: 30px;&#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="left"&gt; &lt;h2&gt;左边&lt;/h2&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;h2&gt;右边&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt; 将.left和.right分别左右浮动并设置颜色、h2元素设置高度应该是如下效果。 但在ie6下会显示成这样， ie6下在浮动的元素下的元素h2设置高度，会独占整行，因为h2是块级元素，但我希望的是浮动元素被内容撑开。这时只要设置样式h2{float:left}就可以解决这个问题。 另外假设父元素的宽度够长，如果子元素中第一个元素浮动并且宽度为200px，那么第二个元素即是设置了margin-left:200px;那么会有也间隙，所以既然要并排显示那么就都设置浮动，不要一个浮一个不浮。 ie6浏览器子元素超出宽度问题在标准浏览器子元素比父元素宽高大时，会超出父元素，但不会改变父元素大小，但是在ie6下回直接撑大父元素，会导致整个布局乱掉，所以ie6下布局一定要注意子元素的尺寸问题。 块级元素嵌套规则p标签、h标签、td标签是不能嵌套块级元素的，如果在ie6下嵌套了还会莫名多生成一个块级元素占用空间，布局也会乱掉。 margin的兼容性问题margin-top的传递问题在子元素中设置margin-top那么父元素也会掉下来。 给父元素设置边框。 给父元素设置overflow:hidden。(标准浏览器、ie7及以上浏览器) 给父元素设置zoom:1;(ie7及以下浏览器) 在ie7及以下浏览器设置父盒子的宽和高也可以解决。 上下margin的叠压问题同级元素如果有上下margin的设置，那么上下两个元素会导致上面元素的下margin和下面元素的上margin重叠。 解决方法是不要设置margin,而是设置某一个方向的margin，比如margin-top、margin-bottom。 inline-block的兼容性问题ie7及以下浏览器不识别display:inline-block属性。所以在ie7及以下浏览器要用行内块需要设置*display:inline;*zoom:1;。*号是只让ie7、ie6识别。 ie6的最小高度问题在ie6浏览器下最小高度是19px；如果要设置小于19px的元素，那么首先要设置具体高度，然后要加*overflow:hidden属性。剪裁掉多出的部分。 ie6双边距的问题当元素浮动后，再设置margin-left那么就会产生双倍边距。解决办法是给浮动元素设置*display:inline。 ie6浏览器li的间隙ie6浏览器下li元素内部的子元素如果浮动，li之间就会产生4px的间隙。解决方法是给li元素增加*vertical-align:top;属性。 ie6文字溢出的bugie6下两个浮动元素中间有注释或者内联元素，并且两个浮动元素宽度相加和父级宽度相差在6px以内，就会导致浮动元素内的文字溢出一个重复的，并且每多一个内联元素或者注释就会多出一个重复文字。 让两个浮动元素之间没有内联元素和注释。 如果只有一个浮动元素设置了宽度另一个没有宽，那么比父盒子的宽小3px即可。 如果两个浮动元素都设置了宽，那么两个元素加起来要比父盒子的宽小6px。 ie6相对定位于overflow:hidden的问题ie6下当子元素比父元素大时，并且子元素设置了相对定位，那么父盒子即使使用overflow:hidden也无法剪裁子元素。 只有将父盒子也设置为相对定位才可以剪裁。 ie6绝对定位奇数问题当父元素设置相对或者绝对定位并且宽高为奇数，那么在ie6中子元素设置绝对定位即使left/right和top/bottom设置为0，也会有1px的距离。 所以ie6下要使用定位父盒子必须是偶数。 ie6浮动元素和绝对定位的问题父元素设置相对定位，如果子元素设置浮动撑满整个父元素的空间，那么此时再有一个同级子元素设置绝对定位则这个元素会消失。 造成这个原因的是同级的问题，那么再绝对定位元素外面套一层元素就可解决。 也可以让浮动的子元素宽加起来比父元素少6px，那么绝对定位的元素也可以显示出来。 ie6下input间隙问题input作为子元素时，父盒子不设高度，那么input设置高度后撑开父盒子会造成上下分别1px的间隙，漏出父盒子。 解决方法是设置input左浮动]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript（正则表达式）]]></title>
      <url>%2F2017%2F06%2F05%2Fjavascript%EF%BC%88%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%2F</url>
      <content type="text"><![CDATA[正则的意思就是让计算机能读懂我们想要的格式和规则。 初始化一个正则表达式 1var re = new RegExp('a'); 简单的写法，推荐这种写法，但是如果写在函数里正则需要传参的话就必须用new的写法 1var re = /a/; 正则表达式是区分大小写的，如果不想区分在最后加i。 1var re = new RegExp('b','i'); 或者 1var re = /b/i; 正则默认匹配成功就会结束，不会继续匹配，如果要全部查找需要全局匹配，在最后加g 1var re = new RegExp('b','g'); 或者 1var re = /b/g; 正则的方法test正则去匹配字符串，如果匹配成功就返回true，如果匹配失败就返回false。 写法：正则.test(字符串)。 12345var str = 'abcdef';var re = /b/;alert(re.test(str); //打印true search正则去匹配字符串，如果匹配成功，就返回匹配成功的索引，如果匹配失败就返回-1。 search的写法：字符串.search(正则) 123456789var str = 'abcefg';var re = /bcd/; var re1 = /B/; alert(str.search(re)) // 打印1，返回匹配到的首字符的索引alert(str.search(re1)) // 打印-1 match正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null。 match的写法：字符串.match(正则) 123456789101112131415var str = '123abc456efg789';var re = /\d\d/g; var re1 = /\d+/g; alert(str.match(re)) // 打印数组['12','45','78']alert(str.match(re1)) // 打印数组['123','456','789']var str1 = 'abc';var re2 = /(a)(b)(c)/;alert(str.match(re1)) // 打印['abc','a','b','c'],第一项是匹配的整体结果，后面依次是子项，不能加g replace正则去匹配字符串，匹配成功的字符去替换新的字符串。 replace的写法：字符串.replace(正则,新的字符串) 12345678910111213141516var str = 'aaa';var re = /a/;str = str.replace(re,'b');alert(str) // 打印baastr = str.replace(re,function(str)&#123; alert(str) // 函数的第一个参数就是匹配成功的字符a var result = 'b' return result; // return要替换的字符 &#125;) 转义字符比较常用的几个转译符 \. 真正的点，原本.是表示任意字符 \n 换行 \s 空格 \S 非空格 \d 数字 \D 非数字 \w 字符 ( 字符、数字、下划线 ) \W 非字符 \b 独立的部分(起始、结束、空格)，也就是要匹配是否在开头、是否在结尾、是否匹配到了空格。 \B 非独立的部分。 重复的子项\1代表重复的第一个子项、\2代表重复的第二个子项，可以用于匹配字符中一堆重复的内容。 12345var str = 'abca';var re = /(a)(b)(c)\1/;alert(re.test(str)) // 打印true，\1代表重复第一个子项，也就是a 量词不确定的字符的个数用量词来表示。 {} 字符出现的范围，{4,7}就是至少出现4次、最多出现7次，{4,}是最少出现4次，{4}正好出现4次， + 是至少出现一次，也可以写成{1,} ? 是0次或者1次，也可以写成{0,1} * 至少出现0次，也可以写成{0,} | 或的意思，和||相同 () 分组操作和匹配子项，分组操作和数学中的作用相同。 分组12345678910111213var str = '2017-6-3';var re = /\d-+/g;var re1 = /(\d-)+/g;str.replace(re,function(str)&#123; alert(str) // 打印'7-'和'6-'&#125;)str.replace(re1,function(str)&#123; alert(str) // 打印'7-6-'&#125;) 匹配子项小括号里匹配的内容就是一个子项，有两个小括号就是有两个子项。 1234567891011var str = '2016-6-4';var re - /(\d+)(-)/g;str.replace(re,function(str1,str2,str3)&#123; alert(str1); // 第一个参数是整个匹配的内容，'2016-','6-' alert(str2); // 在str1的匹配结果中，第一个子项(括号)匹配到的内容 '2016','6' alert(str3); // 在str1的匹配结果中，第二个子项(括号)匹配到的内容 '-','-'&#125;) 字符类就是一组相似的元素或字符，用[]来表示，[]中都是或的关系并且只代表一个字符。如果要代表多位可以在[]使用量词。 123456789var str = 'abc';var re = /a[ade]c/;alert(re.test(str)) // 打印true，中括号里匹配a或d或e都可以，但只能是一个字符var str1 = 'abdc';alert(re.test(str1)) // 打印false，只能匹配一个字符，也就是只占一个字符的位置，str1的第三位不是c所以是false 排除用^表示，写在[]里边是排除的意思。 12345var str = 'abc';var re = /a[^ade]c/;alert(re.test(str)) // 打印false，这里其实和非操作比较像，是指匹配的元素不能是a||d||e。 范围是要匹配的字符的范围。比如a-z、0-9、A-Z。 12345var str = 'abc';var re = /a[a-z]c/;alert(re.test(str)) // 打印true，只要第二个字符是a-z的范围内都可以匹配到 边界^ 正则最开始的位置。 $ 正则最后结束的位置。 常用的表单验证匹配中文：[\u4e00-\u9fa5] 行首位空格：^\s*|\s*$ Email：^\w+@[a-z0-9]+(\.[a-z]+){1,3}$ 网址：[a-zA-Z]+://[^\s]* QQ号：[1-9][0-9]{4,9} 邮政编码：[1-9]\d{5} 身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》六、充实文档内容]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%85%AD%E3%80%81%E5%85%85%E5%AE%9E%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[这一章将继续在实践中应用动态创建标记 1、不应该做什么从技术上讲，可以把任何内容动态添加到网页上，但重要的内容不要这么做，因为这样一来，javascript就没有任何空间去平稳退化，如果缺乏javascript的支持，用户会永远看不到重要的内容，而且各大搜索引擎也不支持javascript。 渐进增强和平稳退化两项原则要牢记在心，在这里再次总结一下这两项重要的原则。 渐进增强应该从最核心的部分，也就是从内容开始，应该根据内容使用标记实现良好的结构，然后再逐步加强这些内容，这些增强工作既可以是通过css改进呈现效果，也可以是通过DOM添加各种行为，如果你正在使用DOM添加核心内容，那么添加的时机未免太迟，核心内容应在刚开始写文档时就成为文档的组成部分。 平稳退化渐进增强的实现必然支持平稳退化，如果你按照渐进增强的原则去充实内容，你为文档添加的样式和行为自然就支持平稳退化。那些缺乏必要的css和DOM支持的访问者仍可以访问到你的核心内容，如果用javascript去添加这些内容，它就没法支持平稳退化，不支持javascript就看不到内容。 2、内容和往常一样，任何网页都以内容为出发点，现在拿下面这段内容作为出发点。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;解释文档DOM&lt;/title&gt; &lt;style&gt; body &#123; font-family:'Helvetica','Arial',sans-serif; font-size: 10pt; &#125; abbr &#123; text-decoration: none; border: 0; font-style: normal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;什么是DOM&lt;/h1&gt; &lt;p&gt;&lt;abbr title="万维网联盟"&gt;W3C&lt;/abbr&gt;将&lt;abbr title="文档对象模型"&gt;DOM&lt;/abbr&gt;定义为:&lt;/p&gt; &lt;blockquote cite="http://www.w3.org/DOM/"&gt; &lt;p&gt;一个平台和语言中立的接口，将允许程序和脚本动态访问和更新的内容，结构和风格的文档。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;这是一个&lt;abbr title="应用程序设计接口"&gt;API&lt;/abbr&gt;可以用来浏览&lt;abbr title="超文本标记语言"&gt;HTML&lt;/abbr&gt;和&lt;abbr title="可扩展标记语言"&gt;XML&lt;/abbr&gt;文档。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;abbr&gt;标签用于缩略语的显示，默认情况会显示为带有下划线或下划点，但是通过css的设置已经代替了浏览器的默认样式。 &lt;abbr&gt;的title属性在浏览器里是隐藏的，有些浏览器会在你把鼠标指针悬停在缩略语上时，将它的title属性显示为一个弹出式的提示消息，这也是浏览器所使用的默认行为，而不同浏览器的默认样式也不尽相同。所以就像刚才用css样式去代替浏览器默认样式那样，我们也可以用DOM去改变浏览器的默认行为。 3、显示缩略语下面我要做的是将&lt;abbr&gt;标签中的title属性集中起来显示在一个页面，我希望得到的定义列表是这个样子： 123456789101112&lt;dl&gt; &lt;dt&gt;W3C&lt;/dt&gt; &lt;dd&gt;万维网联盟&lt;/dd&gt; &lt;dt&gt;DOM&lt;/dt&gt; &lt;dd&gt;文档对象模型&lt;/dd&gt; &lt;dt&gt;API&lt;/dt&gt; &lt;dd&gt;应用程序设计接口&lt;/dd&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言&lt;/dd&gt; &lt;dt&gt;XML&lt;/dt&gt; &lt;dd&gt;可扩展标记语言&lt;/dd&gt;&lt;/dl&gt; 用DOM来具体实现这个定义列表的步骤如下： 遍历这份文档中的所有&lt;abbr&gt;元素。 保存每个&lt;abbr&gt;元素的title属性。 保存每个&lt;abbr&gt;元素包含的文本。 创建一个&lt;dl&gt;自定义列表元素。 遍历刚才保存的title属性和&lt;abbr&gt;元素的文本。 创建一个&lt;dt&gt;标题元素。 把&lt;abbr&gt;元素的文本插入到这个&lt;dt&gt;元素。 创建一个&lt;dd&gt;列表项元素。 把title属性插入到这个&lt;dd&gt;元素。 把&lt;dt&gt;元素追加到第4步创建的&lt;dl&gt;元素上。 把&lt;dd&gt;元素追加到第4步创建的&lt;dl&gt;元素上。 把&lt;dl&gt;元素追加到explanation.html文档的body元素上。 按照上面的思路我将编写一个displayAbbreviations函数，并存入Enrich_document_content.js中。 1234567891011121314151617181920212223242526272829303132333435363738394041function displayAbbreviations()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有缩略词 var abbreviations = document.getElementsByTagName('abbr'); if(abbreviations.length &lt; 1) return false; var defs = new Array(); // 便利这些缩略词 for(var i = 0;i &lt; abbreviations.length; i++)&#123; var current_abbr = abbreviations[i]; var definition = current_abbr.getAttribute('title'); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; &#125; // 创建定义列表 var dlist = document.createElement('dl'); // 遍历定义 for(key in defs)&#123; var definition = defs[key]; // 创建定义标题 var dtitle = document.createElement('dl'); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); // 创建定义描述 var ddesc = document.createElement('dd'); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; // 创建标题 var header = document.createElement('h2'); var header_text = document.createTextNode('缩略词'); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 现在已经可以在页面显示出这个定义列表，不要忘记使用addLoadEvent函数加载。下面解析一下这个函数。 第一步仍然是检查我用到的DOM方法是否被支持。 第二步是遍历获取到的所有&lt;abbr&gt;元素，为了防止html中没有&lt;abbr&gt;元素，所以在遍历之前也做了检查，避免javascript报错。 第三步用数组保存&lt;abbr&gt;元素的文本和title属性，当一个元素中只有一个子节点，用lastChild获取其子节点是一个好的方法，这里将文本作为数组的下标使用，将字符串作为数组的下标也是一种常用的方式，不要被数组的下标通常为数字就被禁锢住想法。 第四步用for…in循环，去遍历之前的数组，for…in是遍历用字符串作为下标的数组的首选，将下标(key)和下标对应的值(value)添加到&lt;dt&gt;和&lt;dl&gt;元素中。 第五步是将这个定义列表和标题插入到body中，这一步没什么特别的。 4、displayAbbreviations函数的兼容性问题按理说这个函数即检查了方法、又全部使用的DOM方法，应该不存在兼容性问题，但问题还是有，就是有的浏览器不支持&lt;abbr&gt;元素，如果是这样那么不仅没有缩略语列表，还会导致javascript报错。 出现这个隐患，如果现在去替换&lt;abbr&gt;元素太过麻烦，不论何时，要替换html中的元素都不应该作为首选。所以保证displayAbbreviations函数在IE中能够平稳退化没这个方案实现起来最简单，也就是如果浏览器不支持&lt;abbr&gt;元素就可以提前退出。 接下来要解决这个兼容性问题，做到平稳退化，我要在第一个for循环中加入一个判断。if(current_abbr.childNodes.length &lt; 1) continue;这条语句会让当前元素没有子节点的话就进入下一次循环，不支持&lt;abbr&gt;元素的浏览器在统计&lt;abbr&gt;元素的子节点个数总会返回错误值。 此时因为defs数组是空的，所以它将不会创建出任何&lt;dt&gt;和&lt;dd&gt;元素，在for…in循环之后，写一个函数出口，if(dlist.childNodes.length &lt; 1) return false;如果dlist没有子节点，那么直接跳出函数，这样就避免了报错的可能性。以下是改进后的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243function displayAbbreviations()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有缩略词 var abbreviations = document.getElementsByTagName('abbr'); if(abbreviations.length &lt; 1) return false; var defs = new Array(); // 便利这些缩略词 for(var i = 0;i &lt; abbreviations.length; i++)&#123; var current_abbr = abbreviations[i]; if(current_abbr.childNodes.length &lt; 1) continue; var definition = current_abbr.getAttribute('title'); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; &#125; // 创建定义列表 var dlist = document.createElement('dl'); // 遍历定义 for(key in defs)&#123; var definition = defs[key]; // 创建定义标题 var dtitle = document.createElement('dl'); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); // 创建定义描述 var ddesc = document.createElement('dd'); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; if(dlist.childNodes.length &lt; 1) return false; // 创建标题 var header = document.createElement('h2'); var header_text = document.createTextNode('缩略词'); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 如果浏览器不支持&lt;abbr&gt;标签，也不会出任何错误，但是也会看不到缩略语列表，不过缩略语列表也算不上页面必不可少的组成部分，如果真的是必不可少的内容，从一开始就应该把它包括在标记里。 5、显示文献来源链接表在这个案例中，还有另一个增强文档的例子，先来看看html中这段标记。 123&lt;blockquote cite="http://www.w3.org/DOM/"&gt; &lt;p&gt;一个平台和语言中立的接口，将允许程序和脚本动态访问和更新的内容，结构和风格的文档。&lt;/p&gt;&lt;/blockquote&gt; &lt;blockquote&gt;元素包含一个cite属性，它可以是一个URL地址，告诉人们&lt;blockquote&gt;元素的内容引自哪里，从理论上讲这是一个文献资料与县官网页链接起来的好办法。但实际上浏览器会完全忽略cite属性，所以我要把这些信息收集起来，以一种更有意义的方式把它们显示在网页上。 按照以下步骤完成displayCitetions函数，并存入Enrich_document_content.js文件中。 遍历这个文档里所有&lt;blockquote&gt;元素。 从&lt;blockquote&gt;元素提取出cite属性的值。 创建一个标识文本是source的链接。 把这个链接赋值为&lt;blockquote&gt;元素的cite属性值。 把这个链接插入到文献节选的末尾。 1234567891011121314151617181920212223242526272829function displayCitetions()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有引用 var quotes = document.getElementsByTagName('blockquote'); // 遍历引用 for(var i = 0;i &lt; quotes.length;i++)&#123; // 如果没有cite属性，继续循环 if(!quotes[i].getAttribute('cite')) continue; // 保存cite属性 var url = quotes[i].getAttribute('cite'); // 取得引用中的所有元素节点 var quoteChildren = quotes[i].getElementsByTagName('*'); // 如果没有元素节点进入下一次循环 if(quoteChildren.length &lt; 1) continue; // 取得引用中的最后一个元素节点 var elem = quoteChildren[quoteChildren.length - 1]; // 创建标记 var link = document.createElement('a'); var link_text = document.createTextNode('source'); link.appendChild(link_text); link.setAttribute('href',url); var superscript = document.createElement('sup'); superscript.appendChild(link); // 把标记添加到引用中的最后一个元素节点 elem.appendChild(superscript) &#125;&#125; 函数执行完毕后这个&lt;blockquote&gt;元素的引用将会添加到段落最后的source上标中。下面来解析一下这个函数。 第一部分是筛选出cite属性，再去获取&lt;blockquote&gt;元素的最后一个子节点，这里&lt;blockquote&gt;的lastChild有可能是个换行符，所以在函数中是获取的&lt;blockquote&gt;下的所有元素对象，这样就可以方便的获取&lt;blockquote&gt;的最后一个子元素。 第二部分是创建链接和插入链接，最终让&lt;sup&gt;元素包含&lt;a&gt;元素，而&lt;a&gt;元素href属性保存了cite的属性值，也就是一个url地址。最后将&lt;sup&gt;元素插入到&lt;blockquote&gt;元素的最后。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》五、动态创建标记]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%BA%94%E3%80%81%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[这一章节主要通过一些DOM方法，通过创建新元素和修改现有元素来改变网页结构，用DOM的方法改变标记。 1、创建元素节点和文本节点DOM是文档的表示，DOM所包含的信息与文档里的信息一一对应，你只要学会问正确的问题，就可以从获取DOM节点上任何一个节点的细节。 DOM是一条双向车道，不仅可以获取文档的内容，还可以更新文档的内容，如果改变了DOM节点树，文档在浏览器里的呈现就会发生变化，所以与其说是创建标记，不如说是在改变DOM节点树，在DOM的角度来看，一个文档就是一颗节点树，如果想在节点树上添加内容，就必须插入新的节点，如果想添加一些标记文档，就必须插入元素节点。 比如现有一个HTML元素&lt;div id = &quot;testdiv&quot;&gt;&lt;/div&gt;，我要在其中插入一段文本，需要4个步骤。 创建一个新的元素。 把这个新的元素插入节点树。 创建一个文本节点。 把文本节点插入新元素的节点树。 1234567window.onload = function()&#123; var pare = document.createElement('p'); var testdiv = document.getElementById('testdiv'); testdiv.appendChild(pare); var txt = document.createTextNode('Hello World'); pare.appendChild(txt);&#125; 这些代码会在页面上显示”Hello World”，并且包含在&lt;div id = &quot;testdiv&quot;&gt;&lt;/div&gt;中。 首先用document.createElement方法创建一个&lt;p&gt;元素，创建以后&lt;p&gt;元素还不是任何一颗DOM树的组成部分，它只是游荡在javascript世界里的一个孤儿，这种情况被称为文档碎片(document frogment)，不过，这时&lt;p&gt;元素已经有了自己的DOM属性，比如nodeType和nodeName。 现在要让&lt;p&gt;元素成为testdiv的一个子节点，appendChild方法可以完成这一任务，这个方法的语法是parent.appendChild(child)。 最后我要给&lt;p&gt;元素增加文本内容，也就是创建一个文本节点并让其成为&lt;p&gt;元素的子节点，使用document.createTextNode方法可以实现，用法和document.createElement相同，同样这个本文节点也是一个孤儿节点，需要使用appendChild添加到&lt;p&gt;元素中。 其实我也可以改变上面的执行顺序，先创建两个节点，再依次加入DOM树中也是一样的。 2、重回图片库案例现在图片库的html文件中有一个图片和一段文字仅仅是为showPic脚本服务的，既然这些元素的存在只是为了让DOM方法处理它们，那么用DOM方法来创建它们才是最合适的选择。动态创建需要完成的步骤如下： 创建一个img元素节点。 设置这个节点的id属性、src属性、alt属性。 创建一个p元素节点。 创建这个节点的id属性。 创建一个文本节点。 把这个本文节点追加到p元素上。 把p元素和img元素插入到gallery.html文档。 1234567891011121314151617function preparePlaceholder()&#123; if(!document.createElement) return false; if(!document.createTextNode) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var placeholder = document.createElement('img'); placeholder.setAttribute('id','placeholder'); placeholder.setAttribute('src','images/placeholder.gif'); placeholder.setAttribute('alt','my image gallery'); var description = document.createElement('p'); description.setAttribute('id','description'); var desctext = document.createTextNode('Chose an image'); description.appendChild(desctext); var gallery = document.getElementById('imagegallery'); insertAfter(placeholder,gallery); insertAfter(description,placeholder);&#125; 现在我可以将html中图片展示的元素和文字描述的元素删除了。 为了确保退路，函数的第一部分仍是检测浏览器是否支持这些方法，这里主要说一下insterAfter方法，它的功能是把一个节点插入到另一个节点之后，DOM本身并没有提供这个方法，所以我们可以自己编写一个函数。 12345678function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 这个函数的步骤如下： 这个函数有连个参数，第一个是要插入的新元素，第二个是目标元素。 获取目标元素的父元素，存到parent变量。 检测目标元素是不是其父元素的最后一个元素。 如果是就用appendChild把新元素追加到parent元素上。 如果不是就把新元素插入到目标元素和其下一个兄弟元素之间，使用nextSibling属性获取这个元素的下一个兄弟元素，使用insertBefore方法把下一个元素插入到另一个元素之前，语法是parentElement.insertBefore(newElement,targetElement)。 3、AjaxAjax主要用于异步加载页面内容的技术，用Ajax可以做到只更新页面的一小部分，不必刷新整个页面。 Ajax的优势就是对页面的请求以异步的方式发送到服务器，而服务器不会用整个页面来相应请求，它会在后台处理请求，与此同时用户还能继续浏览页面并与页面交互，而脚本则可以按需加载内容。 XMLHttpRequest对象Ajax技术的核心就是XMLHttpRequest对象，这个对象充当着浏览器中的脚本与服务器之间的中间人的角色，以往的请求都是浏览器发出，而javascript通过这个对象也可与自己发送请求，同时也自己处理响应。 不同浏览器对实现XMLHttpRequest对象方式不太一样，为了解决兼容性问题，我们可以自己封装一个函数。 1234567891011121314151617function getHttpObject()&#123; if(typeof XMLHttpRequest == 'undefind')&#123; XMLHttpRequest = function()&#123; try&#123; return new ActiveXObject('Msxml2.XMLHTTP6.0'); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject('Msxml2.XMLHTTP3.0'); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject('Msxml2.XMLHTTP'); &#125;catch(e)&#123;&#125; return false; &#125; &#125; return new XMLHttpRequest();&#125; 这个函数通过对象检测技术检测了XMLHttpRequest，如果失败则继续检测其他方法，最终返回一个false或新的XMLHttpRequest对象。 其中ActiveXObject是IE的实现方法，实现了一个名叫XMLHTTP的对象，IE版本中使用的XMLHTTP对象也不完全相同。 XMLHttpRequest发送请求的方法XMLHttpRequest对象有许多的方法，下面通过一个新的函数来具体看XMLHttpRequest的执行过程和方法，这里假设example.txt是接口的地址 1234567891011121314function getNewContent()&#123; var request = getHttpObject(); if(request)&#123; request.open('GET','example.txt',true); request.onreadystatechange = function()&#123; if(request.readyState == 4)&#123; var txt = request.responseText; &#125; &#125; request.send(null); &#125;else&#123; alert('你的浏览器不支持XMLHttpRequest') &#125;&#125; 首先最有用的就是open方法，用open方法来指定服务器上要访问的文件、指定请求类型、指定请求是否以异步的方法发送和处理。 onreadystatechange方法会在服务器给出回应的时候被触发执行，在这个函数中，可以根据服务器的具体响应做相应的处理。 send方法用于发送数据，通常写在指定请求的目标并明确如何处理响应之后。 服务器回响XMLHttpRequest的方法服务器在向XMLHttpRequest对象发送回响时，该对象有许多属性可用。 readyState属性，浏览器会在不同阶段更新readyState属性的值。 0 表示未初始化。 1 表示正在加载。 2 表示加载完毕。 3 表示正在交互。 4 表示完成。 所以只要readyState属性的值变为4，就可以访问服务器发送回来的数据了。 responseText和responseXML属性用于保存服务器发送回来的数据，responseText用于保存文本字符形式的数据，responseXML用于保存Content-Type头部中制定为’text/xml’的数据。 另外，只要是依赖于服务器响应的脚本，都要写在onreadystatechange属性的函数中，因为在发送XMLHttpRequest请求之后，脚本仍然会继续执行，不会等待响应返回，如果把依赖服务器返回内容的代码写在onreadystatechange之后，可能会导致这些代码执行了但数据还没有获取到。send方法就是最好的证明，它会优先于onreadystatechange执行。 Ajax应用的一个特色就是减少重复加载页面的次数，但这种缺少状态记录的技术会与浏览器的一些使用惯例产生冲突，导致用户无法使用后退按钮或者无法为特定状态下的页面添加书签，理想情况，用户每一次操作都应该得到一个清晰明确的结果，为此，web设计人员必须在向服务器发出请求和服务器返回相应时，给用户明确提示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》四、图片库改进]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%9B%9B%E3%80%81%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%2F</url>
      <content type="text"><![CDATA[在这一章主要是用上一章的思想改进图片库，所以我会把之前的javascript图片库案例拿来看看是不是符合上一章所说的规则。 1、支持平稳退化吗？可以确定，图片库如果禁用了javascript功能，也已经留了退路，网页里的所有链接都是可用的，虽然用户体验游影响，但网页的功能并未受到损害，而如果当时在href中写的不是链接而是伪协议或是’#’，那么禁用javascript后它会无法使用。 2、javascript与html分离吗？在图片库中它们确实是混在了一起，onclick直接插入到了html中，理想情况下，应该在外部文件里添加onclick事件处理函数。 我需要编写一个简短的函数把有关操作关联到onclick事件上，我想让函数完成以下工作： 检查浏览器是否理解getElementsTagByName。 检查浏览器是否理解getElementById。 检查网页是否存在一个id为imagegallery的元素。 遍历imagegalery元素中的所有链接。 设置onclick事件，让它在有关链接被点击时完成以下操作。 把这个链接作为参数传递给showPic函数。 取消链接被点击时的默认行为。 12345678910111213function prepareGallery()&#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i = 0; i &lt; links.length; i++)&#123; links[i].onclick = function()&#123; showPic(this); return false; &#125; &#125;&#125; 为了方便获取元素，我将&lt;ul&gt;的id设为’imagegallery’。 函数的第一部分是检查点，如果不支持或没有检查的内容就离开，其实也可以写为if(!document.getElementsByTagName || !document.getElementById) return false;将两个检查写到一起，但是这样写代码太过冗长不利于阅读，所以将代码写在一行并不一定是个好主意。 代码中我用变量名存储获取到的元素，避免了代码写得太长，在给变量起名时，应该选择一些有意义的单词来命名，可以让代码更容易阅读和理解，并且一定要避免使用保留字和函数或方法名。 函数的最后是一个遍历，links存储了列表中的所有a元素，并且是一个伪数组，所以可以遍历得到每个a元素并且将onclick事件绑定给该元素，这样绑定之后，该事件处理函数的this就是绑定该事件的元素，至此可以从html中彻底删除onclick事件了。 3、共享onload事件现在我还需要一个功能，就是要在DOM树加载完之后再执行上面的prepareGallery函数，如果只有一个函数用window.onload = prepareGallery即可，但如果有多个函数，就不能直接这样写，后面的会覆盖前面的，所以我还要再写一个函数完成这个绑定功能。 把现有的window.onload事件处理函数的值存入变量oldonload。 如果在这个处理函数上还没有绑定函数，就像平时那样把新函数添加给它。 如果在这个处理函数上已经绑定了函数，就把新函数追加到现有指令的末尾。 1234567891011function addLoadEvent(func)&#123; var oldonload = window.onload; if(typeof window.onload != 'function')&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; oldonload(); func(); &#125; &#125;&#125; 这个函数将把那些在页面加载完毕时执行的函数创建一个队列，参数func就是要执行的函数。 4、不要做太多的假设下面我要改造一下showPic函数，因为我发现showPic函数并没有任何检查和测试，所以需要一些语句来检查这些元素是否存在。 showPic函数负责完成两件事： 找出id属性是placeholder的图片并修改其src属性。这个是核心功能，必须完成的任务。 找出id属性是description的元素并修改其第一个子元素的nodeValue属性。这个功能只是锦上添花，所以只要placeholder图片存在，即使description元素不在，切换显示新图片的操作也将照常进行。 123456789101112function showPic(whichpic) &#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src", source); if(document.getElementById('description'))&#123; var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; &#125; return true;&#125; 现在这个函数完成了检测，只要图片可以正常获取就返回true，但是还有一个问题，就是如果把placeholder图片从标记文档里删掉，无论点击imagegallery清单里的哪一个链接，都没有任何反应，这不符合平稳退化，此时应该让浏览器打开那个被点击的链接，而不是什么都不发生。 导致这个问题的原因是prepareGallery函数中是假设showPic肯定会切换图片成功，基于这一点才取消了a元素onclick事件的默认行为links[i].onclick = function(){showPic(this);return false;}，但是现在在showPic中，如果图片切换成功才返回true，如果图片切换失败会返回false。所以如果showPic返回了false就不应该取消点击事件，而是该让a元素的链接正常打开，让切换图片的操作照常进行。所以是否取消默认行为应该由showPic函数决定。 为了达到这个目的，应该先验证showPic的返回值，以便决定是否阻止默认行为，如果showPic返回true，那么更新placeholder，取消默认事件。如果showPic返回false，那么就不取消默认事件。在onclick事件处理函数中，我们可以利用逻辑非来对showPic的返回值进行取反。 123links[i].onclick = function()&#123; return !showPic(this);&#125; 现在这个函数已经相当完善，虽然它们的长度有所增加，但它们对标记的依赖和假设已经比原来少多了，尽管如此，在showPic函数里仍存在一些需要处理的假设。 如果a元素的title属性存在，变量text将被赋值a元素的title属性，如果不存在，变量text将被赋值为一个空字符串。 假设placeholder元素是否是一张图片，可以用nodeName属性来测试，要注意的是，nodeName属性总是返回的值总是大写字母。 假设description元素的第一个子元素是一个文本节点，可以用nodeType属性来检测，如果nodeType的值是3，就是一个文本节点。 123456789101112131415function showPic(whichpic) &#123; if (!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); if (placeholder.nodeName != 'IMG') return false; placeholder.setAttribute("src", source); if (document.getElementById('description')) &#123; var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : ''; var description = document.getElementById('description'); if(description.firstChild.nodeType == 3)&#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125; showPic的代码变得更多了，在实际中，你需要自己决定是否真的需要这些检查，它们针对的是html文档有可能不再你的控制范围内的情况，但理想情况下，脚本不应该对html文档的内容和结构做太多假设。 5、键盘访问事件前面的代码只能用鼠标操作，而浏览器web页面也是可以用键盘进行操作的，有个名叫onkeypress的事件处理函数就是专门用来处理键盘事件的，按下键盘的任何一个按键都会触发onkeypress事件。 如果想把onkeypress事件加到上面的案例并完成和onclick相同的操作，只需要这样写links[i].onkeypress = links[i].onclick;，但是在这个案例中我认为并不需要键盘访问事件，有onclick事件足矣，我想说的是，在这里完全体现出了javascript和html分离带来的方便，如果像是最开始那样把javascript写在html中，将不得不去修改每行html语句，而现在只要在javascript代码中加一条语句即可。 6、DOM Core和HTML-DOM至此，我在编写javascript代码时只用到了以下几个DOM方法：getElementById、getElementsByTagName、getAttribute、setAttribute。 这些方法都是DOM Core的组成部分，它们并不是专属javascript语言，支持DOM的任何一种程序设计语言都可以使用它们，它们的用途也并非仅限于处理网页，它们可以用来处理任何一种标记语言(比如XML)编写出来的文档。像onclick属于HTML-DOM，它们在DOM Core出现之前很久就已经为人们所熟知，比如HTML-DOM提供了一个forms对象，写法是document.forms可以代替document.getElementsByTagName(forms)。还有element.src可以代替element.getAttribute。 它们的区别是HTML-DOM只能处理web文档，我使用DOM Core也是因为其兼容多种类型的文档，其实这个完全是根据使用场景来选择，并没有绝对的对错之分。 7、增加css1234567891011121314151617181920212223242526272829303132333435363738394041424344body &#123; font-family: "Helvetica","Arial",serif; color: #333; background-color: #ccc; margin: 1em 10%;&#125;h1 &#123; color: #333; background-color: transparent;&#125;a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none;&#125;ul &#123; padding: 0;&#125;li &#123; float: left; padding: 1em; list-style: none;&#125;img&#123; display: block;&#125;#imagegallery &#123; list-style: none; overflow: hidden;&#125;#imagegallery li &#123; display: inline;&#125;#imagegallery li a img &#123; border: 0;&#125; 8、把图片的文字链接改为缩略图12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" type="" href="./css/style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul id="imagegallery"&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" title = "A fireworks display"&gt; ![](images/thumbnail_fireworks.jpg) &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" title = "A cup of black offee"&gt; ![](images/thumbnail_coffee.jpg) &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" title = "A red,red rose"&gt; ![](images/thumbnail_rose.jpg) &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigben.jpg" title = "The famous clock"&gt; ![](images/thumbnail_bigben.jpg) &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = "placeholder" src = "images/placeholder.gif" alt = "my image galley"/&gt; &lt;p id="description"&gt;Choose an image&lt;/p&gt; &lt;script src="script/script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》三、最佳实践]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%B8%89%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[1、平稳退化和渐进增强什么是平稳退化不管你想通过javascript个改变哪个网页的行为，都必须三思而后行，首先要确认，为这个网页增加这种额外的行为是否有必要。 在所有的javascript特效当中，最臭名昭著的莫过于那些在人们打开网页时弹出的广告窗口，不幸的是有不少用户为此干脆彻底禁用了javascript，这是一个典型的滥用javascript的例子，从技术上讲弹窗解决了如何向用户发送信息，但在实践中，频繁弹出的广告窗口却让用户不胜其烦，令人欣慰的是这一问题已经收到了所有人的关注，那些不遵守用户至上原则的网站都在自取灭亡。 所以如果要使用javascript就要确认，这么做会对浏览体验产生怎样的影响，最重要的是，如果用户的浏览器不支持或禁用了javascript的情况下仍能顺利浏览你的网址，这就是平稳退化。虽然某些功能无法使用，但最基本的操作仍能顺利完成。 举个例子以弹出窗口的例子来说明平稳退化的思想。这里并不是指在加载网页时弹出，而是点击后弹出，例如服务条款，邮费列表等等。 javascript使用window.open(url,name,features)来创建新的浏览器窗口。 参数1：新窗口里页面的url地址，省略这个参数就是一个空白网页。 参数2：新窗口的名字，代码可以通过这个名字与新窗口交互。 参数3：以逗号分隔的字符串，包括新窗口尺寸(工具条、菜单条、初始显示位置等等)。 123function popUp(winURL)&#123; window.open(winURL,"popup","width=320,height=480");&#125; 这个函数将打开一个320x480像素的新窗口”popup”。 使用popUp函数的一个办法是使用伪协议。 真协议用来在因特网上的计算机之间传输数据包，比如HTTP、FTP协议等，协议则是一种非标准化的协议。 1&lt;a href = "javascript:popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 通过”javascript:”为协议调用popUp()函数。 1&lt;a href = "#" onclick = "popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 这是内嵌式的事件处理函数，这个链接的href没什么用，所以用”#”，表示一个空连接，实际工作由onclick完成。 但是以上两种方法都很糟糕，因为它们都不能平稳退化。有以下两点原因。 用户如果禁用了javascript功能，这样的链接将毫无作用。 第二点是不利于搜索引擎排名，搜索机器人浏览web页的目的是把各种网页添加到搜索引擎的数据库，很少有机器人能理解javascript代码。 其实为javascript代码预留退路很简单，给href设置真实的URL地址。 1&lt;a href = "http://www.example.com/" onclick = "popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 这样即使javascript被禁用，这个链接也不是失效的，只是功能上打了点折扣，这是一个经典的平稳退化的例子。 渐进增强所谓”渐进增强”就是用一些额外的信息层去包裹原始数据，按照”渐进增强”原则创建出来的网页几乎都符合”平稳退化”原则，在一个网页中，良好的内容就是一切，只有正确的使用标记语言才能对内容做出准确的描述，CSS指令构成了一个表示层使文档呈现出各种模式，但即使去掉这个表示层，文档的内容也依然可以访问。 2、分离javascript就像css那样把style写到html文档中，虽然可以用，但是这种做法弊大于利，最好的方法是把样式信息存入一个外部文件。在文档的head部分用&lt;link&gt;标签调用这个文件，这样更容易阅读和理解，样式信息也更容易更改，不用去文档里逐一搜索和替换，这个结论同样适用于javascript。 现在我要把上面弹窗例子中的onclick事件分离出来。具体步骤如下： 把文档里的所有链接全放入一个数组里。 遍历数组。 如果某个链接的class属性等于popup，就表示这链接在被点击时应该调用popUp()函数 1234567891011121314window.onload = function()&#123; if(!document.getElementsByTagName) return false; var links = document.getElementsByTagName('a'); if(links.length &gt; 0)&#123; for(var i = 0;i &lt; links.length;i++)&#123; if(links[i].getAttribute('class') == 'popup')&#123; links[i].onlcick = function()&#123; popUp(this.getAttribute('href')); return false; &#125; &#125; &#125; &#125;&#125; 以上代码把调用popUp()函数添加到有关的链接上，存入一个外部javascript文件中。 这里使用了window.onload事件，当onload事件触发时代表整个文档已经加载完毕，当然也包括DOM树，我要让HTML文档先加载这样才可以生成DOM树，起码要在DOM树生成后才可以加载javascript文件，否则获取不到文档中的各个元素，即使把javascript文件放到body的底部，也不能保证哪个先加载结束，浏览器可能一次加载多个文件，因为javascript加载时文档可能还没加载完成，所以DOM也没有加载完，很多功能会无法使用。 3、向后兼容性上面的代码中，针对访问者可能未启用javascript功能的情况，需要进行对象检测，在这里用if语句检测访问者的浏览器是否支持document.getElementsByTagName方法。如果不支持，就不会再继续执行，直接return false;这是一种很常见的向后兼容的方法，适用于很多地方。 4、性能考虑在上面案例的for循环开始前检测是否获取到了a元素，没有的话后面的代码也没必要执行，这里将所有a元素存入link变量。出入对性能考虑，我们应该检查查询DOM中某些元素的操作，搜索整个DOM树对性能并没有好处，总之把搜索结果保存在一个全局变量里，或者把一组元素直接以参数形式传递给函数，是最好的方法。 另外，js文件在HTML标签中的位置对页面初次加载时间也有很大影响，通常我习惯放在head中，但位于head中的脚本会导致浏览器无法并行加载其他文件。根绝HTTP规范，浏览器每次从一个域名中最多可能同时下载两个文件，所以把script标签放到文档末尾，之前可以让页面加载更快]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》二、javascript图片库]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%BA%8C%E3%80%81javascript%E5%9B%BE%E7%89%87%E5%BA%93%2F</url>
      <content type="text"><![CDATA[从这一篇开始会逐步完成一个图片库的案例，但我们不能直接把所有的图片直接放到一个页面里，因为图片下载的时间较长，用户需要等待很长时间去加载一个网页，所以我们需要一个图片库，把整个图片库的浏览链接集中安排在主页里，只在用户点击了这个主页里的某个图片链接时才把相应的图片加载。 1、建立基础的HTML结构123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" title = "A cup of black offee"&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" title = "A red,red rose"&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigen.jpg" title = "The famous clock"&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2、改进图片库这个网页现在的功能是： 清单列表中的每个链接分别指向不同的图片，点击跳转到相应的图片页面。 从图片返回列表要借助于浏览器的back功能。 需要改进的地方： 点击某个链接时，能留在这网页而不是转到另一个窗口。 点击某个链接时，能在这个网页上同时看到那张图片及原有清单列表。 点击某个链接时，在图片的下方显示改图片的描述文字。 完成上述目标要完成的几项改进： 通过增加一个占位图片的办法在这个主页上为图片预留一个浏览区域。 点击某个链接时，拦截这个网页的默认行为。把占位图片替换为与那个链接相对应的图片。 点击某个链接时，获取链接的描述文字，保存到图片下方的位置。 第一步、增加占位图片html部分 1&lt;img id = "placeholder" src = "images/placeholder.jpg" alt = "my image galley"/&gt; js部分 12345function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source);&#125; 为了把占位图片替换为要查看的图片，需要一个方法来改变它的src属性。参数whichpic代表一个指向某个图片的a元素，变量source是参数a元素的href属性值，变量placeholder是占位图片的元素对象。 我们还有另一种方法，也就是非DOM方法，直接用placeholder.src = source;，效果等同于placeholder.setAttribute(&quot;src&quot;,source);，我选择DOM方法的原因是setAttribute是第1级DOM，它的兼容性和可移植性更好，DOM本身适用于任何一种标记语言，DOM是一种适用于多种环境和多种程序设计语言的通用型API，而非DOM方法只能适用于web浏览器，所以在以后的选择时，尽量选择DOM方法。 最后将该方法单独存为一个叫做show_pic.js的文件并引用。在实际开发中，可以将多个功能放到一个js文件中，这样可以减少对站点的请求次数，提高性能。 1&lt;script src="script/script.js"&gt;&lt;/script&gt; 第二步、事件处理函数事件处理函数的作用是在特定事件发生时，调用特定的javascript代码。这个案例中要使用的是onclick点击事件。 1&lt;a href = "images/fireworks.jpg" onclick = "showPic(this);return false;" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; 在每一条链接上增加onlcick事件和处理程序。showPic就是之前写好的方法，将this作为参数传进去，this这里指的就是a元素对象。 return false的作用是阻止默认行为被调用，a元素的默认行为是打开一个新窗口，我不需要这个效果，所以要组织。 事件处理函数的工作机制：在给某个元素添加了事件处理函数后，一旦事件发生，javascript代码便会执行，这些被调用的javascript代码可以返回一个值，这个值将被传递给事件处理函数，具体到此案例中，当onclick被触发时，如果执行的代码返回true，onclick事件处理函数就会认为这个链接被点击了，如果返回false，onclick事件处理函数就认为这个链接没有被点击，所以当onclick认为没有点击链接，自然也不会打开一个新链接。 第三步、增加图片描述文字现在我要用DOM给图片增加一段描述，这段描述的位置在img标签之后，同时也起到了占位符的作用 1&lt;p id="description"&gt;Choose an image&lt;/p&gt; 为了实现这个功能也需要扩展一下showPic函数。 获取a标签的title属性值，并存入变量text。 获取描述文本的元素，id值为description的p元素，保存到变量description。 把description对象的第一个子节点的nodeValue属性值设置为变量text的值。 12345678function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source); var text = whichpic.getAttribute('title'); // 1 var description = document.getElementById('description'); // 2 description.firstChild.nodeValue = text; // 3&#125; 这里设置描述文本我使用的是nodeChild属性，nodeChild属性可以设置和获取文本元素的文本内容。需要注意的是必须是文本节点。 比如description是一个元素节点，那么description.nodeChild获取的就是null，用description的子节点才有效description.firstChild.nodeChild，这里description只有一个子节点并且是文本节点，所以使用firstChild和lastChild都一样，如果description有好几个子元素，要获取其中的某个可以用children[index]来获取。 最终效果最后我们增加一些css样式来美化一下页面,创建style.css文件并引入html文件中。 123456789101112131415161718192021222324252627282930313233body &#123; font-family: "Helvetica","Arial",serif; color: #333; background-color: #ccc; margin: 1em 10%;&#125;h1 &#123; color: #333; background-color: transparent; &#125;a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none;&#125;ul &#123; padding: 0;&#125;li &#123; float: left; padding: 1em; list-style: none;&#125;img &#123; display: block; clear:both;&#125; 以下是script.js文件的最终内容 12345678function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source); var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text;&#125; html文件的最终结构如下 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" type="" href="./css/style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" onclick = "showPic(this);return false;" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" onclick = "showPic(this);return false;" title = "A cup of black offee"&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" onclick = "showPic(this);return false;" title = "A red,red rose"&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigben.jpg" onclick = "showPic(this);return false;" title = "The famous clock"&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = "placeholder" src = "images/placeholder.gif" alt = "my image galley"/&gt; &lt;p id="description"&gt;Choose an image&lt;/p&gt; &lt;script src="script/script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面的最终效果如下，点击i链接可以改变图片和描述文字。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript（BOM常用方法）]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%EF%BC%88BOM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
      <content type="text"><![CDATA[BOM操作的常用属性和方法open()：打开一个新的页面，格式为open(页面的url,打开的方式)，如果url为空则打开一个空白页面。如果打开方式为空，默认为新窗口方式打开。这个方法返回新窗口的window对象。 close()：关闭一个页面，但是这个方法有点兼容性问题，firefox默认无法关闭，chrome默认直接关闭，ie：询问用户。 navigator.userAgent：返回浏览器的名称和版本。 location：浏览器地址信息，本身不是字符串，是object格式。 location：就是url地址本身。 location.search：url中?后面的内容。 location.hash：url中#后面的内容。 窗口尺寸与大小可视区的尺寸：document.documentElement.clientWidth和document.documentElement.clientHeight。 滚动条滚动的距离：document.documentElement.scrollTop和document.documentElement.scrollLeft。在chrome浏览器中要使用document.body.scrollTop和document.body.scrollLeft。 元素内容的宽高：div.scrollHeight和div.scrollWidth。 文档的宽高：document.documentElement.offsetHeight和document.documentElement.offsetWidth。也可以使用document.body.offsetHeight和document.body.offsetWidth。 事件onscroll：当滚动条滚动的时候触发。 onresize：当浏览器尺寸改变的时候触发。 onfocus：当元素获取焦点时触发。 onblur：当元素失去焦点时触发。 focus()：给元素设置焦点。 blur()：让元素失去焦点。 select()：选择指定元素里面的文本内容。只能选择用户可以输入的内容。 onmousemove：鼠标在一个元素上移动时触发。 onkeydown：当键盘按键按下的时候触发。能够响应用户输入的元素才支持键盘事件，和焦点事件一样。如果按下不抬起来会连续触发。 onkeyup：当键盘按键抬起时触发。 oncontextmenu：当右键菜单显示出来时触发。 event事件对象：当一个事件发生时，这个对象发生的这个事件有关的一些详细的信息都会临时保存到event对象中，以便在需要时使用。 事件绑定标准浏览器的方法：div.addEventListener(事件名称，事件处理函数，捕获/冒泡);。false是冒泡，true是捕获。 有捕获。 事件名称没有on。 this指向调用该函数的对象。 事件执行的顺序是正序。 非标准浏览器方法：div.attachEvent(&#39;on&#39;+事件名称，事件处理函数); 没有捕获。 事件名称有on。 this指向window(可以通过call()来解决这个问题)。 事件执行的顺序是倒序。 事件取消非标准浏览器方法：div.dettachEvent(&#39;on&#39;+事件名称,事件处理函数); 标准浏览器方法：div.removeEventListener(事件名称，事件处理函数，捕获/冒泡) 事件流事件流和样式位置没关系，和html的结构有关系 事件冒泡：当一个元素接收到事件的时候，会把它接收到的所有事件传播给它的父级，一直到顶层(window)。父级元素只要有相关的事件处理函数，那么就会被执行。阻止冒泡设置事件函数：event.cancelBubble = true; 冒泡最主要的作用是父元素和子元素都需要的事件处理函数，只需要绑定给父元素就可以了，而如果希望只有子元素才执行的事件处理函数可以通过设置阻止冒泡来接解决。 事件捕获：捕获和冒泡相反，是从最外层元素传播到目标元素。其他并没什么不同。 控制事件是捕获还是冒泡是由addEventListener中的第三个参数决定的，false为冒泡事件监控是出去的由内向外的，true为捕获事件监控是进来的由外向内的。 cookiecookie的作用就是存储数据。长时间去保存一个值，比如用户上次访问的时间等。 当用户访问了某个网站时候，可以通过cookie向访问者的电脑上存储数据，每个浏览器存储的位置不同，所以不同浏览器存储的cookie不能互相通用。 cookie的存储是以域名的形式区分的，也就是说每个网站的cookie文件是不同文件夹存放的，一个域名下的cookie也可能有多个文件。所以每个cookie文件是可以设置名字的。否则cookie文件会很大很乱。 document.cookie = &#39;username=ypj&#39;;这就设置了一个cookie文件的名字和值。 document.cookie;读取当前网站下的下所有的cookie的内容，是字符串格式。 一个域名下存放cookie的个数是有限制的，不同浏览器存放的个数不同。 每个cookie存放的内容大小也是有限制的，也是根据浏览器不同限制也不同。 默认情况下，cookie的周期是整个浏览器结束进程的时候。 如果想长时间存放一个cookie，需要在设置这个cookie的时候同时给他设置一个过期的时间。当过期后cookie就会被销毁。 123var oDate = new Date();oDate.setDate(oDate.getDate() + 5); // 保存5天document.cookie = 'username=ypj;expires=' + oDate.toGMTString() // 将oDate又object转为string; cookie在存储特殊字符的时候可能会出现问题，需要通过encodeURI()编码来解决。解码使用decodeURI()方法。参数都是字符。 用js读取cookie时候只能获取整个字符串，没法直接获取某个cookie的键值，同样设置的时候也不方便，所以可以写两个方法来方便操作。 获取cookie 123456789function getCookie(key)&#123; var arr1 = document.cookie.split(';'); for(var i = 0;i &lt; arr1.length;i++)&#123; var arr2 = arr1[i].split('='); if(arr2[0] == key)&#123; return decodeURI(arr[1]); &#125; &#125;&#125; 设置cookie 12345function setCookie(key,value,t)&#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + t); document.cookie = key + '=' + value + ';expires=' + oDate.toGMTString();&#125; 删除cookie 123function removeCookie(key)&#123; setCookie(key,'',-1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo配置]]></title>
      <url>%2F2017%2F06%2F01%2Fhexo%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[安装hexo安装过程使用以下命令下载hexo $ npm install hexo-cli -g 如果在安装过程中遇到以下错误 ERROR Deployer not found : github 则运行以下命令,或者你直接先运行这个命令更好。 $ npm install hexo-deployer-git --save 新建hexo的文件夹，以后的博客相关的操作都在这个文件夹里边，不要有中文目录。在该文件夹内部执行下面命令 $ hexo init 安装依赖包 $ npm install hexo常用的命令 $ hexo g 完整命令为hexo generate，用于生成静态文件。 $ hexo s 完整命令为hexo server，用于启动服务器，主要用来本地预览。 $ hexo d 完整命令为hexo deploy，用于将本地文件发布到github上。 $ hexo n 完整命令为hexo new，用于新建一篇文章。 查看hexo的本地服务器网页 http://localhost:4000/ 连通githubgithub中的项目名称必须是name.github.io格式 编辑本地hexo目录下的_config.yml文件。以下配置的name要改成自己的 1234deploy: type: git repository: http://github.com/name/name.github.io.git branch: master 配置好之后使用$ hexo g和$ hexo d发布到github。第二个命令会要求输入github的账号密码。如果成功的话打开name.github.io就可以查看博客了。 最好已经搞定了ssh配置，否则每次都要输入密码。 正式发布博客按照自己的意愿修改完后，执行$ hexo g，$ hexo s，打开localhost:4000看看效果。 新建一篇博客$ hexo new &quot;my new post&quot; 在\hexo\source\_post中打开my-new-post.md，开始编辑。 1234567title: my new post #可以改成中文的，如“新文章”date: 2015-04-08 22:56:29 #发表日期，一般不改动categories: blog #文章文类tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt;#在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，使用$ hexo g生成静态文件。$ hexo s在本地预览效果。$ hexo d同步到github，然后使用http://name.github.io进行访问。 清除缓存清除缓存文件db.json和已生成的静态文件public。如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 $ hexo clean 文章的各种格式https://hexo.io/zh-cn/docs/tag-plugins.html next主体设置下载主题$ cd your-hexo-site打开电脑的hexo站点目录。$ git clone https://github.com/iissnan/hexo-theme-next themes/next 在hexo的配置文件中设置theme: next。 主题设定在主题配置文件中可以设置三种主题。 1scheme: Muse || Mist || Pisces 语言设置在hexo配置文件中设置language: zh-Hans。这是简体中文，英文是en。 设置菜单菜单设置包括三个部分，菜单项、菜单项显示文本、菜单项对应图标。在主题配置文件中设置 1234567menu: home: / #主页 archives: /archives #归档页 #about: /about #关于页 categories: /categories #分类页 tags: /tags #标签页 commonweal: /404.html #公益404 现在菜单的文字是固定的，如果要修改文字要打开themes\next\languages\zh-Hans.yml去设置对应中文名称，也可以新建。 图标设置在主题配置文件下,与菜单设置一一对应。 123456789menu_icons: enable: true # Icon Mapping. home: home #about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置侧栏通过修改主题配置文件控制侧栏行为，一个是侧栏位置，一个是侧栏显示时机。 侧栏位置： 12sidebar: position: left 侧栏的行为 12sidebar: display: post #目录列表时显示 || always #一直显示 || hide # 一直隐藏 || remove #完全移除 设置头像主题配置文件中 1avatar: /images/avatar.png # 路径是next/source/images/ 昵称和描述站点配置文件中author参数是昵称，description参数是站点的描述 设置字体在主题配置文件中查找font字段修改。各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组： 非代码类字体：Fallback 到 “PingFang SC”, “Microsoft YaHei”, sans-serif 代码类字体： Fallback 到 consolas, Menlo, “PingFang SC”, “Microsoft YaHei”, monospace 添加菜单栏的页面打开hexo的目录站点下，运行hexo new page categories，这样就新建了categories页面，其他菜单类似，新建之前先去删除之前的。 侧边栏社交在主题配置文件中设置 设置显示文本和链接地址 123social: GitHub: https://github.com/your-user-name 微博: http://weibo.com/your-user-name 设定链接的图标 123social_icons: GitHub: github 微博: weibo 设置友情链接 1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ ### 设置动画效果 在主题配置文件中设置，要等到js加载完才会显示动画和内容。 12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 设置动画背景自带两种动画效果，在主题配置文件中设置 1234567# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画 添加百度/谷歌/本地 自定义站点内容搜索安装 hexo-generator-searchdb，在站点的根目录下执行以下命令npm install hexo-generator-searchdb --save hexo站点配置文件新增配置 12345search: path: search.xml field: post format: html limit: 10000 主题站点配置文件设置 123# Local searchlocal_search: enable: true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript（DOM常用方法）]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%EF%BC%88DOM%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
      <content type="text"><![CDATA[DOM操作的一些常用属性和方法元素节点的nodeType是1 属性节点的nodeType是2 文本节点的nodeType是3 节点的获取childNodes：获取某个元素下的所有子节点，包含文本节点和元素节点。 children：获取某个元素下的所有元素子节点。 nextElementSibling：获取元素的下一个兄弟元素节点。 previousElementSibling：获取元素的上一个兄弟元素节点。 firstElementChild：获取元素下的第一个元素子节点。 lastElementChild：获取元素下的第一个元素子节点。 parentNode：获取元素的父节点。 nodeValue：查看节点的属性值。 nodeName：查看节点的属性名。 nodeType：查看节点的类型。 属性的获取和设置offsetParent：获取最近有定位属性的祖先节点。如果没有直接获取body。 offsetLeft：左外边框到有定位的最近的父级元素的内边框的距离。不带px单位。父级没有带定位的就是到body的距离。 offsetTop：上外边框到有定位的最近的父级元素的内边框的距离。不带px单位。父级没有带定位的就是到body的距离。 getAttribute()：获取元素的行内设置的属性值。参数是属性名。 setAttribute()：设置元素的行内设置的属性值。参数是属性名和属性值。 removeAttribute()：删除元素的行内设置的属性值。参数是属性名。 getBoundingClientRect()： 当前元素距离body的四个方向的距离和宽高的对象。获取的值会随着页面滚动位置而改变。值是不带单位的。 clientWidth：获取元素不计算边框的宽度。document.documentElement.clientWidth是浏览器窗口可是区域的宽度。 clientHeight：获取元素不计算边框的高度。document.documentElement.clientHeight是浏览器窗口可是区域的高度。 offsetWidth：获取元素计算边框的宽度。 offsetHeight：获取元素计算边框的高度。 操作节点document.createElement()：创建一个元素节点，参数是元素的名称，字符串格式。 appendChild()：将一个元素节点添加到另一个元素节点的最后，格式为父节点.appendChild(要添加的节点)。 insertBefore()：将一个元素节点添加到一个元素节点的指定子节点的前面。格式为父节点.insertBefore(要添加的节点,添加到这个节点之前)，假如第二个参数是不存在的，节点将会添加到父节点的最后。 removeChild()：删除一个指定的元素子节点，如果指定的节点找不到会报错。格式为父节点.removeChild(要删除的节点)。 replaceChild()：替换一个元素节点，格式是父节点.replaceChild(要添加的节点,被替换的节点)。 cloneNode()：克隆一个元素节点，默认只会克隆节点本身，不会克隆它的子节点，如果要将这个节点下的所有子节点也都克隆需要传参数true，格式为要克隆的节点.cloneNode(true)。 appendChild()、insertBefore()、replaceChild()在操作一个已有元素时，是将已有元素移动，而不是复制一份进行操作。 操作表格对于表格的操作javascript提供了一些简单的获取方式。 假设table是已经获取到的表格元素。 table.tHead：获取表格头部。 table.tFoot：获取表格底部。 table.tBodies：获取表格主体。 table.tBodiesn.rows[n]：获取表格的行，就是tr。 table.tBodiesn.rows[n].cells[n]：获取单元格，就是td。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript（时间、数组、字符串方法）]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%EF%BC%88%E6%97%B6%E9%97%B4%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
      <content type="text"><![CDATA[日期对象常用方法new Date() 获取当前时间 以下获取的都是数值类型，get是获取时间，将get改为set后面的不变就是设置时间。 getFullYear() 获取年 getMonth() 获取月份，从0开始算 getDate() 获取天 getDay() 获取星期几，0是周日 getHours() 获取小时 getMinutes() 获取分钟 getSeconds() 获取秒 getMilliseconds() 获取毫秒 getTime() 时间戳，返回从1970年1月1日0点0分0秒0毫秒开始计算的毫秒时间。 getTimezoneOffset() 获取本地时间与格林威治标准时间的分钟差。 parse() 返回从1970年1月1日到指定日期(字符串)的毫秒数。 UTC() 根据世界时间返回从1970年1月1日到指定日期(字符串)的毫秒数。 以上获取时间的方法在get后加上UTC就是根据世界时间获取，例如getUTCHours()就是根据世界时间返回小时数。 获取一个时间点设定一个时间点new Date(2017,4,22,22,48,20); 得出的是毫秒。 也可以通过new Date(&#39;November 10,2013 22:3:0&#39;);来获取。主要是用来计算倒计时用到。 秒的转换秒转为天：Math.floor(秒 / 86400) 秒转为小时：Math.floor(秒 % 86400 / 3600) 秒转为分钟：Math.floor(秒 % 86400 % 3600 / 60) 秒转为秒：秒 % 60 英文的月份一月 January、二月 February、三月 March、四月 April、五月 May、六月 June、七月 July、八月 August、九月 September、十月 October、十一月 November、十二月 December。 字符串的方法length字符串长度，字符串里的空格也占用一个长度 charAt()返回字符串索引位置的字符，如果不传参数默认获取第一个。 123var str = 'abs';alert(str.charAt(1)) // balert(str.charAt()) // a charCodeAt()返回字符串索引位置的字符的Unicode值。使用方法同上。 charCodeAt()使用方式和charAt相同，区别是返回的是字符的编码值 String.fromCharCode()参数里输入一个编码，返回相对应的字符，多个编码用逗号间隔 indexOf()返回查找字符在字符串中的索引位置，没找到返回-1。 &#39;str&#39;.indexOf(&#39;t&#39;) //1返回t在字符串str中的索引位置。 &#39;strstr&#39;.indexOf(&#39;t&#39;,2) // 4从strstr字符串的索引2的位置r之后开始找t的位置。不能是负数。 indexOf()每次只能返回查找到的第一个索引位置，如果要查找所有的索引位置需要写一个循环 1234567var str = 'aaabaaababaaaaaaaabaaab';var s = 'b';var i = 0;while( str.indexOf(s,i) != -1 )&#123; alert( str.indexOf(s,i) ); i = str.indexOf(s,i) + s.length;&#125; 这个循环会打印b在字符串中的所有索引位置 lastIndexOf()和indexOf()相对应，indexOf()是从左往右找，lastIndexOf()是从右往左找。第二个参数索引值也是从右向左查找。 字符串的大小比较中文字符也是可以进行比较的，比如&#39;山东&#39; &gt; &#39;青岛&#39;，比较的是第一个字符的编码值的大小，也就是山的编码值和青的编码值的比较，和后面的所有字符没有关系。 同样的道理，&#39;aaaabbbb&#39; &gt; &#39;c&#39;，比较的是a和c的大小，和后面字符没有关系。&#39;1000&#39; &gt; &#39;2&#39;比较的也是1和2的编码值的大小。 substring()截取类方法，对字符串当中的某些文字进行截取。负数会直接当0来处理。 传入一个参数时，从字符串的参数数值的索引位置开始截取后面的所有内容。 传入两个参数时，截取字符串参数一的索引到参数二的索引之间的字符。另外，如果第二个参数比第一个参数小那么会自动调换两个参数的位置。 123var str = 'abcdefg';alert(str.substring(4); // efg alert(str.substring(0,2); // ab slice()和substring()用法基本一样。但是传两个参数时不会交换位置。 和substring()方法不同的是： 只传入一个参数并且是负数，那么就是从字符串的最后开始截取。 传入两个参数，通常第一个是负数第二个也是负数，截取两个参数索引之间的字符 123var str = 'abcdefg';alert(str.slice(-1)) // falert(str.slice(-4,-2)) // cd toUpperCase()字符串转为大写，只能针对英文 toLowerCase()字符串转为小写，只能针对英文 split()将字符串分割为数组。参数是按照什么字符分割，如果不传参数默认会将整个字符串当做一个数组的一个元素。 12345var str = 'www.baidu.com';alert(str.split('.')) // ['www','baidu','com'];var str1 = 'abc';alert(str1.split('')) // ['a','b','c']; 第二个参数是限制截取多少段。 12var str = '2017-05-27-19-47';alert(str.split('-',3)); // ['2017','05','27'] replace()替换字符串，第一个参数是要查找的字符串，也可以通过正则表达式查找。第二个参数是要替换的内容。 123var str = 'abcdefg';console.log(str.replace('abc','ccc')) // 打印cccdefgconsole.log(str.replace(/^a/,'ccc')) // 打印cccbcdefg 数组的方法push()在数组最后一位添加一个元素，返回值是增加后的数组的长度。 unshift()在数组第一位插入一个元素，返回值是增加后的数组的长度。ie6、ie7不支持这个方法的返回值。 pop()从数组的最后删除一个元素，返回值是删除的那个元素。 shift()从数组的开头删除一个元素，返回值是删除的那个元素。 splice()splice方法可以删除、替换、添加 删除时候可以传两个参数，第一个是开始删除的索引，第二个是删除的长度。返回值是删除的元素。 替换的话将要替换的内容写在第二个参数之后。返回值仅是被删除的内容。 添加的时候第一个参数是要添加的后面那个元素的索引，第二个参数是0，代表不替换，要添加的元素写在第二个参数之后。没有返回值 1234var arr = ['a,'b','c','d','e'];arr.splice(0,2) // arr = ['c','d','e']arr.splice(0,2,'z','x') // arr = ['z','x','c','d','e']arr.splice(1,0,'x') // arr = ['a','x','b','c','d','e'] slice()返回从原数组中指定开始下标到结束下标之间的元素组成的新数组。只传一个参数那就是获取到最后，不会改变原数组 123var arr = [1,2,3,4,5,6];console.log(arr.slice(2)) // 打印[3,4,5,6]console.log(arr.slice(2,4)) // 打印[3,4] sort()对数组进行排序，默认全部按照字符串的规则进行排序，会将数字转为字符串，然后按照字符串的比较方式，由小到大排序。 12var arr = [4,3,2,30];arr.sort(); // arr = [2,3,30,4] 要按照数值类型来排序的话需要在sort内部写一个函数 1234arr = [4,3,2,30];arr.sort(function(a,b)&#123; return a - b&#125;) 这里用a-b代表从小到大排序，意思是第一个数减第二个数。 也可以b-a是从大到小排序。是第二个数减第一个数。 只要return 为true，那么就会换位置。 join()将数组转为字符串，用传入的参数去分割数组每个元素，组成一个字符串，如果不传参数默认用逗号分割。 concat()将多个数组拼接起来，参数可以传过个，传几个就连接几个，会拼成一个新的数组，不会改变原来的数组。 123var arr1 = [1,2,3];var arr2 = [4,5,6];alert(arr1.concat(arr2)); // [1,2,3,4,5,6] reverse()颠倒数组内部元素的位置。对字符串也可以进行操作，只是从头到尾颠倒位置。不会进行比较。 12var arr = [1,2,3,4];arr.reverse(); // arr = [4,3,2,1] toString()把数组转换为字符串，字符串包含逗号。 Math系列方法Math.round()对参数进行四舍五入操作。 Math.abs()返回参数的绝对值。 Math.ceil()对参数进行向上取整 Math.floor()对参数进行向下取整 Math.max()传两个参数，返回两数中的最高值 Math.min()传两个参数，返回两数中的最低值 Math.pow()传递两个参数，第二个参数是幂，返回第一个参数的几次幂 Math.sqrt()返回参数的平方根 Math.random()产生0-1之间的随机数 随机数方法经常使用，比如要生成5-10之间的随机数 当求一个x-y之间的数公式就是：Math.round( Math.random() * ( y - x ) + x ) 1Math.round( Math.random() * 5 + 5 ) 通常第二个数是区间中下限的数，第一个数是区间上限的数与第二个加的数的差值。现在生成的就是5-10之间的随机数，并且包括5和10本身，如果想不包含5那就调整第一个数，想不包含10那就调整第二个数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css杂记]]></title>
      <url>%2F2017%2F05%2F21%2Fcss%E6%9D%82%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[word-spacing 单词间距判断是否是单词的依据是有没有空格 行高的测量方式假如文字是12px，行高是16px，那么文字上下空隙分别是2px，假如行高是15px，那么上方是1px，下方是2px。 white-space 强制不换行值为nowrap为强制不换行，默认是normal。 text-indent 首行缩进。通常设置em，这样文字尺寸改变了也不用该缩进值，只需要设置2em便一直是2个字的距离。 文字和空格的大小字体本身原本是一张张的图片，通过一定的编码方式确定是哪个文字，文字和文字之间本身也有一定的缝隙，算上缝隙才算是一个文字的大小，所以文字大小最好是从上到下测量。而宋体中一个空格的大小差不多是一个文字的一半。 伪类的顺序a:link 未访问过,a:visited 访问过后,a:bover 鼠标移入,a:active 鼠标按下。 clear属性给一个元素加上clear属性，那么对应方向上的元素就不会浮动了。值可以设置为left|right|both|none|inherit。clear:both是左右两侧都不能浮动。 清除浮动的方法清除浮动是为了让元素回归文档流，回归到同一层级。 加高度给浮动元素的父元素加一个固定的高度。缺点是扩展性不好。有时候高度不能写死。 父级浮动给浮动元素的父元素加浮动，缺点是父元素的父元素仍然会有问题，当前元素的父元素同时也是更上级元素的子元素。而且margin:0 auto;会失效 inline-block给浮动元素的父元素加inline-block，缺点也是margin:0 auto;会失效 使用空白元素在浮动元素的后面增加一个没有内容的块级元素设置css为clear:both。缺点是只要清除浮动就要放一个空白元素，而且ie6仍会有2px的默认高度。 br在浮动元素后面增加一个&lt;br clear=&quot;all&quot; /&gt;。缺点也是只要清除浮动就要放一个空白元素。 伪类清除浮动假设浮动元素的父元素添加一个class名为clearfix。 12345678.clearfix &#123; *zoom:1;&#125;.clearfix:after &#123; content:&apos;&apos;; display:block; clear:both;&#125; zoom是为了兼容ie浏览器，当设置了zoom之后会检索设置对象的缩放比例，所设置的元素就会扩大或缩小，高度就被重新计算了，所以可以清除浮动，*号是hack的写法，只有ie6、7浏览器可以识别。 overflow给浮动元素的父元素设置overflow:hidden。原理是触发BFC。缺点是比浮动长的内容会被直接剪裁掉。 BFC和haslayoutBFC(block formatting context):BFC是块级元素格式化上下文。是标准浏览器块级元素的标准(除了ie6、7、8之外都是标准浏览器)。 haslayout:ie浏览器特有的。 只要触发了这两个其一，那么这个触发的区域就是一个独立的区域不受外界影响，也可以理解为元素就不会脱离标准文档流了。 触发BFC的情况 float的值不会none。 overflow的值不为visble(这就是overflow:hidden可以清楚浮动的原理，让其触发BFC)。 display的值为table-cell、table-caption、inline-block中的任何一个。 position的值不为relative和staic。 width|height|min-width|min-height的值不是auto的时候。 触发haslayout的情况 zoom的值不会normal的时候。给ie浏览器设置zoom:1清楚浮动就是为了触发haslayout。 css hack \9所有ie10及以下的浏览器。\9是写在属性值的后面。 *ie7及以下浏览器，写在属性的开头。 _ie6及以下浏览器，写在属性的开头。 hack的书写顺序要从高版本往低版本写，因为css是按照顺序执行，后面的覆盖前面的，所以先做统一处理，最后再去处理个别低版本浏览器。另外hack不是一个标准的方法，所以一般不要使用。 禁止选中文字不同的浏览器设置的内容不一样，user-select不是一个W3C的标准，浏览器的支持不完成，需要对不同的浏览器进行调整。 user-select有2个值（none表示不能选中文本，text表示可以选择文本） 123456789-moz-user-select:none; /*火狐*/-webkit-user-select:none; /*webkit浏览器*/-ms-user-select:none; /*IE10*/-khtml-user-select:none; /*早期浏览器*/user-select:none; ie6至ie9还没发现有css属性支持 opacity的兼容性opacity是设置透明度，标准写法是opacity:1;,兼容ie的写法是filter:alpha(opacity=100); 超出2行隐藏(强制2行)首先css有三个属性： overflow:hidden超出的内容隐藏。 text-overflow:ellipsis溢出用省略号显示 white-space:nowrap溢出不换行 这样只能强制一行显示，如果要强制2行显示要用css3的属性。 display:-webkit-box将对象作为弹性伸缩盒子模型显示 webkit-box-orient:vertical设置伸缩盒子的子元素排列方式(从上到下垂直排列子元素) -webkit-line-clamp:2显示的行数，不能单独出现。 最后css样式如下： 12345overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp:2; css命名参考头：header head 内容：content container 尾：footer 导航：nav navigation 侧栏：sidebar aside 栏目：column 页面外围控制整体布局宽度：wrapper wrap 左右中：left right middle center 登录条：login 标志：logo 广告：banner 页面主体：main body main-content page-main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu dropmenu 子菜单：submenu 标题：title ttl caption small-caption 摘要：summary 搜索：search 友情链接：friend-link flink 页脚：footer 版权：copyright 滚动：scroll 标签页：tab 文章列表：list 栏目标题：title 服务：service 注册：register 投票：vote 加入我们：joinus 状态：status status-bar 按钮：btn- 图标：ico- icon- 滚动：scroll 标签页：tab 文章列表：list 弹出层：pop popup 对话框：dialog dlg 状态提醒：success error alert notice caution 提示信息：msg message message-box 当前的：active act current curr selected on 小技巧：tips 注释：note notice 指南：guide 移动端弹窗时暴力禁止html滚动1234html.lock-html &#123; height: 100%; overflow: hidden;&#125; 实现文字竖向排版模拟竖排文字对文字对象的宽度设置只能排下一个文字的宽度距离，让文字一行排不下两个文字使其文字自动换行，就形成了竖立排版需求。 writing-mode属性writing-mode 有两套属性，一套是IE私有的，另一套是CSS规范属性。 CSS规范属性123writing-mode: horizontal-tb; /* 默认值 */writing-mode: vertical-rl;writing-mode: vertical-lr; vertical-rl 表示文本是垂直方向(vertical)展示，然后阅读的顺序是从右往左(rl:right-left)，跟我们古诗的阅读顺序一致。 vertical-lr 表示文本是垂直方向(vertical)展示，然后阅读的顺序还是默认的从左往右(lr:left-right)，也就是仅仅是水平变垂直。 IE私有属性1writing-mode: lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb IE下的属性特别多，但是需要关注的只有这几个： 如果是IE8及以上浏览器：lr-tb 、tb-rl 、tb-lr，分别对应于CSS规范中的 horizontal-tb 、vertical-rl 、vertical-lr`。 如果是IE7浏览器：lr-tb 和 tb-rl 分别对应CSS规范的 horizontal-tb 和 vertical-rl。 css的计算属性calc()calc() 可以使用百分比、em、px和rem单位值计算出一个值应用于元素上，这样一来你就不用考虑元素DIV的宽度值到底是多少，而把这个烦人的任务交由浏览器去计算。比如说“width:calc(50% + 2em)”。 calc() 的表达式都写在括号里，支持四则运算，运算符前后要加空格，在IE浏览器只能兼容到IE9。这个属性最大的用处就不使用box-sizing 的情况下，元素的宽度如果设置为 100% 之后再设置 margin 、 padding、border 会导致元素实际宽度大于100%，而使用clae() 属性可以解决计算的麻烦，直接可以写为 width: calc( 100% - margin * 2 - padding * 2 - border * 2 )即可算出盒子的实际宽度并应用于元素。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记]]></title>
      <url>%2F2017%2F05%2F21%2Fjavascript%E6%9D%82%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[this的基本用法首先有一个函数 123function fn1()&#123; alert(this);&#125; 直接调用则this指向window 1fn1(); // 指向window; 如果是被元素对象调用 123456div.onclick = function()&#123; var _this = this; // 这个this指的就是div元素对象 fn1(); // 这里打印的this值的就是window，因为上面fn1函数的环境就是在全局，所以如果直接调用函数，那么this都是window&#125;div.onclick = fn1; // 这里打印的this就是div元素对象，这里已经改变了fn1函数的环境，赋值给了div元素对象的事件属性中，环境自然也从全局变为div元素对象。 判断浏览器名称123456789101112131415161718function myBrowser()&#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 if (userAgent.indexOf("Opera") &gt; -1) &#123; //判断是否Opera浏览器 return "Opera" &#125;; if (userAgent.indexOf("Firefox") &gt; -1) &#123; //判断是否Firefox浏览器 return "FF"; &#125;; if (userAgent.indexOf("Chrome") &gt; -1)&#123; //判断是否Chrome浏览器 return "Chrome"; &#125; if (userAgent.indexOf("Safari") &gt; -1) &#123; //判断是否Safari浏览器 return "Safari"; &#125; if (userAgent.indexOf("compatible") &gt; -1 &amp;&amp; userAgent.indexOf("MSIE") &gt; -1) &#123; //判断是否IE浏览器 return "IE"; &#125;;&#125; 火狐浏览器禁止页面滚动12345if (navigator.userAgent.toLowerCase().indexOf('firefox')&gt;=0)&#123; if (e.preventDefault) e.preventDefault(); e.returnValue = false;&#125; 鼠标滚轮事件非FireFox浏览器是使用onmousewheel事件，而FireFox浏览器使用DOMMouseScroll事件。 非FireFox浏览器使用的是wheelDelta方法判断滚动方向，FireFox浏览器使用的是detail方法判断滚动方向。 wheelDelta:-120和detail:3 代表向下滚动。wheelDelta:120和detail:-3代表向上滚动。 12345678document.body.onmousewheel = function(event) &#123; event = event || window.event; console.log(event.wheelDelta)&#125;;document.body.addEventListener("DOMMouseScroll", function(event) &#123; console.log(event.detail)&#125;); jquery兼容性的滚轮事件12345678910111213$('#scrollSelect-view').on("mousewheel DOMMouseScroll", function (e) &#123; var delta = (e.originalEvent.wheelDelta &amp;&amp; (e.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) || // chrome &amp; ie (e.originalEvent.detail &amp;&amp; (e.originalEvent.detail &gt; 0 ? -1 : 1)); // firefox if (delta &gt; 0) &#123; // 向上滚 console.log("wheelup"); &#125; else if (delta &lt; 0) &#123; // 向下滚 console.log("wheeldown"); &#125;&#125;); 自定义属性有时候写方法时会定义大量变量，有的变量其实比较多余，很多数据可以存储到元素对象的自定义属性中去。这样不用去考虑作用域的问题，因为只要这个元素对象存在在这个方法内就可以去使用，但是最好只保存和这个元素对象有关的属性。 比如：下面代码就是，在事件处理函数内部只能获取i循环完毕之后的值，而通过把i的值作为元素对象的自定义属性赋值，就没有作用域的限制。 1234567for(var i = 0; i &lt; 5; i++) &#123; div.index = i; div[i].onclick = function()&#123; alert(i); alert(this.index); &#125;&#125; 排他思想和清空上一个排他通常在tab栏切换中经常用到排他，比如有10个选项，只有当前项才有背景色，通常颜色是通过一个类名挂钩到css中去设置的，那么排他就是每次先将所有导航选项的类名清空，然后只给当前点击的这个元素对象添加类名。 1234567891011for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始排他 for(var i = 0; i &lt; Lis.length;i++)&#123; Lis[i].className = ''; &#125; // 单独设置当前选项 Lis[this.index].className = 'active'; &#125;;&#125;; 清空上一个这种效果除了排他之外还可以通过清除上一个选项来完成。创建一个变量存储上一个选中元素，在点击当前元素时候清空上一个类名，之后把自己赋值给这个变量，如此每次只需要清空一个元素的类名即可。 1234567891011121314var oElem = null;// 初始化，默认第一个元素是当前项Lis[0].className = 'active';Elem = Lis[0];for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始清空上一个 Elem.className = ''; Elem = this; Lis[this.index].className = 'active'; &#125;;&#125;; jquery的stop()方法$(selector).stop(stopAll,goToEnd) stopAll 可选。规定是否停止被选元素的所有加入队列的动画。 goToEnd 可选。规定是否允许完成当前的动画。该参数只能在设置了 stopAll 参数时使用。 使用懒加载插件使用的 jquery.lazyload 调用下载好的插件 123456$(function()&#123; $("img.imglazyload").lazyload(&#123; threshold : 200, effect : "fadeIn" &#125;);&#125;); html部分，一定要在外层包一个div并且设置宽高，不要用图片去撑开。 123&lt;div class="item-image"&gt; &lt;img class="imglazyload" data-original="图片地址"&gt;&lt;/div&gt; js中的NaN NaN是一个数字类型但不是一个数值。 出现NaN肯定是进行了非法操作而不是获取数值有错，如果获取数值有错是undefind。 NaN与自己本身也是不相等的。 NaN转为布尔是false。 NaN本身的意思是’不是一个数值’ isNaN可以判断某些类型是不是一个数字类型。如果判断到是一个数字为false(不是一个数值这个判定是错的)，而不是数字类型的是true(不是一个数值这个判定是对的)。 NaN在判断时是在内部使用Number()方法转换，所以是不是数字类型的依据主要是看Number()转出的是什么类型。比如布尔值、空字符串、字符串数字都会被认为是数字类型而返回false。 js的作用域基础作用域实际上是浏览器js解析器的一种工作方式。 浏览器的js解析器在读取javascript代码时会先提升变量和函数，再去逐行解读代码。这是每个作用域的解析步骤。 预解析根据var、function、参数 找一些东西。 首先js解析器会搜索所有var和function找到所有变量，var声明的变量提升时值都是未定义，提升function时候会将整个函数代码块一起提升。 当var和function重名时，会保留function，覆盖var,但是如果两个以上同名的function，那么就看声明的先后顺序了。 逐行解析变量提升之后，js解析器会开始逐行解析代码，这时只有表达式可以改变变量的值，用下边的案例来说明。 1234567891011alert(a); // function a()&#123;alert(4);&#125;var a = 1;alert(a); // 1function a()&#123;alert(2);&#125;alert(a); // 1var a = 3;alert(a) // 3function a()&#123;alert(4);&#125;alert(a); // 3a(); // 报错 第一个alert打印出函数的原因是变量提升的规则，后面的a打印的都是变量的值而不是函数，因为变量赋值是一种表达式，而函数只是一个声明并不是表达式。并且因为现在a是一个数值，所以调用时自然会报错。 多组script自上而下的作用域大部分指的是多组script标签，如下代码 12345678910&lt;script&gt; alert(a); // 报错&lt;/script&gt;&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; alert(a); // 1&lt;/script&gt;/ 如果碰到这种情况，js解析器会对每个script代码块进行独立预解析和逐行解析，第一块script的代码还没声明a，第二块script的代码声明和赋值了，这时到第三块script代码块时a已经声明并赋值了，所以直接会打印1。 函数由内而外主要指函数，一个函数也是一个单独的作用域，javascript中，函数是唯一能分隔作用域的。 1234567var a = 1;function fn1()&#123; alert(a); var a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1()&#123; alert(a); a = 2;&#125;fn1(); // 1alert(a); // 2 第一个例子中在函数内部声明了a，那么在fn1中的a变量就和上级作用域的a变量没有任何关系了。按照预解析的步骤这里打印的是undefined。 第二个例子没有声明a变量，所以在fn1作用域中就找不到a，这时就会去上级作用域中寻找，上级作用域声明了a并且赋值为1了，所以打印1。 如果是下面这种情况 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(a); // 1alert(a); // 2 参数其实就是一个局部变量，第一个例子没有传参，参数就相当于var a; 第二个例子传了参数就相当于var a = 1; 一个函数的解析顺序是先从参数开始的。 下面看一个最常见的案例 12345for(var i = 0; i &lt; 3; i++)&#123; btn[i].onclick = function()&#123; alert(i); // 3 &#125;&#125; 最开始我以为这里打印的i是会随着遍历打印出0,1,2的，但实际上onclick函数中相当于一个独立的作用域，这个作用域中没有声明i变量，所以就要去上级作用域去获取，那为什么是3呢，因为函数只有在点击时才会调用，只有调用时才会发生预解析和逐步解析，这时去获取i的值上级作用域早已遍历完毕。 js运算符%取余的应用下面的例子中要在li元素中添加背景色，颜色存储在arr数组。如果不用取余运算符只能写两层for循环，而使用取余运算，可以直接让取余后的值自己循环。 arr的长度是3，i是0开始每次+1，那么arr数组每次的索引就是：arr[0%3=0],arr[1%3=1],arr[2%3=2],arr[3%3=0],arr[4%3=1],arr[5%3=2],arr[6%3=0]，这样就达到了遍历颜色数组的目的。这种操作很适合于在一个数组的遍历内部又需要遍历另外一个数组的情况。 12345var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];for(var i = 0; i &lt; li.length; i++)&#123; li[i].style.backgroundColor = arr[i%arr.length];&#125; 下面扩展一下这个案例，加上任意li元素点击后变色，再去点击另一个li，另一个li元素变色，上一个li元素变回原来的颜色。通常这种功能会用排他来做，这次不用排他，使用取余操作来写。 12345678910111213141516var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];var elem = null;for(var i = 0; i &lt; li.length; i++)&#123; li[i].index = i; li[i].style.backgroundColor = arr[i%arr.length]; li[i].onclick = function()&#123; if(elem)&#123; elem.style.backgroundColor = arr[elem.index%arr.length]; &#125; elem = this; this.style.backgroundColor = 'gray'; &#125;&#125; 排他是将所有li元素变色，再去更改当前点击的元素的背景色，而这种思路是记录上一次点击的元素，在下一次点击时只改变上一次点击的元素的背景色就可以了。这里elem.index和i的作用是相同的。 另外取余操作还可以换算时间，比如现在要将70秒转为分钟，那么可以这样写 12var s = 70;var m = Math.floor( 70/60 + '分' + 70%60 + '秒'); js获取浏览器计算后的属性值像width或者height这种属性直接获取只能得到行内样式，如果不写在行内就获取不到，使用getComputerStyle可以获取浏览器计算后的样式，也就是被浏览器渲染之后得到的元素实际的属性的值。格式是getComputerStyle(element).width; 但是这个方法在ie6、7、8不兼容。这三个非标准浏览器使用的currentStyle属性。格式是element.currentStyle.width;。 不要用这两个方法去获取没有设置过的属性。 不能用这两个属性去获取复合样式，比如要获取背景色不要用background而是要用backgroundColor，不论css是怎么写的，都要写具体的属性。因为如果写background的话会获取到所有这个属性可以设置的属性值，如果css没写的会获取到默认的。 另外在firefox浏览器4.0版本之前，getComputerStyle的参数要写两个，第二个参数可以随便写比如getComputerStyle(element,&#39;&#39;).width;或getComputerStyle(element,true).width;，总之只要写一个参数就可以。 jq中的即使搜索事件在jq中实现input搜索框的即时搜索和其他即时性的改变需要用到input和propertychange(兼容ie8及以下浏览器)事件。 input是标准的浏览器事件，一般应用于input元素，当input的value发生变化就会发生，无论是键盘输入还是鼠标黏贴的改变都能及时监听到变化。 propertychange只要当前对象属性发生改变都会触发，所以使用propertychange时最好排除一下不想触发事件的元素。 window.parent在b.html页面使用iframe的时候，引入一个Html页面名称暂定为a.html，呢么在a.html中，window指的是a的window对象，而window.parent指的就是b.html的window对象。 监听DOM树加载完成的事件DOM的加载顺序： 解析HTML结构。 加载外部脚本和样式表文件。 解析并执行脚本代码。 构造HTML DOM模型。 加载图片等外部文件。 页面加载完毕 DOMContentLoaded事件 可以在DOM模型加载完成后就执行代码，而不用等到加载完图片或外部文件 移动端获取屏幕的宽高document.documentElement.clientWidth 和 document.documentElement.clientHeight这个得到的是设备像素可见宽高，比如iPhone 5里为320和504。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》一、DOM]]></title>
      <url>%2F2017%2F04%2F13%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%B8%80%E3%80%81DOM%2F</url>
      <content type="text"><![CDATA[1、DOM的含义 文档(D)，指的是document，当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生，DOM把我们编写的网页文档转换为一个文档对象。 对象(O)，指的就是javascript中的三种对象，用户定义对象、内建对象、宿主对象。 模型(M)，可以理解为模型Model或者地图Map，我们可以通过javascript代码来读取这张地图。 要理解模型或者地图的概念，首先我们要理解DOM是把一份文档表示为一棵树。以下面文档为例。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt; &lt;head&gt; &lt;meta charset = "utf-8"&gt; &lt;title&gt;Shopping list&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;What to buy&lt;/h1&gt; &lt;p title = "a gentle reminder"&gt;Don't forget to buy this stuff&lt;/p&gt; &lt;ul id = "purchases"&gt; &lt;li&gt;A tin of beans&lt;/li&gt; &lt;li class = "sale"&gt;Cheese&lt;/li&gt; &lt;li class = "sale"&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 上面的一长串代码可以理解为以下的DOM树 从上图可以看出，html永远是一个文档的开始，可以看作是树根，再深一层就是head和body，它们位于一层，所以是兄弟关系(sibling)，它们都有各自的子元素(child)，有着共同的父元素(parent)。 实际上用parent、silbling、child就可以代表整个DOM树的结构，比如ul是ul是body的child元素，而ul又是li的parent元素，ul和p是sibling元素，并且这棵树上的每个元素都是一个DOM节点。 2、节点上面介绍了DOM的概念，由图也可以看出，DOM树是由一个个节点组成的，这些就是DOM节点。分为三种类型。 元素节点 标签的名字就是元素节点，例如”p”、”ul”、”body”等等。 文本节点 被元素包括的文本内容就是文本节点，比如上面文档中被包含的”A tin of beans”。 属性节点 属性节点用来对元素做出更具体的描述，比如的title属性，也包括id和class属性，属性节点也总是被包含在元素节点内部。 那么我们如何区分这三种节点呢？可以使用nodeType属性。nodeType属性总共有12种可取值，但其中仅有3种有实用价值。 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 实际使用中可以通过元素对象的nodeType属性值来判断节点类型。 3、获取元素有3种DOM方法可以获取元素节点，分别是通过元素id、通过标签名、通过class获取。 通过id名获取这个方法将返回一个与给定id属性值的元素节点对应的元素对象，它是document对象特有函数。1document.getElementById(&apos;box&apos;); 获取id属性值是’box’的元素对象。 这里一直再说元素对象这个概念，其实就是指的html元素，但是在DOM里html元素都是DOM节点。而DOM节点本身就是一个对象，所以叫做元素对象。另外函数和方法其实也是一个概念，对象的方法其实就是一个函数。 通过标签名获取这个方法返回一个对象数组，与getElementById不同的是，这个返回的是一个数组，返回的数组中，每个元素都是获取到的元素对象，可以用length属性查出这个数组的长度。 1document.getElementsByTagName('li'); 这个方法允许把一个通配符作为它的参数，可以获取文档里的所有元素，也可以和getElementById结合使用 12var box = document.getElementById('box');var lis = box.getElementsByTagName('*'); 这样可以获取id为box的元素下的所有元素对象。 通过class获取这是HTML5中新增的方法，可以通过class名获取元素，返回的也是一个对象数组。 1document.getElementsByClassName('sale important'); 获取class属性为sale和important的元素对象，这个元素必须同时有这两个class名，顺序无所谓。也可以和getElementById结合使用。 12var box = document.getElementById('box');var sales = box.getElementsByClassName('sale'); 获取id值为box的元素下的所有class名为sale的元素。 需要注意的是这个方法比较新，所以用的时候要小心，为了弥补这个不足，我们可以自己封装一个获取class名的方法以适用于旧版浏览器。 获取class名的兼容性处理 1234567891011121314function getElementsByClassName(node, className) &#123; if (node.getElementsByClassName) &#123; return node.getElementsByClassName(className); &#125; else &#123; var results = new Array(); var elems = node.getElementsByClassName('*'); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(className) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 这个函数接收两个参数，node表示搜索起点，className是要搜索的class名，这个方法不足的地方是不适用多个class名。 4、获取和设置属性已经了解了三种获取元素节点的方法，现在可以去获取它们的属性。 获取属性1234567var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; var title_text = paras[i].getAttribute('title'); if(title_text != null)&#123; alert(title_text); &#125;&#125; getAttribute用于获取属性，需要用元素节点去调用，参数是要获取的属性名，如果调用的元素节点里没有要查找的属性就会返回null。 设置属性12345var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; paras[i].setAttribute('title','brand new title text'); alert(paras[i].getAttribute('title'));&#125; setAttribute用于设置属性，不管调用的元素原来有没有设置的属性，最终都会被设置上，用setAttribute对文档做出修改后，在浏览器中查看源代码仍是改变前的属性，这就是DOM的工作模式，对页面内容更新却不需要在浏览器里刷新。]]></content>
    </entry>

    
  
  
</search>
