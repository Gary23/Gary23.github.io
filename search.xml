<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[javascript杂记四]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%E6%9D%82%E8%AE%B0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[BOM操作的常用属性和方法open()：打开一个新的页面，格式为open(页面的url,打开的方式)，如果url为空则打开一个空白页面。如果打开方式为空，默认为新窗口方式打开。这个方法返回新窗口的window对象。 close()：关闭一个页面，但是这个方法有点兼容性问题，firefox默认无法关闭，chrome默认直接关闭，ie：询问用户。 navigator.userAgent：返回浏览器的名称和版本。 location：浏览器地址信息，本身不是字符串，是object格式。 location：就是url地址本身。 location.search：url中?后面的内容。 location.hash：url中#后面的内容。 窗口尺寸与大小可视区的尺寸：document.documentElement.clientWidth和document.documentElement.clientHeight。 滚动条滚动的距离：document.documentElement.scrollTop和document.documentElement.scrollLeft。在chrome浏览器中要使用document.body.scrollTop和document.body.scrollLeft。 元素内容的宽高：div.scrollHeight和div.scrollWidth。 文档的宽高：document.documentElement.offsetHeight和document.documentElement.offsetWidth。也可以使用document.body.offsetHeight和document.body.offsetWidth。 事件onscroll：当滚动条滚动的时候触发。 onresize：当浏览器尺寸改变的时候触发。 onfocus：当元素获取焦点时触发。 onblur：当元素失去焦点时触发。 focus()：给元素设置焦点。 blur()：让元素失去焦点。 select()：选择指定元素里面的文本内容。只能选择用户可以输入的内容。 onmousemove：鼠标在一个元素上移动时触发。 onkeydown：当键盘按键按下的时候触发。能够响应用户输入的元素才支持键盘事件，和焦点事件一样。如果按下不抬起来会连续触发。 onkeyup：当键盘按键抬起时触发。 oncontextmenu：当右键菜单显示出来时触发。 event事件对象：当一个事件发生时，这个对象发生的这个事件有关的一些详细的信息都会临时保存到event对象中，以便在需要时使用。 事件绑定标准浏览器的方法：div.addEventListener(事件名称，事件处理函数，捕获/冒泡);。false是冒泡，true是捕获。 有捕获。 事件名称没有on。 this指向调用该函数的对象。 事件执行的顺序是正序。 非标准浏览器方法：div.attachEvent(&#39;on&#39;+事件名称，事件处理函数); 没有捕获。 事件名称有on。 this指向window(可以通过call()来解决这个问题)。 事件执行的顺序是倒序。 事件取消非标准浏览器方法：div.dettachEvent(&#39;on&#39;+事件名称,事件处理函数); 标准浏览器方法：div.removeEventListener(事件名称，事件处理函数，捕获/冒泡) 事件流事件流和样式位置没关系，和html的结构有关系 事件冒泡：当一个元素接收到事件的时候，会把它接收到的所有事件传播给它的父级，一直到顶层(window)。父级元素只要有相关的事件处理函数，那么就会被执行。阻止冒泡设置事件函数：event.cancelBubble = true; 冒泡最主要的作用是父元素和子元素都需要的事件处理函数，只需要绑定给父元素就可以了，而如果希望只有子元素才执行的事件处理函数可以通过设置阻止冒泡来接解决。 事件捕获：捕获和冒泡相反，是从最外层元素传播到目标元素。其他并没什么不同。 控制事件是捕获还是冒泡是由addEventListener中的第三个参数决定的，false为冒泡事件监控是出去的由内向外的，true为捕获事件监控是进来的由外向内的。 cookiecookie的作用就是存储数据。长时间去保存一个值，比如用户上次访问的时间等。 当用户访问了某个网站时候，可以通过cookie向访问者的电脑上存储数据，每个浏览器存储的位置不同，所以不同浏览器存储的cookie不能互相通用。 cookie的存储是以域名的形式区分的，也就是说每个网站的cookie文件是不同文件夹存放的，一个域名下的cookie也可能有多个文件。所以每个cookie文件是可以设置名字的。否则cookie文件会很大很乱。 document.cookie = &#39;username=ypj&#39;;这就设置了一个cookie文件的名字和值。 document.cookie;读取当前网站下的下所有的cookie的内容，是字符串格式。 一个域名下存放cookie的个数是有限制的，不同浏览器存放的个数不同。 每个cookie存放的内容大小也是有限制的，也是根据浏览器不同限制也不同。 默认情况下，cookie的周期是整个浏览器结束进程的时候。 如果想长时间存放一个cookie，需要在设置这个cookie的时候同时给他设置一个过期的时间。当过期后cookie就会被销毁。 123var oDate = new Date();oDate.setDate(oDate.getDate() + 5); // 保存5天document.cookie = 'username=ypj;expires=' + oDate.toGMTString() // 将oDate又object转为string; cookie在存储特殊字符的时候可能会出现问题，需要通过encodeURI()编码来解决。解码使用decodeURI()方法。参数都是字符。 用js读取cookie时候只能获取整个字符串，没法直接获取某个cookie的键值，同样设置的时候也不方便，所以可以写两个方法来方便操作。 获取cookie 123456789function getCookie(key)&#123; var arr1 = document.cookie.split(';'); for(var i = 0;i &lt; arr1.length;i++)&#123; var arr2 = arr1[i].split('='); if(arr2[0] == key)&#123; return decodeURI(arr[1]); &#125; &#125;&#125; 设置cookie 12345function setCookie(key,value,t)&#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + t); document.cookie = key + '=' + value + ';expires=' + oDate.toGMTString();&#125; 删除cookie 123function removeCookie(key)&#123; setCookie(key,'',-1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo配置]]></title>
      <url>%2F2017%2F06%2F01%2Fhexo%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[安装hexo安装过程使用以下命令下载hexo $ npm install hexo-cli -g 如果在安装过程中遇到以下错误 ERROR Deployer not found : github 则运行以下命令,或者你直接先运行这个命令更好。 $ npm install hexo-deployer-git --save 新建hexo的文件夹，以后的博客相关的操作都在这个文件夹里边，不要有中文目录。在该文件夹内部执行下面命令 $ hexo init 安装依赖包 $ npm install hexo常用的命令 $ hexo g 完整命令为hexo generate，用于生成静态文件。 $ hexo s 完整命令为hexo server，用于启动服务器，主要用来本地预览。 $ hexo d 完整命令为hexo deploy，用于将本地文件发布到github上。 $ hexo n 完整命令为hexo new，用于新建一篇文章。 查看hexo的本地服务器网页 http://localhost:4000/ 连通githubgithub中的项目名称必须是name.github.io格式 编辑本地hexo目录下的_config.yml文件。以下配置的name要改成自己的 1234deploy: type: git repository: http://github.com/name/name.github.io.git branch: master 配置好之后使用$ hexo g和$ hexo d发布到github。第二个命令会要求输入github的账号密码。如果成功的话打开name.github.io就可以查看博客了。 最好已经搞定了ssh配置，否则每次都要输入密码。 正式发布博客按照自己的意愿修改完后，执行$ hexo g，$ hexo s，打开localhost:4000看看效果。 新建一篇博客$ hexo new &quot;my new post&quot; 在\hexo\source\_post中打开my-new-post.md，开始编辑。 1234567title: my new post #可以改成中文的，如“新文章”date: 2015-04-08 22:56:29 #发表日期，一般不改动categories: blog #文章文类tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt;#在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，使用$ hexo g生成静态文件。$ hexo s在本地预览效果。$ hexo d同步到github，然后使用http://name.github.io进行访问。 清除缓存清除缓存文件db.json和已生成的静态文件public。如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 $ hexo clean 文章的各种格式https://hexo.io/zh-cn/docs/tag-plugins.html next主体设置下载主题$ cd your-hexo-site打开电脑的hexo站点目录。$ git clone https://github.com/iissnan/hexo-theme-next themes/next 在hexo的配置文件中设置theme: next。 主题设定在主题配置文件中可以设置三种主题。 1scheme: Muse || Mist || Pisces 语言设置在hexo配置文件中设置language: zh-Hans。这是简体中文，英文是en。 设置菜单菜单设置包括三个部分，菜单项、菜单项显示文本、菜单项对应图标。在主题配置文件中设置 1234567menu: home: / #主页 archives: /archives #归档页 #about: /about #关于页 categories: /categories #分类页 tags: /tags #标签页 commonweal: /404.html #公益404 现在菜单的文字是固定的，如果要修改文字要打开themes\next\languages\zh-Hans.yml去设置对应中文名称，也可以新建。 图标设置在主题配置文件下,与菜单设置一一对应。 123456789menu_icons: enable: true # Icon Mapping. home: home #about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置侧栏通过修改主题配置文件控制侧栏行为，一个是侧栏位置，一个是侧栏显示时机。 侧栏位置： 12sidebar: position: left 侧栏的行为 12sidebar: display: post #目录列表时显示 || always #一直显示 || hide # 一直隐藏 || remove #完全移除 设置头像主题配置文件中 1avatar: /images/avatar.png # 路径是next/source/images/ 昵称和描述站点配置文件中author参数是昵称，description参数是站点的描述 设置字体在主题配置文件中查找font字段修改。各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组： 非代码类字体：Fallback 到 “PingFang SC”, “Microsoft YaHei”, sans-serif 代码类字体： Fallback 到 consolas, Menlo, “PingFang SC”, “Microsoft YaHei”, monospace 添加菜单栏的页面打开hexo的目录站点下，运行hexo new page categories，这样就新建了categories页面，其他菜单类似，新建之前先去删除之前的。 侧边栏社交在主题配置文件中设置 设置显示文本和链接地址 123social: GitHub: https://github.com/your-user-name 微博: http://weibo.com/your-user-name 设定链接的图标 123social_icons: GitHub: github 微博: weibo 设置友情链接 1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ ### 设置动画效果 在主题配置文件中设置，要等到js加载完才会显示动画和内容。 12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 设置动画背景自带两种动画效果，在主题配置文件中设置 1234567# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画 添加百度/谷歌/本地 自定义站点内容搜索安装 hexo-generator-searchdb，在站点的根目录下执行以下命令npm install hexo-generator-searchdb --save hexo站点配置文件新增配置 12345search: path: search.xml field: post format: html limit: 10000 主题站点配置文件设置 123# Local searchlocal_search: enable: true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记三]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%E6%9D%82%E8%AE%B03%2F</url>
      <content type="text"><![CDATA[DOM操作的一些常用属性和方法元素节点的nodeType是1 属性节点的nodeType是2 文本节点的nodeType是3 节点的获取childNodes：获取某个元素下的所有子节点，包含文本节点和元素节点。 children：获取某个元素下的所有元素子节点。 nextElementSibling：获取元素的下一个兄弟元素节点。 previousElementSibling：获取元素的上一个兄弟元素节点。 firstElementChild：获取元素下的第一个元素子节点。 lastElementChild：获取元素下的第一个元素子节点。 parentNode：获取元素的父节点。 nodeValue：查看节点的属性值。 nodeName：查看节点的属性名。 nodeType：查看节点的类型。 属性的获取和设置offsetParent：获取最近有定位属性的祖先节点。如果没有直接获取body。 offsetLeft：左外边框到有定位的最近的父级元素的内边框的距离。不带px单位。父级没有带定位的就是到body的距离。 offsetTop：上外边框到有定位的最近的父级元素的内边框的距离。不带px单位。父级没有带定位的就是到body的距离。 getAttribute()：获取元素的行内设置的属性值。参数是属性名。 setAttribute()：设置元素的行内设置的属性值。参数是属性名和属性值。 removeAttribute()：删除元素的行内设置的属性值。参数是属性名。 getBoundingClientRect()： 当前元素距离body的四个方向的距离和宽高的对象。获取的值会随着页面滚动位置而改变。值是不带单位的。 clientWidth：获取元素不计算边框的宽度。document.documentElement.clientWidth是浏览器窗口可是区域的宽度。 clientHeight：获取元素不计算边框的高度。document.documentElement.clientHeight是浏览器窗口可是区域的高度。 offsetWidth：获取元素计算边框的宽度。 offsetHeight：获取元素计算边框的高度。 操作节点document.createElement()：创建一个元素节点，参数是元素的名称，字符串格式。 appendChild()：将一个元素节点添加到另一个元素节点的最后，格式为父节点.appendChild(要添加的节点)。 insertBefore()：将一个元素节点添加到一个元素节点的指定子节点的前面。格式为父节点.insertBefore(要添加的节点,添加到这个节点之前)，假如第二个参数是不存在的，节点将会添加到父节点的最后。 removeChild()：删除一个指定的元素子节点，如果指定的节点找不到会报错。格式为父节点.removeChild(要删除的节点)。 replaceChild()：替换一个元素节点，格式是父节点.replaceChild(要添加的节点,被替换的节点)。 cloneNode()：克隆一个元素节点，默认只会克隆节点本身，不会克隆它的子节点，如果要将这个节点下的所有子节点也都克隆需要传参数true，格式为要克隆的节点.cloneNode(true)。 appendChild()、insertBefore()、replaceChild()在操作一个已有元素时，是将已有元素移动，而不是复制一份进行操作。 操作表格对于表格的操作javascript提供了一些简单的获取方式。 假设table是已经获取到的表格元素。 table.tHead：获取表格头部。 table.tFoot：获取表格底部。 table.tBodies：获取表格主体。 table.tBodiesn.rows[n]：获取表格的行，就是tr。 table.tBodiesn.rows[n].cells[n]：获取单元格，就是td。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记二]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%E6%9D%82%E8%AE%B02%2F</url>
      <content type="text"><![CDATA[日期对象常用方法new Date() 获取当前时间 以下获取的都是数值类型。 getFullYear() 获取年 getMonth() 获取月份，从0开始算 getDate() 获取天 getDay() 获取星期几，0是周日 getHours() 获取小时 getMinutes() 获取分钟 getSeconds() 获取秒 getTime() 时间戳，返回从1970年1月1日0点0分0秒0毫秒开始计算的毫秒时间。 获取一个时间点设定一个时间点new Date(2017,4,22,22,48,20); 得出的是毫秒。 也可以通过new Date(&#39;November 10,2013 22:3:0&#39;);来获取。主要是用来计算倒计时用到。 毫秒的转换毫秒转为天：Math.floor(毫秒 / 86400) 毫秒转为小时：Math.floor(毫秒 % 86400 / 3600) 毫秒转为分钟：Math.floor(毫秒 % 86400 % 3600 / 60) 毫秒转为秒：毫秒 % 60 英文的月份一月 January、二月 February、三月 March、四月 April、五月 May、六月 June、七月 July、八月 August、九月 September、十月 October、十一月 November、十二月 December。 字符串的方法length字符串长度，字符串里的空格也占用一个长度 charAt()返回字符串索引位置的字符，如果不传参数默认获取第一个。 123var str = 'abs';alert(str.charAt(1)) // balert(str.charAt()) // a charCodeAt()使用方式和charAt相同，区别是返回的是字符的编码值 String.fromCharCode()参数里输入一个编码，返回相对应的字符，多个编码用逗号间隔 indexOf()返回查找字符在字符串中的索引位置，没找到返回-1。 &#39;str&#39;.indexOf(&#39;t&#39;) //1返回t在字符串str中的索引位置。 &#39;strstr&#39;.indexOf(&#39;t&#39;,2) // 4从strstr字符串的索引2的位置r之后开始找t的位置。不能是负数。 indexOf()每次只能返回查找到的第一个索引位置，如果要查找所有的索引位置需要写一个循环 1234567var str = 'aaabaaababaaaaaaaabaaab';var s = 'b';var i = 0;while( str.indexOf(s,i) != -1 )&#123; alert( str.indexOf(s,i) ); i = str.indexOf(s,i) + s.length;&#125; 这个循环会打印b在字符串中的所有索引位置 lastIndexOf()和indexOf()相对应，indexOf()是从左往右找，lastIndexOf()是从右往左找。第二个参数索引值也是从右向左查找。 字符串的大小比较中文字符也是可以进行比较的，比如&#39;山东&#39; &gt; &#39;青岛&#39;，比较的是第一个字符的编码值的大小，也就是山的编码值和青的编码值的比较，和后面的所有字符没有关系。 同样的道理，&#39;aaaabbbb&#39; &gt; &#39;c&#39;，比较的是a和c的大小，和后面字符没有关系。&#39;1000&#39; &gt; &#39;2&#39;比较的也是1和2的编码值的大小。 substring()截取类方法，对字符串当中的某些文字进行截取。负数会直接当0来处理。 传入一个参数时，从字符串的参数数值的索引位置开始截取后面的所有内容。 传入两个参数时，截取字符串参数一的索引到参数二的索引之间的字符。另外，如果第二个参数比第一个参数小那么会自动调换两个参数的位置。 123var str = 'abcdefg';alert(str.substring(4); // efg alert(str.substring(0,2); // ab slice()和substring()用法基本一样。但是传两个参数时不会交换位置。 和substring()方法不同的是： 只传入一个参数并且是负数，那么就是从字符串的最后开始截取。 传入两个参数，通常第一个是负数第二个也是负数，截取两个参数索引之间的字符 123var str = 'abcdefg';alert(str.slice(-1)) // falert(str.slice(-4,-2)) // cd toUpperCase()字符串转为大写，只能针对英文 toLowerCase()字符串转为小写，只能针对英文 split()将字符串分割为数组。参数是按照什么字符分割，如果不传参数默认会将整个字符串当做一个数组的一个元素。 12345var str = 'www.baidu.com';alert(str.split('.')) // ['www','baidu','com'];var str1 = 'abc';alert(str1.split('')) // ['a','b','c']; 第二个参数是限制截取多少段。 12var str = '2017-05-27-19-47';alert(str.split('-',3)); // ['2017','05','27'] 数组的方法push()在数组最后一位添加一个元素，返回值是增加后的数组的长度。 unshift()在数组第一位插入一个元素，返回值是增加后的数组的长度。ie6、ie7不支持这个方法的返回值。 pop()从数组的最后删除一个元素，返回值是删除的那个元素。 shift()从数组的开头删除一个元素，返回值是删除的那个元素。 splice()splice方法可以删除、替换、添加 删除时候可以传两个参数，第一个是开始删除的索引，第二个是删除的长度。返回值是删除的元素。 替换的话将要替换的内容写在第二个参数之后。返回值仅是被删除的内容。 添加的时候第一个参数是要添加的后面那个元素的索引，第二个参数是0，代表不替换，要添加的元素写在第二个参数之后。没有返回值 1234var arr = ['a,'b','c','d','e'];arr.splice(0,2) // arr = ['c','d','e']arr.splice(0,2,'z','x') // arr = ['z','x','c','d','e']arr.splice(1,0,'x') // arr = ['a','x','b','c','d','e'] sort()对数组进行排序，默认全部按照字符串的规则进行排序，会将数字转为字符串，然后按照字符串的比较方式，由小到大排序。 12var arr = [4,3,2,30];arr.sort(); // arr = [2,3,30,4] 要按照数值类型来排序的话需要在sort内部写一个函数 1234arr = [4,3,2,30];arr.sort(function(a,b)&#123; return a - b&#125;) 这里用a-b代表从小到大排序，意思是第一个数减第二个数。 也可以b-a是从大到小排序。是第二个数减第一个数。 只要return 为true，那么就会换位置。 join()将数组转为字符串，用传入的参数去分割数组每个元素，组成一个字符串，如果不传参数默认用逗号分割。 concat()将多个数组拼接起来，参数可以传过个，传几个就连接几个，会拼成一个新的数组，不会改变原来的数组。 123var arr1 = [1,2,3];var arr2 = [4,5,6];alert(arr1.concat(arr2)); // [1,2,3,4,5,6] reverse()颠倒数组内部元素的位置。对字符串也可以进行操作，只是从头到尾颠倒位置。不会进行比较。 12var arr = [1,2,3,4];arr.reverse(); // arr = [4,3,2,1] Math系列方法Math.random()产生0-1之间的随机数 Math.round()对参数进行四舍五入操作。 生成5-10之间的随机数1Math.round( Math.random() * 5 + 5 ) 通常第二个加的数是区间中那个下限的数，第一个乘的数是区间上限的数与第二个加的数的差值。 当求一个x-y之间的数公式就是：Math.round( Math.random() * ( y - x ) + x )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css杂记一]]></title>
      <url>%2F2017%2F05%2F21%2Fcss%E6%9D%82%E8%AE%B0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[word-spacing 单词间距判断是否是单词的依据是有没有空格 行高的测量方式假如文字是12px，行高是16px，那么文字上下空隙分别是2px，假如行高是15px，那么上方是1px，下方是2px。 white-space 强制不换行值为nowrap为强制不换行，默认是normal。 text-indent 首行缩进。通常设置em，这样文字尺寸改变了也不用该缩进值，只需要设置2em便一直是2个字的距离。 文字和空格的大小字体本身原本是一张张的图片，通过一定的编码方式确定是哪个文字，文字和文字之间本身也有一定的缝隙，算上缝隙才算是一个文字的大小，所以文字大小最好是从上到下测量。而宋体中一个空格的大小差不多是一个文字的一半。 伪类的顺序a:link 未访问过,a:visited 访问过后,a:bover 鼠标移入,a:active 鼠标按下。 clear属性给一个元素加上clear属性，那么对应方向上的元素就不会浮动了。值可以设置为left|right|both|none|inherit。clear:both是左右两侧都不能浮动。 清除浮动的方法清除浮动是为了让元素回归文档流，回归到同一层级。 加高度给浮动元素的父元素加一个固定的高度。缺点是扩展性不好。有时候高度不能写死。 父级浮动给浮动元素的父元素加浮动，缺点是父元素的父元素仍然会有问题，当前元素的父元素同时也是更上级元素的子元素。而且margin:0 auto;会失效 inline-block给浮动元素的父元素加inline-block，缺点也是margin:0 auto;会失效 使用空白元素在浮动元素的后面增加一个没有内容的块级元素设置css为clear:both。缺点是只要清除浮动就要放一个空白元素，而且ie6仍会有2px的默认高度。 br在浮动元素后面增加一个&lt;br clear=&quot;all&quot; /&gt;。缺点也是只要清除浮动就要放一个空白元素。 伪类清除浮动假设浮动元素的父元素添加一个class名为clearfix。 12345678.clearfix &#123; *zoom:1;&#125;.clearfix:after &#123; content:&apos;&apos;; display:block; clear:both;&#125; zoom是为了兼容ie浏览器，当设置了zoom之后会检索设置对象的缩放比例，所设置的元素就会扩大或缩小，高度就被重新计算了，所以可以清除浮动，*号是hack的写法，只有ie6、7浏览器可以识别。 overflow给浮动元素的父元素设置overflow:hidden。原理是触发BFC。缺点是比浮动长的内容会被直接剪裁掉。 BFC和haslayoutBFC(block formatting context):BFC是块级元素格式化上下文。是标准浏览器块级元素的标准(除了ie6、7、8之外都是标准浏览器)。 haslayout:ie浏览器特有的。 只要触发了这两个其一，那么这个触发的区域就是一个独立的区域不受外界影响，也可以理解为元素就不会脱离标准文档流了。 触发BFC的情况 float的值不会none。 overflow的值不为visble(这就是overflow:hidden可以清楚浮动的原理，让其触发BFC)。 display的值为table-cell、table-caption、inline-block中的任何一个。 position的值不为relative和staic。 width|height|min-width|min-height的值不是auto的时候。 触发haslayout的情况 zoom的值不会normal的时候。给ie浏览器设置zoom:1清楚浮动就是为了触发haslayout。 css hack \9所有ie10及以下的浏览器。\9是写在属性值的后面。 *ie7及以下浏览器，写在属性的开头。 _ie6及以下浏览器，写在属性的开头。 hack的书写顺序要从高版本往低版本写，因为css是按照顺序执行，后面的覆盖前面的，所以先做统一处理，最后再去处理个别低版本浏览器。另外hack不是一个标准的方法，所以一般不要使用。 禁止选中文字不同的浏览器设置的内容不一样，user-select不是一个W3C的标准，浏览器的支持不完成，需要对不同的浏览器进行调整。 user-select有2个值（none表示不能选中文本，text表示可以选择文本） 123456789-moz-user-select:none; /*火狐*/-webkit-user-select:none; /*webkit浏览器*/-ms-user-select:none; /*IE10*/-khtml-user-select:none; /*早期浏览器*/user-select:none; ie6至ie9还没发现有css属性支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记一]]></title>
      <url>%2F2017%2F05%2F21%2Fjavascript%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[this的基本用法首先有一个函数 123function fn1()&#123; alert(this);&#125; 直接调用则this指向window 1fn1(); // 指向window; 如果是被元素对象调用 123456div.onclick = function()&#123; var _this = this; // 这个this指的就是div元素对象 fn1(); // 这里打印的this值的就是window，因为上面fn1函数的环境就是在全局，所以如果直接调用函数，那么this都是window&#125;div.onclick = fn1; // 这里打印的this就是div元素对象，这里已经改变了fn1函数的环境，赋值给了div元素对象的事件属性中，环境自然也从全局变为div元素对象。 判断浏览器名称123456789101112131415161718function myBrowser()&#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 if (userAgent.indexOf("Opera") &gt; -1) &#123; //判断是否Opera浏览器 return "Opera" &#125;; if (userAgent.indexOf("Firefox") &gt; -1) &#123; //判断是否Firefox浏览器 return "FF"; &#125;; if (userAgent.indexOf("Chrome") &gt; -1)&#123; //判断是否Chrome浏览器 return "Chrome"; &#125; if (userAgent.indexOf("Safari") &gt; -1) &#123; //判断是否Safari浏览器 return "Safari"; &#125; if (userAgent.indexOf("compatible") &gt; -1 &amp;&amp; userAgent.indexOf("MSIE") &gt; -1) &#123; //判断是否IE浏览器 return "IE"; &#125;;&#125; 火狐浏览器禁止页面滚动12345if (navigator.userAgent.toLowerCase().indexOf('firefox')&gt;=0)&#123; if (e.preventDefault) e.preventDefault(); e.returnValue = false;&#125; 鼠标滚轮事件非FireFox浏览器是使用onmousewheel事件，而FireFox浏览器使用DOMMouseScroll事件。 非FireFox浏览器使用的是wheelDelta方法判断滚动方向，FireFox浏览器使用的是detail方法判断滚动方向。 wheelDelta:-120和detail:3 代表向下滚动。wheelDelta:120和detail:-3代表向上滚动。 12345678document.body.onmousewheel = function(event) &#123; event = event || window.event; console.log(event.wheelDelta)&#125;;document.body.addEventListener("DOMMouseScroll", function(event) &#123; console.log(event.detail)&#125;); jquery兼容性的滚轮事件12345678910111213$('#scrollSelect-view').on("mousewheel DOMMouseScroll", function (e) &#123; var delta = (e.originalEvent.wheelDelta &amp;&amp; (e.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) || // chrome &amp; ie (e.originalEvent.detail &amp;&amp; (e.originalEvent.detail &gt; 0 ? -1 : 1)); // firefox if (delta &gt; 0) &#123; // 向上滚 console.log("wheelup"); &#125; else if (delta &lt; 0) &#123; // 向下滚 console.log("wheeldown"); &#125;&#125;); 自定义属性有时候写方法时会定义大量变量，有的变量其实比较多余，很多数据可以存储到元素对象的自定义属性中去。这样不用去考虑作用域的问题，因为只要这个元素对象存在在这个方法内就可以去使用，但是最好只保存和这个元素对象有关的属性。 比如：下面代码就是，在事件处理函数内部只能获取i循环完毕之后的值，而通过把i的值作为元素对象的自定义属性赋值，就没有作用域的限制。 1234567for(var i = 0; i &lt; 5; i++) &#123; div.index = i; div[i].onclick = function()&#123; alert(i); alert(this.index); &#125;&#125; 排他思想和清空上一个排他通常在tab栏切换中经常用到排他，比如有10个选项，只有当前项才有背景色，通常颜色是通过一个类名挂钩到css中去设置的，那么排他就是每次先将所有导航选项的类名清空，然后只给当前点击的这个元素对象添加类名。 1234567891011for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始排他 for(var i = 0; i &lt; Lis.length;i++)&#123; Lis[i].className = ''; &#125; // 单独设置当前选项 Lis[this.index].className = 'active'; &#125;;&#125;; 清空上一个这种效果除了排他之外还可以通过清除上一个选项来完成。创建一个变量存储上一个选中元素，在点击当前元素时候清空上一个类名，之后把自己赋值给这个变量，如此每次只需要清空一个元素的类名即可。 1234567891011121314var oElem = null;// 初始化，默认第一个元素是当前项Lis[0].className = 'active';Elem = Lis[0];for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始清空上一个 Elem.className = ''; Elem = this; Lis[this.index].className = 'active'; &#125;;&#125;; jquery的stop()方法$(selector).stop(stopAll,goToEnd) stopAll 可选。规定是否停止被选元素的所有加入队列的动画。 goToEnd 可选。规定是否允许完成当前的动画。该参数只能在设置了 stopAll 参数时使用。 使用懒加载插件使用的 jquery.lazyload 调用下载好的插件 123456$(function()&#123; $("img.imglazyload").lazyload(&#123; threshold : 200, effect : "fadeIn" &#125;);&#125;); html部分，一定要在外层包一个div并且设置宽高，不要用图片去撑开。 123&lt;div class="item-image"&gt; &lt;img class="imglazyload" data-original="图片地址"&gt;&lt;/div&gt; js中的NaN NaN是一个数字类型但不是一个数值。 出现NaN肯定是进行了非法操作而不是获取数值有错，如果获取数值有错是undefind。 NaN与自己本身也是不相等的。 NaN转为布尔是false。 NaN本身的意思是’不是一个数值’ isNaN可以判断某些类型是不是一个数字类型。如果判断到是一个数字为false(不是一个数值这个判定是错的)，而不是数字类型的是true(不是一个数值这个判定是对的)。 NaN在判断时是在内部使用Number()方法转换，所以是不是数字类型的依据主要是看Number()转出的是什么类型。比如布尔值、空字符串、字符串数字都会被认为是数字类型而返回false。 js的作用域基础作用域实际上是浏览器js解析器的一种工作方式。 浏览器的js解析器在读取javascript代码时会先提升变量和函数，再去逐行解读代码。这是每个作用域的解析步骤。 预解析根据var、function、参数 找一些东西。 首先js解析器会搜索所有var和function找到所有变量，var声明的变量提升时值都是未定义，提升function时候会将整个函数代码块一起提升。 当var和function重名时，会保留function，覆盖var,但是如果两个以上同名的function，那么就看声明的先后顺序了。 逐行解析变量提升之后，js解析器会开始逐行解析代码，这时只有表达式可以改变变量的值，用下边的案例来说明。 1234567891011alert(a); // function a()&#123;alert(4);&#125;var a = 1;alert(a); // 1function a()&#123;alert(2);&#125;alert(a); // 1var a = 3;alert(a) // 3function a()&#123;alert(4);&#125;alert(a); // 3a(); // 报错 第一个alert打印出函数的原因是变量提升的规则，后面的a打印的都是变量的值而不是函数，因为变量赋值是一种表达式，而函数只是一个声明并不是表达式。并且因为现在a是一个数值，所以调用时自然会报错。 多组script自上而下的作用域大部分指的是多组script标签，如下代码 12345678910&lt;script&gt; alert(a); // 报错&lt;/script&gt;&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; alert(a); // 1&lt;/script&gt;/ 如果碰到这种情况，js解析器会对每个script代码块进行独立预解析和逐行解析，第一块script的代码还没声明a，第二块script的代码声明和赋值了，这时到第三块script代码块时a已经声明并赋值了，所以直接会打印1。 函数由内而外主要指函数，一个函数也是一个单独的作用域，javascript中，函数是唯一能分隔作用域的。 1234567var a = 1;function fn1()&#123; alert(a); var a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1()&#123; alert(a); a = 2;&#125;fn1(); // 1alert(a); // 2 第一个例子中在函数内部声明了a，那么在fn1中的a变量就和上级作用域的a变量没有任何关系了。按照预解析的步骤这里打印的是undefined。 第二个例子没有声明a变量，所以在fn1作用域中就找不到a，这时就会去上级作用域中寻找，上级作用域声明了a并且赋值为1了，所以打印1。 如果是下面这种情况 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(a); // 1alert(a); // 2 参数其实就是一个局部变量，第一个例子没有传参，参数就相当于var a; 第二个例子传了参数就相当于var a = 1; 一个函数的解析顺序是先从参数开始的。 下面看一个最常见的案例 12345for(var i = 0; i &lt; 3; i++)&#123; btn[i].onclick = function()&#123; alert(i); // 3 &#125;&#125; 最开始我以为这里打印的i是会随着遍历打印出0,1,2的，但实际上onclick函数中相当于一个独立的作用域，这个作用域中没有声明i变量，所以就要去上级作用域去获取，那为什么是3呢，因为函数只有在点击时才会调用，只有调用时才会发生预解析和逐步解析，这时去获取i的值上级作用域早已遍历完毕。 js运算符%取余的应用下面的例子中要在li元素中添加背景色，颜色存储在arr数组。如果不用取余运算符只能写两层for循环，而使用取余运算，可以直接让取余后的值自己循环。 arr的长度是3，i是0开始每次+1，那么arr数组每次的索引就是：arr[0%3=0],arr[1%3=1],arr[2%3=2],arr[3%3=0],arr[4%3=1],arr[5%3=2],arr[6%3=0]，这样就达到了遍历颜色数组的目的。这种操作很适合于在一个数组的遍历内部又需要遍历另外一个数组的情况。 12345var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];for(var i = 0; i &lt; li.length; i++)&#123; li[i].style.backgroundColor = arr[i%arr.length];&#125; 下面扩展一下这个案例，加上任意li元素点击后变色，再去点击另一个li，另一个li元素变色，上一个li元素变回原来的颜色。通常这种功能会用排他来做，这次不用排他，使用取余操作来写。 12345678910111213141516var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];var elem = null;for(var i = 0; i &lt; li.length; i++)&#123; li[i].index = i; li[i].style.backgroundColor = arr[i%arr.length]; li[i].onclick = function()&#123; if(elem)&#123; elem.style.backgroundColor = arr[elem.index%arr.length]; &#125; elem = this; this.style.backgroundColor = 'gray'; &#125;&#125; 排他是将所有li元素变色，再去更改当前点击的元素的背景色，而这种思路是记录上一次点击的元素，在下一次点击时只改变上一次点击的元素的背景色就可以了。这里elem.index和i的作用是相同的。 另外取余操作还可以换算时间，比如现在要将70秒转为分钟，那么可以这样写 12var s = 70;var m = Math.floor( 70/60 + '分' + 70%60 + '秒'); js获取浏览器计算后的属性值像width或者height这种属性直接获取只能得到行内样式，如果不写在行内就获取不到，使用getComputerStyle可以获取浏览器计算后的样式，也就是被浏览器渲染之后得到的元素实际的属性的值。格式是getComputerStyle(element).width; 但是这个方法在ie6、7、8不兼容。这三个非标准浏览器使用的currentStyle属性。格式是element.currentStyle.width;。 不要用这两个方法去获取没有设置过的属性。 不能用这两个属性去获取复合样式，比如要获取背景色不要用background而是要用backgroundColor，不论css是怎么写的，都要写具体的属性。因为如果写background的话会获取到所有这个属性可以设置的属性值，如果css没写的会获取到默认的。 另外在firefox浏览器4.0版本之前，getComputerStyle的参数要写两个，第二个参数可以随便写比如getComputerStyle(element,&#39;&#39;).width;或getComputerStyle(element,true).width;，总之只要写一个参数就可以。 jq中的即使搜索事件在jq中实现input搜索框的即时搜索和其他即时性的改变需要用到input和propertychange(兼容ie8及以下浏览器)事件。 input是标准的浏览器事件，一般应用于input元素，当input的value发生变化就会发生，无论是键盘输入还是鼠标黏贴的改变都能及时监听到变化。 propertychange只要当前对象属性发生改变都会触发，所以使用propertychange时最好排除一下不想触发事件的元素。 window.parent在b.html页面使用iframe的时候，引入一个Html页面名称暂定为a.html，呢么在a.html中，window指的是a的window对象，而window.parent指的就是b.html的window对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>%2F2017%2F04%2F13%2FGit%2F</url>
      <content type="text"><![CDATA[Git是通过监控文件的状态来实现版本的控制的。 文件的三种状态分别是已提交(commotted)、已修改(modified)、已暂存(staged)。 状态改变Git都是可以监听到的。由此引入对应Git项目的。 Git的三个区域介绍 Git仓库目：就是Git用来保存项目的源数据和对象数据库的地方。Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录：是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供用户使用或修改 暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index）,不过一般说法还是叫暂存区。 Git的基本工作流程 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 Git操作方法和命令本地仓库根目录右键，打开Git Bash。 输入git init初始化一个git仓库。 这样就可以让git来管理目录。这个命令只是创建了一个名为.git的隐藏目录，这个目录就是存储我们历史版本的仓库。 添加到缓存git add *将已修改的文件放到暂存区，也可以直接写文件名或者文件夹名，git会自动过滤空目录。 查看状态git status 检测当前仓库文件的状态，红色表示被修改，放到暂存区的文件被标记成了绿色等待提交。 git checkout index.html 将index.html从暂存区还原到工作区。 提交git commit -m &#39;提交信息&#39; -m是mark的意思，将暂存区的内容全部文件提交，将暂存区被标记成绿色的文件，全部提交到本地仓库存储。 其他git log 查看存盘点，每次提交会生成一个随机id值 git reset --hard id值 还原代码到该id值得版本 第一次使用git时需要配置。git config --global user.name pj.Yu 设置自己的名字。git config --global user.email 406490508@qq.com 设置自己的邮箱 Git分支同时开发多个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要来修复，这个时候我们当然希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。通过Git创建分支来解决实际开发中类似的问题。 开发时在另一个分支上开发新功能A然后上线，然后再写另一个分支另外一个功能B，这时A功能有bug再去调试，不会影响其他分支的状态。 当我们初始化仓库时候，实际上就是产生了第一次提交。Git会默认帮我们创建一个master的分支，每次commit操作生成一个新的版本（存盘点）。而且会生成一个sha值，master是主干，这些版本就是在主干上的存盘点，每一次的历史按本都是基于分支存在的。 分支功能基本操作建立新的分支git branch share 建立一个名为share的分支，建立后现在还是在master主干上。 git checkout share 切换到share分支，切换之前尽量先commit。 git branch 查看当前都有哪些分支。*号表示当前处于哪个分支。 git checkout -b share 创建并切换到share分支 另外分支是有继承关系的。新建的自分支会继承父分支的所有提交历史。 合并两个分支git merge share 当前分支合并share分支。同一个文件被修改会产生冲突。 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 冲突开始的位置 =========== 之上是当前分支的代码，之下是share分支的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; share 冲突结束的位置 根据需求留下想要的代码，将标识符都删除掉就解决冲突了。 删除分支git branch -d share 删除share分支 git的分支管理规范(主要指在gitLab上的分支) 不要有太多的分支，分支太多管理起来太费劲，毕竟是多人开发制定策略太复杂 要有一个稳定的平行分支，即master分支不要轻易修改，这个稳定的文分支不能有bug。 要有一个开发分支(developer)，保证master分支的稳定性 所有的功能分支(feature)从developer创建，功能写完后合并到developer，但不能直接合并到master，因为要保证始终有一个没有bug的稳定分支 所有功能开发完成后新建发布分支(release)，用作测试，测试完全没问题就合并到master分支。 GitHub多个人共同开发，改完代码后放到共享仓库，其他人就可以取到代码。借助一个远程仓库，大家可以共享代码、历史版本等数据，GitHub就是这样的一个代码仓库。 在gitHub中新建一个项目 首先创建一个新的项目，要输入项目名，项目描述，是否公开。其实就相当于新建一个共享库。 以表格形式创建一个仓库，并且会提供给我们一个仓库地址。 由于主机名太长，可以简写成主机名。以后只填写主机名就行，就不用写远程仓库地址了 git remote add &quot;主机名&quot; &quot;远程仓库地址&quot; 添加远程主机，其实就是给远成仓库地址起一个比较短的名字 git remote show &quot;主机名&quot; 查看这个主机名对应的主机名是谁 git remote 显示所有主机名 地址下面会告诉用户应该怎样操作，如何创建.git并上传等设置，这里根据自己的实际情况，并不是每一步骤都要设置，有可能之前已经设置好了 设置之后就可以push了，但是这时会有权限问题，也就是公钥和私钥，需要将本电脑的公钥传到gitHub上， 设置公钥为了免密码共享代码需要通过SSH来实现： ssh-keygen -t rsa 创建一个公钥，一直回车。在用户的文件里创建了一文件夹.ssh里边创建了对公钥和私钥.pub是公钥。 将公钥放到gitHub对应账号下，在个人设置里有SSH的选项，复制进去就行。相当于在自己电脑和gitHub之间建立了连接。私钥不需要管。 如果有两台电脑就要添加两个SSH key git push 仓库地址 分支 将本地提交的更改推送到远程仓库。 git pull 仓库地址 分支 将远程仓库的代码拉取到本地仓库。 git push origin 本地的分支:远程仓库分支 把本地分支的修改共享到远程的分支上去 如果远程没有这个分支就会创建一个。 fork功能GitHub除了创建共享仓库，还有一个目的是coding，大家一起来共享代码 这里的项目都是公开的开源项目，除了自己可以维护功能，其他来自全世界的人都可以共同进行开发，并且其他开发者可以对原有的项目进行修改 但是程序员水平参差不齐，所以项目不允许其他人直接修改。需要先forking一份到自己的目录下，然后通过克隆、pull、push等操作，修改自己目录下的这份副本。 自己改完以后经过自己测试，没问题的话可以申请原有项目合并自己的修改。申请合并是pull requests选项，在gitLab中是Merge Requests选项。要填写合并哪个项目的哪个分支，还要填写更改的说明，和发邮件类似，这样发送请求就成功了。 对方会受到申请并且检验，如果对方觉得改的不错，同意后可进行合并，否则拒绝 克隆远程仓库当远程仓库已经有项目了，项目已经开始开发了，可以执行克隆操作。 git clone &quot;仓库地址&quot; 拿下来的就是仓库了，就不用再执行init了。 克隆下来后，查看分支，当前只有master分支，因为克隆的就是主干分支。 git fetch &quot;仓库地址&quot; 这时就把其他分支都拿下来了 git branch -A 可以看远程仓库的分支，除了主干都是红色的 总结来看，我如果使用克隆功能，相当于完成了以下步骤： mkdir 目录 -&gt; cd 目录 -&gt; git init -&gt; git remote add origin “仓库地址” -&gt; git pull origin master GitLab通过GitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，私有仓库又是需要交“保护费”的，而gitLab就是免费私有的这么一个网站。 gitLab也是一个可以通过Web界面管理仓库的网站程序，我们可以把它架设到公司自已的服务器上，实现仓库私有化，这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。 给项目添加成员进入一个项目后，右上角的设置有个Menbers选项，就是成员的意思，如果希望有个人一起合作写这个项目，就可以邀请并分配权限，通常分配Developer权限。现在对方就可以随意push代码，但是不能操作master分支。 分组很多时候我们需要创建一个分组，相当于建立一个群Groups，在左边的菜单栏里。 分组可以直接添加分组成员，步骤和项目添加成员相同。 在分组里可以建立项目，作为小组的成员也会自动生成一个项目目录，大家就可以一起开发这个项目，之后的步骤和上面相同。 Protexted Branches受保护的分支，默认情况下保护的是master分支， 也可以自行根据权限设置保护的分支。 gitignore 忽略文件有些文件不需要提交，比如笔记，图片等。这时就可以忽略掉 忽略方式：创建一个没有文件名的.gitignore后缀文件，通过另存为来保存。也可以用命令行创建将要忽略的文件名存进去，就忽略了。 比较差异当内容被修改时，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 用git difftool比较暂存区和修改的文件的差异 接一个sha值比较暂存区和历史记录的差异,两个sha值就是历史版本和历史版本的差异 回滚（撤销）操作如果刚刚上传完后又发现一个bug， 可以用git reset把某一个版本的代码还原到工作目录。 –hard 工作区会变，历史会变，暂存区也会变。 –soft 只会变历史区域的代码，即是回滚在工作区也看不见。 –mixed 历史会变，暂存区也会变，工作区不变。 工作区指的能看的见的代码。 .git目录就是仓库区域。 暂存区也在.git目录下，就是index文件。 git checkout SHA值 -- index.html 只拿出index到工作区中，其他文件不变 历史不变 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch &quot;远程主机&quot; 或者git fetch &quot;远程主机&quot; &quot;分支名称&quot;获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。 用git merge remotes/主机名/分支名 当前分支合并remotes/主机名/分支名 也可以用git pull 主机名 分支名，这个命令等于做了两个操作，git fetch和 git merge origin/某个分支 git branch -a 便可以查看所有(本地+远程仓库)分支了 git push origin --delete 分支名称 可以删除远程分支。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一、DOM]]></title>
      <url>%2F2017%2F04%2F13%2F%E4%B8%80%E3%80%81DOM%2F</url>
      <content type="text"><![CDATA[1、DOM的含义 文档(D)，指的是document，当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生，DOM把我们编写的网页文档转换为一个文档对象。 对象(O)，指的就是javascript中的三种对象，用户定义对象、内建对象、宿主对象。 模型(M)，可以理解为模型Model或者地图Map，我们可以通过javascript代码来读取这张地图。 要理解模型或者地图的概念，首先我们要理解DOM是把一份文档表示为一棵树。以下面文档为例。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt; &lt;head&gt; &lt;meta charset = "utf-8"&gt; &lt;title&gt;Shopping list&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;What to buy&lt;/h1&gt; &lt;p title = "a gentle reminder"&gt;Don't forget to buy this stuff&lt;/p&gt; &lt;ul id = "purchases"&gt; &lt;li&gt;A tin of beans&lt;/li&gt; &lt;li class = "sale"&gt;Cheese&lt;/li&gt; &lt;li class = "sale"&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 上面的一长串代码可以理解为以下的DOM树 从上图可以看出，html永远是一个文档的开始，可以看作是树根，再深一层就是head和body，它们位于一层，所以是兄弟关系(sibling)，它们都有各自的子元素(child)，有着共同的父元素(parent)。 实际上用parent、silbling、child就可以代表整个DOM树的结构，比如ul是ul是body的child元素，而ul又是li的parent元素，ul和p是sibling元素，并且这棵树上的每个元素都是一个DOM节点。 2、节点上面介绍了DOM的概念，由图也可以看出，DOM树是由一个个节点组成的，这些就是DOM节点。分为三种类型。 元素节点 标签的名字就是元素节点，例如”p”、”ul”、”body”等等。 文本节点 被元素包括的文本内容就是文本节点，比如上面文档中被包含的”A tin of beans”。 属性节点 属性节点用来对元素做出更具体的描述，比如的title属性，也包括id和class属性，属性节点也总是被包含在元素节点内部。 那么我们如何区分这三种节点呢？可以使用nodeType属性。nodeType属性总共有12种可取值，但其中仅有3种有实用价值。 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 实际使用中可以通过元素对象的nodeType属性值来判断节点类型。 3、获取元素有3种DOM方法可以获取元素节点，分别是通过元素id、通过标签名、通过class获取。 通过id名获取这个方法将返回一个与给定id属性值的元素节点对应的元素对象，它是document对象特有函数。1document.getElementById(&apos;box&apos;); 获取id属性值是’box’的元素对象。 这里一直再说元素对象这个概念，其实就是指的html元素，但是在DOM里html元素都是DOM节点。而DOM节点本身就是一个对象，所以叫做元素对象。另外函数和方法其实也是一个概念，对象的方法其实就是一个函数。 通过标签名获取这个方法返回一个对象数组，与getElementById不同的是，这个返回的是一个数组，返回的数组中，每个元素都是获取到的元素对象，可以用length属性查出这个数组的长度。 1document.getElementsByTagName('li'); 这个方法允许把一个通配符作为它的参数，可以获取文档里的所有元素，也可以和getElementById结合使用 12var box = document.getElementById('box');var lis = box.getElementsByTagName('*'); 这样可以获取id为box的元素下的所有元素对象。 通过class获取这是HTML5中新增的方法，可以通过class名获取元素，返回的也是一个对象数组。 1document.getElementsByClassName('sale important'); 获取class属性为sale和important的元素对象，这个元素必须同时有这两个class名，顺序无所谓。也可以和getElementById结合使用。 12var box = document.getElementById('box');var sales = box.getElementsByClassName('sale'); 获取id值为box的元素下的所有class名为sale的元素。 需要注意的是这个方法比较新，所以用的时候要小心，为了弥补这个不足，我们可以自己封装一个获取class名的方法以适用于旧版浏览器。 获取class名的兼容性处理 1234567891011121314function getElementsByClassName(node, className) &#123; if (node.getElementsByClassName) &#123; return node.getElementsByClassName(className); &#125; else &#123; var results = new Array(); var elems = node.getElementsByClassName('*'); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(className) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 这个函数接收两个参数，node表示搜索起点，className是要搜索的class名，这个方法不足的地方是不适用多个class名。 4、获取和设置属性已经了解了三种获取元素节点的方法，现在可以去获取它们的属性。 获取属性1234567var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; var title_text = paras[i].getAttribute('title'); if(title_text != null)&#123; alert(title_text); &#125;&#125; getAttribute用于获取属性，需要用元素节点去调用，参数是要获取的属性名，如果调用的元素节点里没有要查找的属性就会返回null。 设置属性12345var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; paras[i].setAttribute('title','brand new title text'); alert(paras[i].getAttribute('title'));&#125; setAttribute用于设置属性，不管调用的元素原来有没有设置的属性，最终都会被设置上，用setAttribute对文档做出修改后，在浏览器中查看源代码仍是改变前的属性，这就是DOM的工作模式，对页面内容更新却不需要在浏览器里刷新。]]></content>
    </entry>

    
  
  
</search>
