<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[javascript杂记一]]></title>
      <url>%2F2017%2F05%2F21%2Fjavascript%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[1、this的基本用法首先有一个函数 123function fn1()&#123; alert(this);&#125; 直接调用则this指向window 1fn1(); // 指向window; 如果是被元素对象调用 123456div.onclick = function()&#123; var _this = this; // 这个this指的就是div元素对象 fn1(); // 这里打印的this值的就是window，因为上面fn1函数的环境就是在全局，所以如果直接调用函数，那么this都是window&#125;div.onclick = fn1; // 这里打印的this就是div元素对象，这里已经改变了fn1函数的环境，赋值给了div元素对象的事件属性中，环境自然也从全局变为div元素对象。 2、判断浏览器名称123456789101112131415161718function myBrowser()&#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 if (userAgent.indexOf("Opera") &gt; -1) &#123; //判断是否Opera浏览器 return "Opera" &#125;; if (userAgent.indexOf("Firefox") &gt; -1) &#123; //判断是否Firefox浏览器 return "FF"; &#125;; if (userAgent.indexOf("Chrome") &gt; -1)&#123; //判断是否Chrome浏览器 return "Chrome"; &#125; if (userAgent.indexOf("Safari") &gt; -1) &#123; //判断是否Safari浏览器 return "Safari"; &#125; if (userAgent.indexOf("compatible") &gt; -1 &amp;&amp; userAgent.indexOf("MSIE") &gt; -1) &#123; //判断是否IE浏览器 return "IE"; &#125;;&#125; 2、火狐浏览器禁止页面滚动12345if (navigator.userAgent.toLowerCase().indexOf('firefox')&gt;=0)&#123; if (e.preventDefault) e.preventDefault(); e.returnValue = false;&#125; 4、鼠标滚轮事件非FireFox浏览器是使用onmousewheel事件，而FireFox浏览器使用DOMMouseScroll事件。 非FireFox浏览器使用的是wheelDelta方法判断滚动方向，FireFox浏览器使用的是detail方法判断滚动方向。 wheelDelta:-120和detail:3 代表向下滚动。wheelDelta:120和detail:-3代表向上滚动。 12345678document.body.onmousewheel = function(event) &#123; event = event || window.event; console.log(event.wheelDelta)&#125;;document.body.addEventListener("DOMMouseScroll", function(event) &#123; console.log(event.detail)&#125;); 5、jquery兼容性的滚轮事件12345678910111213$('#scrollSelect-view').on("mousewheel DOMMouseScroll", function (e) &#123; var delta = (e.originalEvent.wheelDelta &amp;&amp; (e.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) || // chrome &amp; ie (e.originalEvent.detail &amp;&amp; (e.originalEvent.detail &gt; 0 ? -1 : 1)); // firefox if (delta &gt; 0) &#123; // 向上滚 console.log("wheelup"); &#125; else if (delta &lt; 0) &#123; // 向下滚 console.log("wheeldown"); &#125;&#125;); 6、自定义属性有时候写方法时会定义大量变量，有的变量其实比较多余，很多数据可以存储到元素对象的自定义属性中去。这样不用去考虑作用域的问题，因为只要这个元素对象存在在这个方法内就可以去使用，但是最好只保存和这个元素对象有关的属性。 比如：下面代码就是，在事件处理函数内部只能获取i循环完毕之后的值，而通过把i的值作为元素对象的自定义属性赋值，就没有作用域的限制。 1234567for(var i = 0; i &lt; 5; i++) &#123; div.index = i; div[i].onclick = function()&#123; alert(i); alert(this.index); &#125;&#125; 7、排他思想和清空上一个排他通常在tab栏切换中经常用到排他，比如有10个选项，只有当前项才有背景色，通常颜色是通过一个类名挂钩到css中去设置的，那么排他就是每次先将所有导航选项的类名清空，然后只给当前点击的这个元素对象添加类名。 1234567891011for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始排他 for(var i = 0; i &lt; Lis.length;i++)&#123; Lis[i].className = ''; &#125; // 单独设置当前选项 Lis[this.index].className = 'active'; &#125;;&#125;; 清空上一个这种效果除了排他之外还可以通过清除上一个选项来完成。创建一个变量存储上一个选中元素，在点击当前元素时候清空上一个类名，之后把自己赋值给这个变量，如此每次只需要清空一个元素的类名即可。 1234567891011121314var oElem = null;// 初始化，默认第一个元素是当前项Lis[0].className = 'active';Elem = Lis[0];for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始清空上一个 Elem.className = ''; Elem = this; Lis[this.index].className = 'active'; &#125;;&#125;; 8、jquery的stop()方法$(selector).stop(stopAll,goToEnd) stopAll 可选。规定是否停止被选元素的所有加入队列的动画。 goToEnd 可选。规定是否允许完成当前的动画。该参数只能在设置了 stopAll 参数时使用。 9、使用懒加载插件使用的 jquery.lazyload 调用下载好的插件 123456$(function()&#123; $("img.imglazyload").lazyload(&#123; threshold : 200, effect : "fadeIn" &#125;);&#125;); html部分，一定要在外层包一个div并且设置宽高，不要用图片去撑开。 123&lt;div class="item-image"&gt; &lt;img class="imglazyload" data-original="图片地址"&gt;&lt;/div&gt; 10、js中的NaN NaN是一个数字类型但不是一个数值。 出现NaN肯定是进行了非法操作而不是获取数值有错，如果获取数值有错是undefind。 NaN与自己本身也是不相等的。 NaN转为布尔是false。 NaN本身的意思是’不是一个数值’ isNaN可以判断某些类型是不是一个数字类型。如果判断到是一个数字为false(不是一个数值这个判定是错的)，而不是数字类型的是true(不是一个数值这个判定是对的)。 NaN在判断时是在内部使用Number()方法转换，所以是不是数字类型的依据主要是看Number()转出的是什么类型。比如布尔值、空字符串、字符串数字都会被认为是数字类型而返回false。 11、js的作用域基础作用域实际上是浏览器js解析器的一种工作方式。 浏览器的js解析器在读取javascript代码时会先提升变量和函数，再去逐行解读代码。这是每个作用域的解析步骤。 预解析根据var、function、参数 找一些东西。 首先js解析器会搜索所有var和function找到所有变量，var声明的变量提升时值都是未定义，提升function时候会将整个函数代码块一起提升。 当var和function重名时，会保留function，覆盖var,但是如果两个以上同名的function，那么就看声明的先后顺序了。 逐行解析变量提升之后，js解析器会开始逐行解析代码，这时只有表达式可以改变变量的值，用下边的案例来说明。 1234567891011alert(a); // function a()&#123;alert(4);&#125;var a = 1;alert(a); // 1function a()&#123;alert(2);&#125;alert(a); // 1var a = 3;alert(a) // 3function a()&#123;alert(4);&#125;alert(a); // 3a(); // 报错 第一个alert打印出函数的原因是变量提升的规则，后面的a打印的都是变量的值而不是函数，因为变量赋值是一种表达式，而函数只是一个声明并不是表达式。并且因为现在a是一个数值，所以调用时自然会报错。 多组script自上而下的作用域大部分指的是多组script标签，如下代码 12345678910&lt;script&gt; alert(a); // 报错&lt;/script&gt;&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; alert(a); // 1&lt;/script&gt;/ 如果碰到这种情况，js解析器会对每个script代码块进行独立预解析和逐行解析，第一块script的代码还没声明a，第二块script的代码声明和赋值了，这时到第三块script代码块时a已经声明并赋值了，所以直接会打印1。 函数由内而外主要指函数，一个函数也是一个单独的作用域，javascript中，函数是唯一能分隔作用域的。 1234567var a = 1;function fn1()&#123; alert(a); var a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1()&#123; alert(a); a = 2;&#125;fn1(); // 1alert(a); // 2 第一个例子中在函数内部声明了a，那么在fn1中的a变量就和上级作用域的a变量没有任何关系了。按照预解析的步骤这里打印的是undefined。 第二个例子没有声明a变量，所以在fn1作用域中就找不到a，这时就会去上级作用域中寻找，上级作用域声明了a并且赋值为1了，所以打印1。 如果是下面这种情况 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(a); // 1alert(a); // 2 参数其实就是一个局部变量，第一个例子没有传参，参数就相当于var a; 第二个例子传了参数就相当于var a = 1; 一个函数的解析顺序是先从参数开始的。 下面看一个最常见的案例 12345for(var i = 0; i &lt; 3; i++)&#123; btn[i].onclick = function()&#123; alert(i); // 3 &#125;&#125; 最开始我以为这里打印的i是会随着遍历打印出0,1,2的，但实际上onclick函数中相当于一个独立的作用域，这个作用域中没有声明i变量，所以就要去上级作用域去获取，那为什么是3呢，因为函数只有在点击时才会调用，只有调用时才会发生预解析和逐步解析，这时去获取i的值上级作用域早已遍历完毕。 12、js运算符%取余的应用下面的例子中要在li元素中添加背景色，颜色存储在arr数组。如果不用取余运算符只能写两层for循环，而使用取余运算，可以直接让取余后的值自己循环。 arr的长度是3，i是0开始每次+1，那么arr数组每次的索引就是：arr[0%3=0],arr[1%3=1],arr[2%3=2],arr[3%3=0],arr[4%3=1],arr[5%3=2],arr[6%3=0]，这样就达到了遍历颜色数组的目的。这种操作很适合于在一个数组的遍历内部又需要遍历另外一个数组的情况。 12345var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];for(var i = 0; i &lt; li.length; i++)&#123; li[i].style.backgroundColor = arr[i%arr.length];&#125; 下面扩展一下这个案例，加上任意li元素点击后变色，再去点击另一个li，另一个li元素变色，上一个li元素变回原来的颜色。通常这种功能会用排他来做，这次不用排他，使用取余操作来写。 12345678910111213141516var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];var elem = null;for(var i = 0; i &lt; li.length; i++)&#123; li[i].index = i; li[i].style.backgroundColor = arr[i%arr.length]; li[i].onclick = function()&#123; if(elem)&#123; elem.style.backgroundColor = arr[elem.index%arr.length]; &#125; elem = this; this.style.backgroundColor = 'gray'; &#125;&#125; 排他是将所有li元素变色，再去更改当前点击的元素的背景色，而这种思路是记录上一次点击的元素，在下一次点击时只改变上一次点击的元素的背景色就可以了。这里elem.index和i的作用是相同的。 另外取余操作还可以换算时间，比如现在要将70秒转为分钟，那么可以这样写 12var s = 70;var m = Math.floor( 70/60 + '分' + 70%60 + '秒'); 13、js获取浏览器计算后的属性值像width或者height这种属性直接获取只能得到行内样式，如果不写在行内就获取不到，使用getComputerStyle可以获取浏览器计算后的样式，也就是被浏览器渲染之后得到的元素实际的属性的值。格式是getComputerStyle(element).width; 但是这个方法在ie6、7、8不兼容。这三个非标准浏览器使用的currentStyle属性。格式是element.currentStyle.width;。 不要用这两个方法去获取没有设置过的属性。 不能用这两个属性去获取复合样式，比如要获取背景色不要用background而是要用backgroundColor，不论css是怎么写的，都要写具体的属性。因为如果写background的话会获取到所有这个属性可以设置的属性值，如果css没写的会获取到默认的。 另外在firefox浏览器4.0版本之前，getComputerStyle的参数要写两个，第二个参数可以随便写比如getComputerStyle(element,&#39;&#39;).width;或getComputerStyle(element,true).width;，总之只要写一个参数就可以。 14、jq中的即使搜索事件在jq中实现input搜索框的即时搜索和其他即时性的改变需要用到input和propertychange(兼容ie8及以下浏览器)事件。 input是标准的浏览器事件，一般应用于input元素，当input的value发生变化就会发生，无论是键盘输入还是鼠标黏贴的改变都能及时监听到变化。 propertychange只要当前对象属性发生改变都会触发，所以使用propertychange时最好排除一下不想触发事件的元素。 15、window.parent在b.html页面使用iframe的时候，引入一个Html页面名称暂定为a.html，呢么在a.html中，window指的是a的window对象，而window.parent指的就是b.html的window对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一、DOM]]></title>
      <url>%2F2017%2F04%2F13%2F%E4%B8%80%E3%80%81DOM%2F</url>
      <content type="text"><![CDATA[1、DOM的含义 文档(D)，指的是document，当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生，DOM把我们编写的网页文档转换为一个文档对象。 对象(O)，指的就是javascript中的三种对象，用户定义对象、内建对象、宿主对象。 模型(M)，可以理解为模型Model或者地图Map，我们可以通过javascript代码来读取这张地图。 要理解模型或者地图的概念，首先我们要理解DOM是把一份文档表示为一棵树。以下面文档为例。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt; &lt;head&gt; &lt;meta charset = "utf-8"&gt; &lt;title&gt;Shopping list&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;What to buy&lt;/h1&gt; &lt;p title = "a gentle reminder"&gt;Don't forget to buy this stuff&lt;/p&gt; &lt;ul id = "purchases"&gt; &lt;li&gt;A tin of beans&lt;/li&gt; &lt;li class = "sale"&gt;Cheese&lt;/li&gt; &lt;li class = "sale"&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 上面的一长串代码可以理解为以下的DOM树 从上图可以看出，html永远是一个文档的开始，可以看作是树根，再深一层就是head和body，它们位于一层，所以是兄弟关系(sibling)，它们都有各自的子元素(child)，有着共同的父元素(parent)。 实际上用parent、silbling、child就可以代表整个DOM树的结构，比如ul是ul是body的child元素，而ul又是li的parent元素，ul和p是sibling元素，并且这棵树上的每个元素都是一个DOM节点。 2、节点上面介绍了DOM的概念，由图也可以看出，DOM树是由一个个节点组成的，这些就是DOM节点。分为三种类型。 元素节点 标签的名字就是元素节点，例如”p”、”ul”、”body”等等。 文本节点 被元素包括的文本内容就是文本节点，比如上面文档中被包含的”A tin of beans”。 属性节点 属性节点用来对元素做出更具体的描述，比如的title属性，也包括id和class属性，属性节点也总是被包含在元素节点内部。 那么我们如何区分这三种节点呢？可以使用nodeType属性。nodeType属性总共有12种可取值，但其中仅有3种有实用价值。 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 实际使用中可以通过元素对象的nodeType属性值来判断节点类型。 3、获取元素有3种DOM方法可以获取元素节点，分别是通过元素id、通过标签名、通过class获取。 通过id名获取这个方法将返回一个与给定id属性值的元素节点对应的元素对象，它是document对象特有函数。1document.getElementById(&apos;box&apos;); 获取id属性值是’box’的元素对象。 这里一直再说元素对象这个概念，其实就是指的html元素，但是在DOM里html元素都是DOM节点。而DOM节点本身就是一个对象，所以叫做元素对象。另外函数和方法其实也是一个概念，对象的方法其实就是一个函数。 通过标签名获取这个方法返回一个对象数组，与getElementById不同的是，这个返回的是一个数组，返回的数组中，每个元素都是获取到的元素对象，可以用length属性查出这个数组的长度。 1document.getElementsByTagName('li'); 这个方法允许把一个通配符作为它的参数，可以获取文档里的所有元素，也可以和getElementById结合使用 12var box = document.getElementById('box');var lis = box.getElementsByTagName('*'); 这样可以获取id为box的元素下的所有元素对象。 通过class获取这是HTML5中新增的方法，可以通过class名获取元素，返回的也是一个对象数组。 1document.getElementsByClassName('sale important'); 获取class属性为sale和important的元素对象，这个元素必须同时有这两个class名，顺序无所谓。也可以和getElementById结合使用。 12var box = document.getElementById('box');var sales = box.getElementsByClassName('sale'); 获取id值为box的元素下的所有class名为sale的元素。 需要注意的是这个方法比较新，所以用的时候要小心，为了弥补这个不足，我们可以自己封装一个获取class名的方法以适用于旧版浏览器。 获取class名的兼容性处理 1234567891011121314function getElementsByClassName(node, className) &#123; if (node.getElementsByClassName) &#123; return node.getElementsByClassName(className); &#125; else &#123; var results = new Array(); var elems = node.getElementsByClassName('*'); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(className) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 这个函数接收两个参数，node表示搜索起点，className是要搜索的class名，这个方法不足的地方是不适用多个class名。 4、获取和设置属性已经了解了三种获取元素节点的方法，现在可以去获取它们的属性。 获取属性1234567var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; var title_text = paras[i].getAttribute('title'); if(title_text != null)&#123; alert(title_text); &#125;&#125; getAttribute用于获取属性，需要用元素节点去调用，参数是要获取的属性名，如果调用的元素节点里没有要查找的属性就会返回null。 设置属性12345var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; paras[i].setAttribute('title','brand new title text'); alert(paras[i].getAttribute('title'));&#125; setAttribute用于设置属性，不管调用的元素原来有没有设置的属性，最终都会被设置上，用setAttribute对文档做出修改后，在浏览器中查看源代码仍是改变前的属性，这就是DOM的工作模式，对页面内容更新却不需要在浏览器里刷新。]]></content>
    </entry>

    
  
  
</search>
