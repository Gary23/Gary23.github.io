<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[面向对象三、作用域]]></title>
      <url>%2F2017%2F06%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
      <content type="text"><![CDATA[instanceof 运算符语法object instanceof fn 如果运算符后面的函数的prototype属性引用的对象出现在运算符面前对象的原型链上的话就返回true，否则返回false。 12345678910function foo ()&#123; &#125;var f = new foo;console.log(f instanceof foo); // 返回true 判断f是不是foo函数的实例console.log(f instanceof Object); // 返回true f也是在Object的原型链上foo.prototype = new fn;var ff = new foo;console.log(ff instanceof fn) // true 因为fn创建了foo.prototype,所以foo.prototype的原型就是fn.prototype。console.log(ff instanceof Object) //true //ff -&gt; foo.prototype -&gt; fn.prototype -&gt; Object.prototype -&gt; null 作用域链绘制作用域链的规则 将这个script标签的全局作用域定义为0级作用域链，将全局作用域上的所有数据（变量、对象、函数），绘制在这条链上 由于在词法作用域中，只有函数可以分割作用域，那么只要遇到函数就再引申出新的作用域链，级别为当前链级别+1，将数据绘制到新链上 重复步骤二，直到没有遇到函数为止 以下面的函数举例来绘制作用域链： 12345678910111213var n = 123;function f()&#123; var n = 12; function f1()&#123; var n = 1; function f2()&#123; var n = 0; &#125; function f3()&#123; var n = 0; &#125; &#125;&#125; 变量的搜索原则 当访问一个变量时，首先在当前变量所处的作用于上查找，如果找到就直接使用，并停止查找 如果没有找到就向上一级链(T-1)上去查找，如果找到就直接使用并停止查找 如果没有找到就继续向上一级链查找，直到0级链 如果没有找到就报错 如果访问的变量不存在，会搜索整个作用域链（不仅性能低，而且抛出异常） 在实际开发不推崇所有数据都写在全局上。尽量使用局部变量，推荐使用沙箱。 如果在开发中，所有js变量都写在全局上，会造成全局污染 同级别的链上的变量互不干扰 1234567891011function f (a)&#123; var a ; function a ()&#123; console.log(a); &#125; a(); a = 10; console.log(a);&#125;f(100);// 在这个题中 var a 不会覆盖a的参数100，但是function会改变，a=10这个赋值操作也会覆盖，因为都相当于赋值。 补充在函数执行时候，会创建一个执行的环境，这个环境包括：activeObject（活动对象）以及作用域链 activeObject存储的是所有在函数内部定义的变量，以及函数的形参; 会将变量名字以及形参名字作为该对象的属性来存储，比如有个变量a，那么就等于有了a这个属性，这时a的属性值就是100； 因为之前已经传了a这个参数，传了参数也相当于在函数内声明了a这个变量，也就是说此时在activeObject中已经有了a这个属性，所以这时在函数内声明a就不管用了，只有赋值才管用。只能改属性值但属性不会再创建。上述代码先将函数赋值给了a，又将100赋值给了a 查找对象也是在activeObject中查找，也就是查找里边的属性和属性值，没有的话就找上一级函数的activeObject。直到找到为止，没有找到就报错。 闭包定义 指一个函数有权去访问另一个函数内部的参数和变量。 创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量。 应用闭包主要是为了设计私有的方法和变量。 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域，但是闭包的情况不同，不会被垃圾回收机制回收。 为了防止闭包导致的内存泄漏，用完闭包之后手工赋值为null，就会被回收。 闭包结构和闭包引用写在同一个函数里，出了函数就自动删除该缓存了。 缺点 闭包会造成函数内部的数据常驻内存，会增大内存使用量，从而引发内存泄漏问题。每创建一个闭包都会创建一个缓存数据，这样就会造成内存泄漏（内存满了后其他数据写不进去） 闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。 12345678910111213141516function fn ()&#123; var n = Math.random(); function getN ()&#123; return n; // 这个作用域中没有n所以会向上寻找。 &#125; return getN; //这里是要返回整个getN函数，所以不加括号。&#125;var ff = fn(); // 这个ff就是闭包，通过它可以访问fn内部的数据。var nn = ff();var mm = ff(); // fn()实际上是getN这个函数体，那么ff()就是调用了getN这个函数，这样会返回n。console.log(nn);console.log(mm); // nn和mm的数是相同的console.log(nn === mm); //true,ff = null; // n被回收 优点 希望一个变量长期驻扎在内存中 避免全局变量的污染 私有成员的存在 用闭包的应用体现其优点下面通过几个案例来了解闭包的优点： 统计某个构造函数创建多少个对象，变量可以长驻内存123456789101112131415161718192021222324252627282930//统计某个构造函数创建多少个对象function counter() &#123; var n = 0; return &#123; add:function()&#123; n+=1; &#125;, getCounts:function()&#123; return n; &#125; &#125;&#125;// 创建一个闭包,相当于初始化计时器，因为重新调用会让n=0.// 然后创建闭包时，n=0和return的对象会被缓存。// 那么为什么闭包环境能缓存数据呢：// 因为 var n = 0相当于n进入环境，在局部作用域创建了一个对象和n 最后把对象和n返回个外部作用域，相当于已出执行环境，通过全局变量就能找到返回的对象，通过返回的对象就能找到n，通过这个路径就能找到变量n，// 所以得出结论因为在函数内部有方法（函数）对其有引用，并且又将其返回到外部作用域上的一个变量接收。创建之后就缓存了，这时再通过这个变量访问闭包里的环境，那么只会访问该变量的缓存区域。var PresonCount = counter();function Preson()&#123; PresonCount.add();&#125;//用Preson这个构造函数创建对象，每创建一次都相当于调用了一次该构造函数。var p = new Preson()var p1 = new Preson()var p2 = new Preson()var p3 = new Preson()console.log(PresonCount.getCounts()); 局部变量的累加,怎样做到变量a即是局部变量又可以累加1234567891011121314151617181920212223242526272829303132333435// 1、全局变量var a = 1function abc()&#123; a++ console(a)&#125;abc() // 2abc() // 3// 可以累加但问题是a是全局变量 容易被污染// 2、局部变量function abc () &#123; var a = 1; a++; console(a);&#125;abc() // 2abc() // 2// 放到局部里又不能累加，因为每次执行函数都相当于把a重新声明// 3、局部变量的累加function outer () &#123; var a = 1; return function () &#123; a++; console.log(a); &#125;&#125;var y = outer();y() // 2y() // 3// 这样即实现了累加，又能把变量a藏起来。 模块化代码，减少全局变量的污染。a是局部变量，全局变量有a也没关系123456789var abc = (function () &#123; var a = 1; return function()&#123; a++ console(a) &#125;&#125;()); // 函数在这里自调用一次，所以abc得到的是abc里返回的函数 abc(); // 2 abc(); // 3 函数的私有成员调用123456789101112131415161718var aaa = (function()&#123; var a = 1; function bbb()&#123; a++; console.log(a); &#125; function ccc()&#123; a++; console.log(a); &#125; return &#123; b:bbb, c:ccc // json格式，也就是返回一个对象。b是bbb的函数体 &#125;&#125;()); // 自调用一下，这样aaa就是函数体内的返回值，也就是那个json格式的对象aaa.b(); //2aaa.c(); //3 在循环中直接找到对应元素的索引123456789101112131415//这是以前的写法var lis = document.getElementsByTagName('li');for (var i = 0; i &lt; lis.length; i++) &#123; lis[i].onclick = function()&#123; console.log(i); // 由于进入函数时i已经循环完毕，所以i变为常量4&#125;// 用闭包的方式来写for (var i = 0; i &lt; lis.length; i++) &#123; (function(i)&#123; lis[i].onclick = function()&#123; console.log(i); &#125; &#125;(i)) //在这里调用一次，将i作为参数传进去，这时里边的i就不会是执行完之后的i值&#125; 内存泄漏问题由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素 12345678function closure()&#123; var oDiv = document.getElementById('oDiv'); //用完之后会一直待在内存中 var test = oDiv.innerHTML; oDiv.onclick = function () &#123; alert(test); // 这里用oDiv导致内存泄漏 &#125;; oDiv = null; //最后应该将oDiv解除来避免内存泄漏&#125; 多闭包结构向上边的案例只需要一个n的值一个闭包就可以解决，而很多时候需要返回的变量大于1。 如下需要访问函数内部的多个变量n和m，就需要多个闭包。闭包的实质就是一个函数。 12345678910111213141516171819function foo()&#123; var n = 1,m = &#123;age:20&#125;; // n是变量，m是对象 function getN()&#123; return n; &#125; function getM()&#123; return m; &#125; return &#123;getM:getM,getN:getN&#125;; // :前的是属性名，：后的是属性值也就是函数体。&#125;var obj = foo(); // 这就是一次闭包.obj.getM().age = 22;console.log(obj.getM().age);console.log(obj.getN());var obj1 = foo(); // 这是第二次闭包，每闭包一次就是重新调用一次。不会被上次obj闭包调用并且更改属性值而改变函数本身的值，这和原型的不可变特性比较像。console.log(obj.getM().age); 对象的私有属性1234567891011121314151617181920212223242526272829303132333435363738394041// 用下面这个案例来说明构造函数的问题。function Preson (name,age) &#123; this.name = name; this.age = age;&#125;// 这是创建对象并且传参姓名var xiaohong = new Preson("小红",20)// 这时如果一不小心，就能随意将姓名改成小绿了。xiaohong.name = "小绿"// ---------------------------------------------------------------------------------------// 为了解决这个问题,可以用这种写法function Preson (name,age) &#123; return &#123; getName:function()&#123; return name; &#125;, getAge:function()&#123; return age; &#125; // name通常不能更改，但是age 可以改，给了这样一个借口就可以直接改了 setAge:function(val)&#123; age = val; &#125; &#125;&#125;// 还是创建对象并且传参// 这样就没法随意更改了，除非更改构造函数的函数。var xiaohong = Preson("小红",20)xiaohong.serAge(19); xiaohong.getAge(); // 先传一个参数19，让age改为19.再调用一下getAge函数。就将年龄属性改为了19// 但是还有个问题，那就是通过下面的语句可以创建一个name的属性。这样也是不太好的xiaohong.name = "小绿"//通过下面这个属性可以解决。但是要写在上面创建属性的语句的前面Object.preventExtenions(xiaohong)xiaohong.name = "小绿" console.log(xiaohong.name) // 这时就返回undefined了。 用闭包来解决递归函数性能问题1234567891011121314151617181920212223242526 // 利用闭包可以缓存数据的特性，改善递归性能 // 这个函数是为了缓存var fib = (function() &#123; var cache = []; // 这个函数是求fib的第n项值 return function(n) &#123; if (n &lt; 1) &#123; return undefined; &#125; // 1、看缓存里有没有 // 如果有，直接返回值 if (cache[n]) &#123; return cache[n] &#125; else // 如果没有重新计算 if (n === 1 || n === 2) &#123; cache[n] = 1; &#125; else &#123; cache[n] = arguments.callee(n - 1) + arguments.callee(n - 2); &#125; return cache[n]; &#125; &#125;()) console.log(fib(10)); 垃圾回收机制定义GC(Garbage Collection)，专门负责一些无效的变量所占有的内存回收销毁。 原理垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但这个过程不是实时的，因为其开销比较大，所以垃圾回收器会照固定的时间间隔周期性的执行。、 为什么闭包会造成内存常驻，并且让垃圾回收机制不能回收不再使用的变量（生命周期结束的变量），当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。 123456789101112131415161718function fn1 () &#123; // body... var obj = &#123; name:'tom', age:20 &#125;&#125;function fn2 () &#123; // body... var obj = &#123; name:'tom', age:20 &#125; return obj&#125;var a = fn1();var b = fn2(); 当fn1被调用时，进入fn1环境，会开辟一块内存存放对象obj，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放， 而在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。那么问题出现了：到底哪个变量是没有用的？所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：计数清除和引用清除。 引用计数法跟踪记录每个值被引用的次数，如果一个变量被另外一个变量引用了， 那么该变量的引用计数+1，如果同一个值又被赋值给另一个变量，则引用次数再+1。相反，当这个变量不再引用该变量时，这个变量的引用计数-1；GC会在一定时间间隔去查看每个变量的计数，如果为0就说明没有办法再访问这个值了就将其占用的内存回收。 123456function test () &#123; var a = &#123;&#125;; // a的引用次数为0 var b = a ; // a的引用次数+1，为1 var c = a ; // a的引用次数再+1， 为2 var b = &#123;&#125; // a的引用次数减1，为1&#125; 引用计数的缺点123456function test () &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125; 以上代码a和b的引用次数都是2，fn()执行完毕后，两个对象已经离开环境，在标记清除方式下是没问题，但在引用计数策略下，因为a和b的引用次数不为0，所以不会被垃圾回收器回收内存，如果fn函数被大量调用，就会造成内存泄漏。只能手动让a和b=null才能被识别并回收 1234window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;;&#125;; 这段代码看起来没什么问题，但是obj引用了document.getElementById(“element”)而document.getElementById(“element”)的onclick方法会引用外部环境值中的变量，自然也包括obj。解决办法：自己手工解除循环引用。 12345window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;; obj = null;&#125;; 将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾回收器下次运行时，就会删除这些值并回收它们占用的内存。 标记清除法从当前文档的根部（window对象）找一条路径，如果能到达该变量，那么说明此变量有被其他变量引用，也就说明该变量不应该被回收掉，反之，应该被回收其所占的内存 当变量进入某个执行环境（例如，在函数中声明一个变量），那么给其标记为“进入环境”，此时不需要回收，但是如果上述执行环境执行完毕，便被销毁，那么该环境内的所有变量都被标记为“已出环境”，如果被标记为已出环境，就会被回收掉其占用的内存空间。 12345function test() &#123; var a = 10; // 被标记，进入环境 var b = 20; // 被标记，进入环境&#125;test() // 执行完毕后，a,b被标记离开环境，被回收。 垃圾回收器在运行时会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。目前IE,Firefox,Opera,Chrome,Safari的js实现使用的都是标记清除的垃圾回收策略，只不过时间间隔不相同。 沙箱123456789101112131415161718192021 // 沙箱 // 变量不写在全局上，但又想达到写在全局的目的，就用沙箱 // 特点：1、能分割作用域，不会污染全局（函数） // 2、在分割后的作用域的内部的代码要自执行。（匿名函数） // 结构： (function()&#123; //代码块 &#125;());// 经典的沙箱模式：var n = 2(function () &#123; // 这个n不会污染外部的n。所以这样能保证自己的代码安全执行（别人也污染不了我），也不会污染全局变量或其他作用域的变量 var n = 1; function foo () &#123; console.log(n); &#125; //window.fn 相当于设定了一个全局变量 window.fn = foo;&#125;())fn();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象二、函数]]></title>
      <url>%2F2017%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[创建方式声明式123function foo ()&#123; console.log(arguments);&#125; 表达式123var foo = function () &#123; console.log(arguments);&#125; 构造函数方式123var foo = new Function(arg1,arg2,......,argn,body')// arg1,arg2,......,argn是可选的形参列表，表达为创建出来函数的形参列表，数据类型是字符串// body 字符串类型，表达为创建出来的函数的函数体部分 函数的原型链由于函数也可以通过构造函数来创建，那么函数也是对象，对象都具有proto属性，有了proto属性也就说明它也具有原型链。 12345678910111213141516console.log(Object.constructor)console.log(Array.constructor)console.log(Date.constructor)console.log(RegExp.constructor)var foo = function()&#123;&#125;console.log(foo.constructor)// 以上内置函数和自定义函数的构造函数都是Function()// 结论：// 1、所有函数都是Function的实例// 2、那么也就是说，所有的函数的构造函数为Function// 3、所有函数的原型对象为Function.prototype 12345678console.log(foo.__proto__ === Function.prototype)console.log(Object.__proto__ === Function.prototype)console.log(Array.__proto__ === Function.prototype)console.log(RegExp.__proto__ === Function.prototype)console.log(Date.__proto__ === Function.prototype)console.log(Date.__proto__ === Function.prototype)// 以上结构都为true,也就是说这些内置函数和自定义函数都是通过Function这个构造函数创建的，他们的原型对象__proto__也就是Function.prototype 函数原型链的绘制绘制原型链时将函数（内置函数和自定义函数）成为函数对象，为了避免混淆，其他对象称为普通对象 Function.prototype 即是函数也是对象类型，而所有的原型对象都没有 prototype 属性，并且只有原型对象才有 constructor 属性 arguments对象arguments对象属性length：实参的个数 callee：返回正在执行的函数；应用在匿名函数递归调用 12345function foo ()&#123; console.log(arguments);&#125;foo() 函数相关属性caller：返回调用当前函数的函数 length：形参的个数 name：存的函数的名字 1234function fn ()&#123; foo()&#125;// foo.caller就是返回fn函数体 函数重载在Javascript中函数是不能重载的，如果有函数重载Javascript会认为这是两个不同的函数，第二个会覆盖第一个，如下： 123456function foo () &#123;&#125;function foo (arguments) &#123;&#125; 但是Javascript可以模拟函数的重载，以前一直是这样写的，只是没有灌输重载这个概念。如下： 12345678910111213141516function foo() &#123;// 如果函数没有传递实参就打印falseif (arguments.length == 0) &#123; return false;&#125;// 如果传递两个实参，就将两个实参拼接起来在打印出来if (arguments.length &gt;= 2) &#123; var str = ""; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; str = str + arguments[i]; &#125; return str;&#125;&#125;//每个功能都是函数的重载 函数递归递归就是在函数体里自己调用自己 需要注意的是递归调用时要有递归调用的开始条件和结束条件，不然会死循环。 1234function fn()&#123; fn()&#125;//这就是递归函数，在内部调用自己，但是此时没有条件显示，所以会死循环 下面通过两个案例来解释递归函数的用法和条件限制 求等差数列的第n项的值步骤：得知道开始项的值，用v代替，每次增加的数字也就是差值，用d代替，要查找的第几项，用n代替 1234567891011121314151617 // 在这个例子中，n的值每次递减，递减到n===1的时候return v, 这就相当于整个函数有了值。也就是终止了再次进入调用函数本身。然后一步一步的把值返回。因为每次return都会+d,函数循环的次数也就是+d的次数。 // 每次函数调用自己都相当于进栈一次，循环调用了几次,栈里就有几个函数，当n===1时开始return，也就开始依次出栈。我们实际return的是v的值，每次出栈让v+d，然后根据d来确定是出几次栈，也就是做几次操作。function dengCha(v, d, n) &#123; // 过滤n小于1的无效值 if (n &lt; 1) &#123; return undefined; &#125;// 如果n为1，就直接返回V 此时不要继续递归,让函数从v的值开始每次+d，加的次数就是循环调用的次数。 else if(n === 1)&#123; return v; &#125; // 此时如果传入的n值&gt;1,就需要递归了 else &#123; return dengCha(v,d,n-1) + d &#125;&#125; 用一张图来表示函数执行过程： 斐波那契函数1234567891011121314151617181920// 案例2： // fib数列 1,1,2,3,5,8,13,21,34，... // fib的规律： // 1: 1 // 2: 1 // 3: 2 // 4: 3 // 5: 5 // n: n-1+n-2// 这是一个匿名函数，用v来接收匿名函数的返回值var v = (function(n)&#123;if(n &lt; 1)&#123; return undefined;&#125;else if(n === 1 || n ===2)&#123; return 1;&#125;else &#123; return arguments.callee(n-1) + arguments.callee(n-2);&#125;&#125;(6)) console.log(v); 用一张图来表示函数内部操作步骤 函数的四种调用模式普通函数执行：这声明一个函数后，就直接调用。种模式下this指向window对象12345function foo () &#123; console.log(1); console.log(this === window);&#125;foo(); 方法调用模式：通过一个对象来调用方法。把某一个函数当做对象的方法，this指向该方法的调用者1234567var obj = &#123; sayHi:function()&#123; console.log("hello"); console.log(this === obj); &#125; &#125;obj.sayHi(); 构造函数模式：配合new操作符来调用函数。this指向当前函数创建的对象12345function fn (name) &#123; this.name = name; console.log(this);&#125;var f = new fn("tom"); call/apply模式（上下文模式）：this是用户动态指定的，指定call or apply方法的第一个参数。只有函数对象才有call和apply方法fn.call(thisobj,arg1,arg2,...,argN) thisobj是fn在执行时this指向的对象，arg1…argN是fn在执行时传入的实参列表 fn.apply(thisobj,[fn的实参]) 和call不同点事最后是以数组的形式传递实参的 注意：在非严格模式下，如果thisobj赋值为null或者不传实参，此时this -&gt; window对象，就相当于普通函数执行模式。 1234567// 此时要借用构造函数的name属性var o = &#123;&#125;;fn.call(o,"Jack") // o调用fn的name属性console.log(o.name); // 就打印了Jackfn.apply(o,['tim']) // console.log(Function.prototype)fn.apply(o,['tim']) // 用apply方法 上下文模式的应用数组的合并123456// 将arr2上的所有元素合并到arr1中var arr1 = [1,2,3];var arr2 = [4,5,6];// 下面两种方法都可以,只要是函数调用了push方法就行。[].push.apply(arr1,arr2); Array.prototype.push.apply(arr1,arr2); 借调方法（函数）借用构造函数 1234567891011121314function parent(name, age, gender) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 借用构造函数（和对象冒充作用类似）function child(name, age, gender, address) &#123; parent.call(this, name, age, gender); this.address = address; &#125;var c = new child('c',19,'女','地球');//这样c就借用了parent的属性并且传了值。 借调原生方法 1234// 求data中的最大值var data = [67,89,190,23,10,100];var max = Math.max.apply(null,data); // this指向无所谓时可以填null// 想让括号里传的参数做怎样的操作就调用怎样的方法 获取内置对象类型 12345678910console.log(typeof []); // 怎样返回arrayconsole.log(typeof new Date); // 怎样返回data// 功能：如果是内置对象，返回其类型名// 如果是自定义对象，就返回objectfunction getType(obj)&#123; var t = Object.prototype.toString.call(obj).slice(8,-1); // 想让括号里传的参数做怎样的操作就调用怎样的方法 return t.toLowerCase();&#125;getType() 将伪数组变成真数组 123// 借用上面的函数getTypevar doms = document.getElementsByTagName('div');var domArr = Array.prototype.slice.call(doms); 数组去重 123456789101112131415161718192021222324252627var arr = [1, 2, 2 , '1'];// indexOffunction unique(a) &#123; var ret = []; // 如果不支持indexOf方法 // 自己实现数组的indexOf方法，并添加到数组的原型对象上。 if( !ret.indexOf )&#123; Array.prototype.indexOf = function(val) &#123; // this指向的就是 indexOf的调用者 （数组对象） // 如果循环顺利执行完，就表示没有val值，返回-1； // 否则返回val在当前数组中的下标值。 for(var i = 0,l = this.length; i &lt; l; i++)&#123; if(this[i] === val) return i; &#125; return -1; &#125;; &#125; for(var i = 0,l = a.length;i &lt; l; i++)&#123; // 如果ret中不存在当前遍历到的元素，就添加到ret中 // 否则就不要添加 if( ret.indexOf(a[i]) === -1 )&#123; ret.push(a[i]); &#125; &#125; return ret;&#125;console.log(unique(arr));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面向对象一、原型]]></title>
      <url>%2F2017%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%80%E3%80%81%E5%8E%9F%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[面向对象的概念面向对象是一种编程思想，核心是解决任何问题的时候首先试图去找到一个对象来帮助解决问题 在编程中，面向对象是调度者，从根本上是将面向过程封装，所以面向过程不可弃之不用。面向过程是执行者，执行顺序一般情况不能打乱。 面向对象的优点： 代码的灵活度高，代码执行顺序可以打乱。面向过程的代码不能打乱。 可维护性高，出现bug只需要在对象上去调试。 扩展性高，扩展时只需要维护局部模块。 面向对象的缺点： 可能会造成代码复杂度提高 代码可读性相对不好 js语言的特点 弱类型 多范式 基于对象的语言： 在Javascript中，一切的根源都是对象，并没有面向对象的一些概念，所以说是基于对象的语言，通常把构造函数当做一个模板，通过模板对建立对象 在其他面向对象的语言中，有类这个概念，Javascript用构造函数来模拟类，类和构造函数都是起到了模板的作用 不是面向对象的语言，只是用面对象向这种思想来模拟 基于原型的语言： 弱类型的语言基本都有原型存在，在面向对象的语言中，是类和类之间继承，而Javascript中只能让对象和对象之间继承， 原型的介绍原型的概念就是一个函数的prototype属性所引用的对象，原型是Javascript内置的，只要声明了一个函数，那么原型就自动存在了。 1234function fn ()&#123;&#125; // 这是一个构造函数console.log(fn.prototype) // 就是这个构造函数的原型console.log(fn.prototype.constructor) //就是这个构造函数// 所以构造函数和它的原型是能互相访问的。 原型的意义通过同一个构造函数创建出的所有对象都共享这个构造函数的原型，也就是说上述创建出的所有对象，可以直接访问到原型上的任何成员(属性和方法)。 123function fn ()&#123;&#125;var f = new fnf.constructor //就是fn这个构造函数，所以在fn这个构造函数里增加属性和方法对象f是可以直接访问的 原型的本质就是一个对象。在原型中创建方法就和个对象加方法一样。 原型的好处可以实现数据共享。用下面的代码列举问题来看一下原型的好处 123456789101112function Preson () &#123; this.talk = function()&#123; console.log("talk") &#125;&#125; var jim = new Preson; jim.talk(); var john = new Preson; john.talk();// 问题：以上创建的两个对象访问了两次构造函数的talk()方法，这样对象每次访都是创建一个新的只属于这个对象的函数，没创建一个方法都是占用一块内存，而方法中的逻辑实际上都是一样的。这就相当于浪费了一块内存的位置// 解决方法：把建立在构造函数内的方法放在一个公共的地方，而这个公共的地方必须是该构造函数创建出来的，这样对象才能访问到，也就是该构造函数的原型上，实现数据共享fn.prototype.talk = function()&#123; console.log("talk") &#125; 获取原型的方式：函数：函数名.prototype 对象：对象.proto 对象的组成部分：对象本身和它的原型组成 每个对象都有__proto__属性，也就是说每个对象都有原型，所以说Javascript是基于原型的语言， 对象的类型：就是该对象的构造函数的名字，Javascript虽然是弱类型语言，并不是没有类型，而是不注重类型的存在，体现在所有对象用typeof去检测都是object,所以也可以说所有对象的原型都是Object.prototype。 自定义一个数组对象的原型还是一个数组对象。他们的构造函数就是Array内置函数，包括Object,Array,Date都是内置函数。new后边的都是函数。 原型的归属：原型的属性：给原型一个归属，也就是什么什么的原型，通常说原型是站在函数的角度去认识原型，那么站在函数的角度来说，原型可以被称为该函数的原型属性。 原型的对象：是站在对象的角度来看原型，此时原型可称为是这个对象的原型对象。 这两者只是称谓不同，实际上都是同一个原型。 proto的兼容性处理：两个下划线的属性是有兼容性的，这不是W3C的标准属性，只是浏览器给提供的便利的东西。 123456789101112131415 function getPrototype(obj) &#123; // 判断浏览器是否兼容__proto__ if (obj.__proto__) &#123; // 如果支持 return obj.__proto__; &#125; else &#123; // 如果不支持 // 获取该对象的构造函数 // 在通过此函数的prototype属性获取其原型对象 return obj.constructor.prototype; &#125;&#125;// 三元表达式写法function getPrototype(obj) &#123; return !!obj.__proto__ ? obj.__proto__ : obj.constructor.prototype;&#125; 标准构造函数写法主要就是要考虑哪些属性应该保留在构造函数内部，哪些属性提取出来放在原型上。 和对象息息相关的属性，这些属性都要写在构造函数内部。像姓名、年龄这些属性，是随着对象不同而改变的，所以没法放在原型上，而是要放到构造函数内部。 而那些为了共享的属性并且是每个对象都具有的属性，值也不会随对象变化而变化是确定的值。可以写在原型上。比如每个人都生活在地球上。 在一般情况下，方法被认为是所有对象所共有的。比如一般情况下人都会说话。所以所有方法都应该放在原型上。 原型的特性动态性给原型扩展成员会直接反应到已创建的对象身上。 12345678function A() &#123;&#125; A.prototype.color = 'black'; var a = new A; var ad = new A; // 已经创建对象之后再去扩展原型上的属性，也会反应到对象身上 A.prototype.makefood = function ()&#123; console.log('做饭')&#125; a.makefood(); // 做饭 ad.makefood(); // 做饭 置换原型对象，不会反映到已创建出来的对象。但是会直接影响之后创建出来的对象。 1234567891011121314function A() &#123;&#125; A.prototype.color = 'black'; var a = new A; A.prototype = &#123; constructor: A, makeup: function() &#123; console.log('我会化妆.'); &#125; &#125;; var na = new A; console.log(a.color); // black，因为a是置换对象之前创建的，所以它的原型就是A置换之前的原型。 a.makeup();// 报错，因为a是在置换原型之前创建的对象。 na.makeup(); // 我会化妆.因为na是在置换原型之后创建的对象 console.log(na.color); // undefined 因为这是在置换之前扩展的。扩展之后color属性就没了 唯一性由同一函数创建出来的所有对象，共享同一个原型对象。 123456789// 由同一个构造函数创建出的对象都共享同一个原型。function A() &#123;&#125;A.prototype.color = 'black';var a = new A;var ad = new A;// 这两个对象的原型对象全等，也就是同一个，并且共享原型对象的属性。console.log(a.__proto__ === ad.__proto__); // trueconsole.log(ad.color); // blackconsole.log(a.color); // black 不可变性对象是无法改变原型对象上的任何成员 123456789function A() &#123;&#125;A.prototype.color = 'black';var a = new A;// 更改a的color属性只能改变自身不会改变其他成员，并不会改变它的原型上的color属性，所以也不会改变ad的color。a.color = 'goldyellow';var ad = new A;console.log(ad.color); // blackconsole.log(A.prototype.color); // blackconsole.log(a.color); // goldyellow 继承性所有对象都继承自它的原型对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function A() &#123;&#125; // a和na都是构造函数A创建出的对象，,都继承了A的原型 A.prototype.color = 'black'; var a = new A; var na = new A; console.log(a.color); // black console.log(na.color);// black``` ## 面向对象的三大特性#### 封装性把复杂的实现过程包装并隐藏起来，然后提供一个接口来给用户使用。##### 封装的好处1. 实现代码的重复利用。2. 实际使用中，只要出现重复代码逻辑就要考虑封装成一个函数，如果该函数和一些变量关联性比较大，那么就可以将函数封装成一个对象。3. 私密性（安全性），封装后用户看不到复杂的内部代码，不会误操作覆盖封装的变量。4. 封装时尽量保持函数或对象功能的单一性，便于日后维护。#### 继承性1. 概念：就是指一个对象有权去访问另一个对象的属性和方法，自己没有的属性和方法可以去访问另一个对象去获得，在js中只要让一个对象去访问另一个对象的属性和方法的话就必须要建立继承，任何对象都继承自己的原型对象。2. 在js中继承是对象与对象之间，其他面向对象语言(c,java,objectC等)都是类与类之间的继承。类在其他语言里就相当于模板的意义，**在js中模板是构造函数，那么通过同一个构造函数（模板）创建出来的对象都继承函数里的属性和方法**（ES6之前的方式）3. 在实际开发中两种继承方式可以组合起来应用。4. 继承性的实现方式：在实际开发中，这三种方式可以结合起来用。 ##### 集成的实现方式1：基于原型```js// // a:基于原型：扩展原型 在原有的原型上进行相应的扩展，实现继承// (在对象的构造函数的原型上进行扩展，那么该对象也就继承了扩展的内容)function A () &#123;&#125; var a = new A;// a本身没有printA这个方法，但是它的模板创建了这个方法，所以a也继承了这个方法A.prototype.printA = function () &#123; console.log("扩展原型") &#125;a.printA();//-------------------------------------------------------------------// b:基于原型：置换原型 将要被继承的对象，直接替换掉原有的原型// (假如b要继承a，就把b构造函数的原型直接替换成new a(传参))// 首先创建了这个构造函数，通常parent代表 child继承自parentfunction parent () &#123; this.name = 'tom';&#125;// 给这个模板的原型创建了一个方法parent.prototype.printC = function () &#123; console.log("c"); console.log(this.name);&#125;// 又创建了一个构造函数。child代表继承自parent。function child () &#123;&#125;// 让child的原型 = 模板parent创建的对象。parent函数的name和printC也继承给了child，同时传参数也不影响parent函数child.prototype = new parent();//创建对象c,因为child的原型已经和函数parent一样，所以用c可以直接访问name和printC了var c = new child;c.printC();console.log(c.name); 集成的实现方式2： 拷贝继承12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 拷贝继承：将别的对象上的所有成员拷贝一份添加到的当前对象本身，拷贝继承没有任何对原型的操作。// 创建一个对象parentvar parent = &#123; print: function() &#123; console.log('i am parent'); &#125;, name: 'parent'&#125;// 创建一个对象childvar child = &#123; name: 'child' &#125; // child没有print方法，那么可以拷贝一份过来 // 拷贝步骤： // 1、遍历parent。for (var k in parent) &#123; /* 这样就将parent的所有属性都拷贝了过来,k就是name和print，child依次更改 和创建了这两个属性，并切将parent对应的属性值赋值给child. */ child[k] = parent[k];&#125;child.print();// 拷贝继承概念部分结束//--------------------------------------------------------------------------// 下面是一个问题，就是代码重复的问题，当child还要继承parent1的时候就要再写一遍遍历var parent1 = &#123; print1:function()&#123; console.log('print1'); &#125;&#125;for (var k in parent1) &#123; child[k] = parent1[k];&#125;child.print1();// 造成了代码重复，所以可以封装成一个函数// 封装为child对象的一个方法extend，谁调用extend方法就是给谁实现继承// 新建一个child对象 var child = &#123;&#125;// 给child创建一个名为extend方法，里边的函数就是封装的拷贝方法 child.extend = function(parent) &#123; var k; // parent是传的参数 for (k in parent) &#123; this[k] = parent[k] &#125; &#125;// 第一步封装完成，但是问题是只能往里传一个对象//--------------------------------------------------------------------------// 实现继承多个对象child.extend = function() &#123; // arguments是传入参数的数据的数组，在这里也就是传入的对象数量 var args = arguments; //遍历atguments上的所有对象 //依次将遍历的每个对象的成员添加到child for (var i = 0, l = args.length; i &lt; l; i++) &#123; //判断传入的是否为对象 if (typeof obj === 'object') &#123; for (var k in args[i]) &#123; this[k] = args[i][k] &#125; &#125; &#125;&#125;// 调用这个对象的拷贝方法并且传一个参数，参数是对象child.extend(&#123; name: 'child', print: function() &#123; console.log(this.name); &#125;&#125;)child.print(); 集成的实现方式3：对象冒充123456789101112131415161718// 对象冒充 在一个构造函数中可以动态的添加一个parent方法指向// 用已有的构造函数，然后调用parent方法去实例化当前对象的一部分成员（或全部成员）// 这种当时被称为对象冒充。function parent (name,age,gender) &#123; this.name = name; this.age = age; this.gender = gender&#125;// 如果两个函数的模板属性有重复。function child(name,age,gender) &#123; this.parent = parent; this.parent(name,age,gender); delete this.parent; // child通过这个属性冒充parent,通过这个构造函数创建对象也会有parent里的成员 // 注意：child利用完parent属性后记得删除. &#125; 集成的实现方式4：借调函数12345678910111213function parent (name,age,gender) &#123; // body... this.name = name; this.age = age; this.gender = gender;&#125;// 和冒充类似，这是用call方法实现的function child (name,age,gender,address) &#123; // body... parent.call(this,name,age,gender); this.address = address;&#125;var c= new child('tom',28,'男','yueqiu'); 集成的实现方式5：Object.create(parent) （置换原型的原理）123456789101112131415161718192021222324// 方法的介绍 Object.create(parent); 返回一个对象并继承自传入参数parent// 用基于原型：置换原型的方式来继承 var obj = &#123; name:'tom', print:function()&#123; console.log(this.name); &#125; &#125;// 将obj当做参数传进来,newObj就继承了obj// 声明一个新变量来接收继承自parent的对象var newObj = Object.create(obj)newObj.print();// 下面是Object.create解决兼容性问题if(!Object.create)&#123; Object.create = function(parent)&#123; function F () &#123; F.prototype = parent; return new F; &#125; &#125;&#125; 多态性体现在继承中的概念。比如某对象A继承自某对象B，B对象的某个方法在A中并不适用。然后A对象重写该方法，那么这个就是多态性。 概念：体现在子对象和父对象之间，在父对象中的同一方法在各个子对象中的实现行为不同。 原型链原型链是从当前对象到Object.prototype之间，存在一条层次分明，逐级递进的体现继承关系的链式结构 所有对象都有__proto__属性 原生对象继承自Object.prototype,具有constructor属性；如果置换了原型，记得要添加constructor属性 函数具有prototype属性 123456789101112131415161718192021222324var o = &#123;&#125;; //Object对象，对象都有__proto__属性// 对象的__proto__是它的原型对象console.log(o.__proto__)// 对象的constructor是它的数据类型Objectconsole.log(o.constructor）// 对象的原型就是Object.prototypeconsole.log(Object.prototype === o.__proto_);console.log(o.__proto__.__proto__); // 也就是console.log(Object.prototype.__proto__);// 返回null// 所以 o -&gt; Object.prototype -&gt; Null// Object对象的继承层次：// obj -&gt; Object.prototype -&gt; null// 以数组为例var arr = []; console.log(arr.constructor === Array); console.log(arr.__proto__ === Array.prototype); // arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null 用一张图来表示原型链：这是最简单最基础的原型链 用两个例题来深入体会原型链： 12function parent() &#123;&#125;var p = new parent; 1234function A() &#123;&#125;function B() &#123;&#125;B.prototype = new A; // 这时B.prototype的构造函数就是A()，var b = new B; 属性搜索原则当访问对象成员时，首先在当前对象上查找，如果找到就直接返回（调用）并且停止查找 如果没有找到就向其原型对象上去查找，如果找到就直接返回（调用） 如果还是没有找到，就继续向原型对象的原型对象上查找，直到Object.prototype。 如果找到了，就直接返回（调用），并停止查找，否则返回undefined（报错：xxx is not a function） 注意： 如果访问对象的某个属性不存在的话，会搜索整个原型链，有可能会导致js性能降低。 在实际开发中尽量保持一个适度的原型链长度。 兼顾js性能以及代码的可读性和扩展性 Object.prototype介绍constructor就是自己的构造函数（function Object( ) { [native code] }） hasOwnProperty()123456// hasOwnProperty() 判断指定的属性是否为当前对象自己的（自己的就是指不是继承过来的）// 构造函数里的就是对象自己的，原型上的就是继承的。// 格式：obj.hasOwnProperty('属性名')var o = &#123;name:'tom'&#125;;console.log(o.hasOwnProperty('name')); //返回trueconsole.log(o.hasOwnProperty('toString')); //返回false isPrototypeOf()12345678910111213141516// isPrototypeOf（） 用来判断当前对象是否是指定对象的原型对象// 格式：obj1.isPrototypeOf(obj2)// 只要对象A出现在B对象的原型链上就返回true,否则返回falsefunction A () &#123;&#125;function B () &#123;&#125; var a = new A; var b = new B;//现在没有任何关系 console.log(a.isPrototypeOf(b)); //返回falsevar a = new AB.prototype = a;var b = new B// b -&gt; a -&gt; a.prototype -&gt; Object.prototype -&gt; null propertyIsEnumerable()12345678910111213141516171819// propertyIsEnumerable() 判断对象指定的属性是否可枚举，并且指定的属性必须是自己的，两者都满足才能返回 true function foo(name, age, address) &#123; // body... this.name = name; this.age = age; this.address = address; &#125; foo.prototype.talk = function()&#123; console.log(this.name); &#125; console.log(f.propertyIsEnumerable('name')); // 返回true console.log(f.propertyIsEnumerable('talk')); // 返回false// 可枚举就是用 for in 遍历出来的属性都是可枚举的。内置的属性(__proto__)都是不可枚举的var obj = &#123; name:'tom'; age:18;&#125; 构造函数的执行过程12345678910111213// 构造函数的执行过程function Fn (name,age) &#123; this.name = name; this.age = age;&#125;var Fn = new Fn();// 1:创建了一个空对象// 2:将obj赋值给this (让this指向上面创建空对象,也就是Fn)// 3:将当前作用域交给this// 4:执行构造函数内部的代码// 5:将this返回 new的时候函数内部会默认return this]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[锋利的jq(二、jq的选择器)]]></title>
      <url>%2F2017%2F06%2F13%2F%E9%94%8B%E5%88%A9%E7%9A%84jq-%E4%BA%8C%E3%80%81jq%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基本选择器 选择器 描述 返回 示例 #id 根据给定的id匹配一个元素 单个元素 $(&#39;#test&#39;)选取id为test的元素 .class 根据给定的类名匹配元素 集合元素 $(&#39;.test&#39;)选取所有class为test的元素 element 根据给定的元素名匹配元素 集合元素 $(&#39;p&#39;)选取所有&lt;p&gt;元素 * 匹配所有元素 集合元素 $(&#39;*&#39;)选取所有元素 selector1,selector2…` 将每个选择器匹配到的元素合并后一起返回 集合元素 $(&#39;div,span,p.myClass&#39;)选取所有&lt;div&gt;``&lt;span&gt;和拥有class为myClass的&lt;p&gt;标签的一组元素 层次选择器层次选择器用来获取后代元素、子元素、相邻元素和同级元素等。 选择器 描述 返回 示例 $(‘ancestor descendant’) 选取ancestor元素里所有的descendant(后代)元素 集合元素 $(&#39;div span&#39;)选取&lt;div&gt;里的所有的&lt;span&gt;元素 $(‘parent&gt;child’) 选取parent元素下的child(子)元素 集合元素 $(&#39;div&gt;span&#39;)选取&lt;div&gt;元素下元素名是&lt;span&gt;的子元素 $(‘prev + next’) 选取紧接在prev元素后的next元素 单个元素 $(&#39;.one + div&#39;)选取class为one的下一个&lt;div&gt;同级元素，可以用$(&#39;.one&#39;).next(&#39;div&#39;)代替 $(‘prev~siblings’) 选取prev元素之后的所有siblings元素 集合元素 $(&#39;#two~div&#39;)选取id为two的元素后面的所有&lt;div&gt;同级元素，可以用$(&#39;#two&#39;).nextAll(&#39;div&#39;)代替 过滤选择器通过特定的过滤规则来选定元素。 基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(&#39;div:first&#39;)选取所有&lt;div&gt;元素中第1个&lt;div&gt;元素 :last 选取最后一个元素 单个元素 $(&#39;div:last&#39;)选取所有&lt;div&gt;元素中的最后一个&lt;div&gt;元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(&#39;input:not(.myClass)&#39;)选取class不是myClass的&lt;input&gt;元素 :even 选取索引是偶数的所有元素 集合元素 $(&#39;input:even&#39;)选取索引是偶数的&lt;input&gt;元素 :odd 选取索引是奇数的所有元素 集合元素 $(&#39;input:odd&#39;)选取索引是奇数的&lt;input&gt;元素 :eq(index) 选取索引等于index的元素 单个元素 $(&#39;input:eq(1)&#39;)选取索引等于1的&lt;input&gt;元素 :gt(index) 选取索引大于index的元素(不包括index本身) 集合元素 $(&#39;input:gt(1)&#39;)选取索引大于1的&lt;input&gt;元素 :lt(index) 选取索引小于index的元素(不包括index本身) 集合元素 $(&#39;input:lt(1)&#39;)选取索引小于1的&lt;input&gt;元素 :header 选取所有标题元素 集合元素 $(&#39;:header&#39;)选取网页中所有标题元素 :animated 选取当前正在执行动画的所有元素 集合元素 $(&#39;div:animated&#39;)选取正在执行动画的&lt;div&gt;元素 :focus 选区当前获取焦点的元素 集合元素 $(&#39;:focus&#39;)选取当前获取焦点的元素 内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为’text’的元素 集合元素 $(&#39;div:contains(&#39;我&#39;)&#39;)选取含有文本’我’的&lt;div&gt;元素 :empty 选取不包含子元素或者文本的空元素 集合元素 $(&#39;div:empty&#39;)选取不包含子元素(包含文本元素)的&lt;div&gt;空元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $(&#39;div:has(p)&#39;)选取还有&lt;p&gt;元素的&lt;div&gt;元素 :parent 选取含有子元素或者文本的元素 集合元素 $(div:parent)选取拥有子元素(包含文本元素)的&lt;div&gt;元素 可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见的元素 集合元素 $(&#39;:hidden&#39;)选取所有不可见的元素，包括visibility:hidden、display:none、type=&#39;hidden&#39; :visible 选取所有可见的元素 集合元素 $(&#39;div:visible&#39;)选取所有可见的&lt;div&gt;元素 属性过滤选择器 选择器 描述 返回 示例 [attribute] 选取拥有此属性的元素 集合元素 $(&#39;div[id]&#39;)选取拥有属性id的&lt;div&gt;元素 [attribute=value] 选取属性的值为value的元素 集合元素 $(&#39;div[title=test]&#39;)选择属性title为’test’的&lt;div&gt;元素 [attribute!=value] 选取属性的值不等于value的元素 集合元素 $(&#39;div[title!=test]&#39;)选取属性title不等于’test’的&lt;div&gt;元素(没有title属性的元素也会被选取) [attribute^=value] 选取属性的值以value开始的元素 集合元素 $(&#39;div[title^=test]&#39;)选取属性title以’test’开始的&lt;div&gt;元素 [attribute$=value] 选取属性的值以value结束的元素 集合元素 $(&#39;div[title$=test]&#39;)选取属性title以’test’结束的&lt;div&gt;元素 [attribute*=value] 选取属性的值含有value的元素 集合元素 $(&#39;div[title*=test]&#39;) 选取属性title含有’test’的&lt;div&gt;元素 [attribute&brvbar;=value] 选取属性等于给定字符串或以该字符串为前缀(该字符串后跟一个连字符’-‘的元素) 集合元素 $(div[title&brvbar;=’en’])选取title属性等于en或以en为前缀的&lt;div&gt;元素 [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $(div[title~=&#39;uk&#39;])选取属性title用空格分隔的值中包含字符uk的元素 [attributeN] 用属性选择器合并成一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围 集合元素 $(&#39;div[id][title$=&#39;test&#39;]&#39;)选取拥有属性id，并且属性title以’test’结束的&lt;div&gt;元素 子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素(index从1算起) 集合元素 :eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的，而:eq(index)是从0算起的 :first-child 选取每个父元素的第1个子元素 集合元素 :first只返回单个元素，而:first-child选择符将为每个父元素匹配第1个子元素。例如$(&#39;ul li:first-child&#39;);选取每个&lt;ul&gt;中第1个&lt;li&gt;元素 :last-child 选取每个父元素的最后一个子元素 集合元素 区别和上面相同，$(&#39;ul li:last-child&#39;);选取每个&lt;ul&gt;中最后一个&lt;li&gt;元素 :only-child 如果某个元素是它父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(ul li:only-child)在&lt;ul&gt;中选取是惟一子元素的&lt;li&gt;元素 表单属性过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(&#39;#form1 :enabled&#39;);选取id为form1的表单内所有可用的元素 :disabled 选取所有不可用元素 集合元素 $(&#39;#form1 :disabled&#39;);选取id为form2的表单内的所有不可用的元素 :checked 选取所有被选中的元素 集合元素 $(&#39;input:checked&#39;);选取所有被选中的&lt;input&gt;元素 :selected 选取所有被选中的选项元素 集合元素 $(select option:selected);选取所有被选中的选项元素 表单选择器为了使用户能够更加灵活的操作表单，可以使用表单选择器，更加方便的获取到表单的某个类型的元素。 选择器 描述 返回 示例 :input 选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;button&gt;元素 集合元素 $(&#39;:input&#39;)选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;button&gt;元素 :text 选取所有的单行文本框 集合元素 $(&#39;:text&#39;)选取所有的单行文本框 :password 选取所有的密码框 集合元素 $(&#39;:password&#39;)选取所有的密码框 :radio 选取所有的单选框 集合元素 $(&#39;:radio&#39;)选取所有的单选框 :checkbox 选取素有的多选框 集合元素 $(&#39;:checkbox&#39;)选取素有的多选框 :submit 选取所有的提交按钮 集合元素 $(&#39;:submit&#39;)选取所有的提交按钮 :image 选取所有的图像按钮 集合元素 $(&#39;:image&#39;)选取所有的图像按钮 :reset 选取所有的重置按钮 集合元素 $(&#39;:reset&#39;)选取所有的重置按钮 :button 选取所有的按钮 集合元素 $(&#39;:button&#39;)选取所有的按钮 :file 选取所有的上传域 集合元素 $(&#39;:file&#39;)选取所有的上传域 :hidden 选取所有不可见元素 集合元素 $(&#39;:hidden&#39;)选取所有不可见元素 使用选择器的注意事项含有’·’、’#’、’(‘或’]’等特殊字符碰到id或者class属性值带有这些特殊字符的需要转译之后才能使用，不能直接写 $(&#39;#box#b&#39;)这种不经过转译的写法是错误的，应该写为$(&#39;#box\\#b&#39;)，通过\\进行转译。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[锋利的jq(一、认识jq)]]></title>
      <url>%2F2017%2F06%2F13%2F%E9%94%8B%E5%88%A9%E7%9A%84jq-%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86jq%2F</url>
      <content type="text"><![CDATA[window.onload和$(document).ready()window.onload：必须等网页中所有的内容加载完毕后(包括图片)才能执行，不能同时编写多个。 $(document.ready())：网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完，可以同时编写多个，可以简写为$(function(){}) jQuery对象和DOM对象的转换jQuery转为DOM对象有两种方法，即[index]和get(index)。 123var box = $('#box')[0];var box1 = $('#box1').get(0); DOM转为jQuery对象,只需要用$()把DOM对象包装起来,$()就是一个jQuery对象的制造工厂。 123var box = document.getElementById('box');var $box = $(box); $快捷方式的更改$是jQuery的快捷方式，为防止冲突，也可以自定义这个快捷方式。 交给其他js库假如jQuery库在其他库之后引入，在其他库和jQuery库加载完成后就可以使用jQuery.noConflict()将变量$的控制权交给其他js库，如果先引入jQuery就不需要jQuery.noConflict()方法，直接写$即可。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery.noConflict(); // 将变量$的控制权移交给prototype.js jQuery(function()&#123; // 使用jQuery jQuery('p').click(function()&#123; alert( jQuery(this).text() ) &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 防止$冲突第一种方法：想确保jQuery不会与其他库冲突，可以自定义一个快捷方式。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; var $j = jQuery.noConflict(); // 自定义一个快捷方式 $j(function()&#123; // 利用刚自定义的快捷方式使用jQuery $j('p').click(function()&#123; alert($j(this).text()); &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 第二种方法：如果不想自定义名称，同时又想避免冲突可以这样。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery.noConflict(); // 将变量$的控制权移交给prototype.js jQuery(function($)&#123; // 将$通过参数传入 $('p').click(function()&#123; alert($(this).text()); &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 判断是否获取到了某元素在原生javascript中通过这样来判断页面中是否有这个元素 123if(document.getElementById('tt'))&#123; document.getElementById('tt').style.color = 'red';&#125; 在jQuery中因为$()获取的是一个对象，所以不能直接判断这个对象是否存在 123if($('#tt'))&#123; // 这里将永远判断为true，因为jQuery对象一直存在&#125; 应该这样判断 123if($('#tt').length &gt; 0)&#123; &#125; 或者 123if($('#tt')[0])&#123; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css的ie6兼容问题]]></title>
      <url>%2F2017%2F06%2F13%2Fcss%E7%9A%84ie6%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[png图片的兼容性png的图片在ie6下默认不是透明的，所以需要处理一下。 使用DD_belatedPNG插件，需要在script中调用，DD_belatedPNG.fix(&quot;selector1,selector2&quot;)，缺点是不支持body元素。 第二种方法是使用ie6的滤镜属性，这个属性body也可以使用。_background-image:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;XX.png&quot;,sizingMethod=&quot;crop&quot;);，因为只需要ie6支持所以用了hack。 float在ie6的兼容问题有如下结构 123456789101112131415161718192021222324252627282930&lt;style&gt;.box &#123; width: 400px; border: 1px solid #000000; overflow: hidden;&#125;.left &#123; float: left; background-color: red;&#125;.right &#123; float: right; background-color: blue;&#125;h2 &#123; height: 30px;&#125;&lt;/style&gt;&lt;div class="box"&gt; &lt;div class="left"&gt; &lt;h2&gt;左边&lt;/h2&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;h2&gt;右边&lt;/h2&gt; &lt;/div&gt;&lt;/div&gt; 将.left和.right分别左右浮动并设置颜色、h2元素设置高度应该是如下效果。 但在ie6下会显示成这样， ie6下在浮动的元素下的元素h2设置高度，会独占整行，因为h2是块级元素，但我希望的是浮动元素被内容撑开。这时只要设置样式h2{float:left}就可以解决这个问题。 另外假设父元素的宽度够长，如果子元素中第一个元素浮动并且宽度为200px，那么第二个元素即是设置了margin-left:200px;那么会有也间隙，所以既然要并排显示那么就都设置浮动，不要一个浮一个不浮。 ie6浏览器子元素超出宽度问题在标准浏览器子元素比父元素宽高大时，会超出父元素，但不会改变父元素大小，但是在ie6下回直接撑大父元素，会导致整个布局乱掉，所以ie6下布局一定要注意子元素的尺寸问题。 块级元素嵌套规则p标签、h标签、td标签是不能嵌套块级元素的，如果在ie6下嵌套了还会莫名多生成一个块级元素占用空间，布局也会乱掉。 margin的兼容性问题margin-top的传递问题在子元素中设置margin-top那么父元素也会掉下来。 给父元素设置边框。 给父元素设置overflow:hidden。(标准浏览器、ie7及以上浏览器) 给父元素设置zoom:1;(ie7及以下浏览器) 在ie7及以下浏览器设置父盒子的宽和高也可以解决。 上下margin的叠压问题同级元素如果有上下margin的设置，那么上下两个元素会导致上面元素的下margin和下面元素的上margin重叠。 解决方法是不要设置margin,而是设置某一个方向的margin，比如margin-top、margin-bottom。 inline-block的兼容性问题ie7及以下浏览器不识别display:inline-block属性。所以在ie7及以下浏览器要用行内块需要设置*display:inline;*zoom:1;。*号是只让ie7、ie6识别。 ie6的最小高度问题在ie6浏览器下最小高度是19px；如果要设置小于19px的元素，那么首先要设置具体高度，然后要加*overflow:hidden属性。剪裁掉多出的部分。 ie6双边距的问题当元素浮动后，再设置margin-left那么就会产生双倍边距。解决办法是给浮动元素设置*display:inline。 ie6浏览器li的间隙ie6浏览器下li元素内部的子元素如果浮动，li之间就会产生4px的间隙。解决方法是给li元素增加*vertical-align:top;属性。 ie6文字溢出的bugie6下两个浮动元素中间有注释或者内联元素，并且两个浮动元素宽度相加和父级宽度相差在6px以内，就会导致浮动元素内的文字溢出一个重复的，并且每多一个内联元素或者注释就会多出一个重复文字。 让两个浮动元素之间没有内联元素和注释。 如果只有一个浮动元素设置了宽度另一个没有宽，那么比父盒子的宽小3px即可。 如果两个浮动元素都设置了宽，那么两个元素加起来要比父盒子的宽小6px。 ie6相对定位于overflow:hidden的问题ie6下当子元素比父元素大时，并且子元素设置了相对定位，那么父盒子即使使用overflow:hidden也无法剪裁子元素。 只有将父盒子也设置为相对定位才可以剪裁。 ie6绝对定位奇数问题当父元素设置相对或者绝对定位并且宽高为奇数，那么在ie6中子元素设置绝对定位即使left/right和top/bottom设置为0，也会有1px的距离。 所以ie6下要使用定位父盒子必须是偶数。 ie6浮动元素和绝对定位的问题父元素设置相对定位，如果子元素设置浮动撑满整个父元素的空间，那么此时再有一个同级子元素设置绝对定位则这个元素会消失。 造成这个原因的是同级的问题，那么再绝对定位元素外面套一层元素就可解决。 也可以让浮动的子元素宽加起来比父元素少6px，那么绝对定位的元素也可以显示出来。 ie6下input间隙问题input作为子元素时，父盒子不设高度，那么input设置高度后撑开父盒子会造成上下分别1px的间隙，漏出父盒子。 解决方法是设置input左浮动]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>%2F2017%2F06%2F05%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[正则的意思就是让计算机能读懂我们想要的格式和规则。 初始化一个正则表达式 1var re = new RegExp('a'); 简单的写法，推荐这种写法，但是如果写在函数里正则需要传参的话就必须用new的写法 1var re = /a/; 正则表达式是区分大小写的，如果不想区分在最后加i。 1var re = new RegExp('b','i'); 或者 1var re = /b/i; 正则默认匹配成功就会结束，不会继续匹配，如果要全部查找需要全局匹配，在最后加g 1var re = new RegExp('b','g'); 或者 1var re = /b/g; 正则的方法test正则去匹配字符串，如果匹配成功就返回true，如果匹配失败就返回false。 写法：正则.test(字符串)。 12345var str = 'abcdef';var re = /b/;alert(re.test(str); //打印true search正则去匹配字符串，如果匹配成功，就返回匹配成功的索引，如果匹配失败就返回-1。 search的写法：字符串.search(正则) 123456789var str = 'abcefg';var re = /bcd/; var re1 = /B/; alert(str.search(re)) // 打印1，返回匹配到的首字符的索引alert(str.search(re1)) // 打印-1 match正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null。 match的写法：字符串.match(正则) 123456789101112131415var str = '123abc456efg789';var re = /\d\d/g; var re1 = /\d+/g; alert(str.match(re)) // 打印数组['12','45','78']alert(str.match(re1)) // 打印数组['123','456','789']var str1 = 'abc';var re2 = /(a)(b)(c)/;alert(str.match(re1)) // 打印['abc','a','b','c'],第一项是匹配的整体结果，后面依次是子项，不能加g replace正则去匹配字符串，匹配成功的字符去替换新的字符串。 replace的写法：字符串.replace(正则,新的字符串) 12345678910111213141516var str = 'aaa';var re = /a/;str = str.replace(re,'b');alert(str) // 打印baastr = str.replace(re,function(str)&#123; alert(str) // 函数的第一个参数就是匹配成功的字符a var result = 'b' return result; // return要替换的字符 &#125;) 转义字符比较常用的几个转译符 \. 真正的点，原本.是表示任意字符 \n 换行 \s 空格 \S 非空格 \d 数字 \D 非数字 \w 字符 ( 字符、数字、下划线 ) \W 非字符 \b 独立的部分(起始、结束、空格)，也就是要匹配是否在开头、是否在结尾、是否匹配到了空格。 \B 非独立的部分。 重复的子项\1代表重复的第一个子项、\2代表重复的第二个子项，可以用于匹配字符中一堆重复的内容。 12345var str = 'abca';var re = /(a)(b)(c)\1/;alert(re.test(str)) // 打印true，\1代表重复第一个子项，也就是a 量词不确定的字符的个数用量词来表示。 {} 字符出现的范围，{4,7}就是至少出现4次、最多出现7次，{4,}是最少出现4次，{4}正好出现4次， + 是至少出现一次，也可以写成{1,} ? 是0次或者1次，也可以写成{0,1} * 至少出现0次，也可以写成{0,} | 或的意思，和||相同 () 分组操作和匹配子项，分组操作和数学中的作用相同。 分组12345678910111213var str = '2017-6-3';var re = /\d-+/g;var re1 = /(\d-)+/g;str.replace(re,function(str)&#123; alert(str) // 打印'7-'和'6-'&#125;)str.replace(re1,function(str)&#123; alert(str) // 打印'7-6-'&#125;) 匹配子项小括号里匹配的内容就是一个子项，有两个小括号就是有两个子项。 1234567891011var str = '2016-6-4';var re - /(\d+)(-)/g;str.replace(re,function(str1,str2,str3)&#123; alert(str1); // 第一个参数是整个匹配的内容，'2016-','6-' alert(str2); // 在str1的匹配结果中，第一个子项(括号)匹配到的内容 '2016','6' alert(str3); // 在str1的匹配结果中，第二个子项(括号)匹配到的内容 '-','-'&#125;) 字符类就是一组相似的元素或字符，用[]来表示，[]中都是或的关系并且只代表一个字符。如果要代表多位可以在[]使用量词。 123456789var str = 'abc';var re = /a[ade]c/;alert(re.test(str)) // 打印true，中括号里匹配a或d或e都可以，但只能是一个字符var str1 = 'abdc';alert(re.test(str1)) // 打印false，只能匹配一个字符，也就是只占一个字符的位置，str1的第三位不是c所以是false 排除用^表示，写在[]里边是排除的意思。 12345var str = 'abc';var re = /a[^ade]c/;alert(re.test(str)) // 打印false，这里其实和非操作比较像，是指匹配的元素不能是a||d||e。 范围是要匹配的字符的范围。比如a-z、0-9、A-Z。 12345var str = 'abc';var re = /a[a-z]c/;alert(re.test(str)) // 打印true，只要第二个字符是a-z的范围内都可以匹配到 边界^ 正则最开始的位置。 $ 正则最后结束的位置。 常用的表单验证匹配中文：[\u4e00-\u9fa5] 行首位空格：^\s*|\s*$ Email：^\w+@[a-z0-9]+(\.[a-z]+){1,3}$ 网址：[a-zA-Z]+://[^\s]* QQ号：[1-9][0-9]{4,9} 邮政编码：[1-9]\d{5} 身份证：[1-9]\d{14}|[1-9]\d{17}|[1-9]\d{16}x]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM编程艺术--六、充实文档内容]]></title>
      <url>%2F2017%2F06%2F03%2FDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E5%85%AD%E3%80%81%E5%85%85%E5%AE%9E%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[这一章将继续在实践中应用动态创建标记 1、不应该做什么从技术上讲，可以把任何内容动态添加到网页上，但重要的内容不要这么做，因为这样一来，javascript就没有任何空间去平稳退化，如果缺乏javascript的支持，用户会永远看不到重要的内容，而且各大搜索引擎也不支持javascript。 渐进增强和平稳退化两项原则要牢记在心，在这里再次总结一下这两项重要的原则。 渐进增强应该从最核心的部分，也就是从内容开始，应该根据内容使用标记实现良好的结构，然后再逐步加强这些内容，这些增强工作既可以是通过css改进呈现效果，也可以是通过DOM添加各种行为，如果你正在使用DOM添加核心内容，那么添加的时机未免太迟，核心内容应在刚开始写文档时就成为文档的组成部分。 平稳退化渐进增强的实现必然支持平稳退化，如果你按照渐进增强的原则去充实内容，你为文档添加的样式和行为自然就支持平稳退化。那些缺乏必要的css和DOM支持的访问者仍可以访问到你的核心内容，如果用javascript去添加这些内容，它就没法支持平稳退化，不支持javascript就看不到内容。 2、内容和往常一样，任何网页都以内容为出发点，现在拿下面这段内容作为出发点。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;解释文档DOM&lt;/title&gt; &lt;style&gt; body &#123; font-family:'Helvetica','Arial',sans-serif; font-size: 10pt; &#125; abbr &#123; text-decoration: none; border: 0; font-style: normal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;什么是DOM&lt;/h1&gt; &lt;p&gt;&lt;abbr title="万维网联盟"&gt;W3C&lt;/abbr&gt;将&lt;abbr title="文档对象模型"&gt;DOM&lt;/abbr&gt;定义为:&lt;/p&gt; &lt;blockquote cite="http://www.w3.org/DOM/"&gt; &lt;p&gt;一个平台和语言中立的接口，将允许程序和脚本动态访问和更新的内容，结构和风格的文档。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;这是一个&lt;abbr title="应用程序设计接口"&gt;API&lt;/abbr&gt;可以用来浏览&lt;abbr title="超文本标记语言"&gt;HTML&lt;/abbr&gt;和&lt;abbr title="可扩展标记语言"&gt;XML&lt;/abbr&gt;文档。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;abbr&gt;标签用于缩略语的显示，默认情况会显示为带有下划线或下划点，但是通过css的设置已经代替了浏览器的默认样式。 &lt;abbr&gt;的title属性在浏览器里是隐藏的，有些浏览器会在你把鼠标指针悬停在缩略语上时，将它的title属性显示为一个弹出式的提示消息，这也是浏览器所使用的默认行为，而不同浏览器的默认样式也不尽相同。所以就像刚才用css样式去代替浏览器默认样式那样，我们也可以用DOM去改变浏览器的默认行为。 3、显示缩略语下面我要做的是将&lt;abbr&gt;标签中的title属性集中起来显示在一个页面，我希望得到的定义列表是这个样子： 123456789101112&lt;dl&gt; &lt;dt&gt;W3C&lt;/dt&gt; &lt;dd&gt;万维网联盟&lt;/dd&gt; &lt;dt&gt;DOM&lt;/dt&gt; &lt;dd&gt;文档对象模型&lt;/dd&gt; &lt;dt&gt;API&lt;/dt&gt; &lt;dd&gt;应用程序设计接口&lt;/dd&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言&lt;/dd&gt; &lt;dt&gt;XML&lt;/dt&gt; &lt;dd&gt;可扩展标记语言&lt;/dd&gt;&lt;/dl&gt; 用DOM来具体实现这个定义列表的步骤如下： 遍历这份文档中的所有&lt;abbr&gt;元素。 保存每个&lt;abbr&gt;元素的title属性。 保存每个&lt;abbr&gt;元素包含的文本。 创建一个&lt;dl&gt;自定义列表元素。 遍历刚才保存的title属性和&lt;abbr&gt;元素的文本。 创建一个&lt;dt&gt;标题元素。 把&lt;abbr&gt;元素的文本插入到这个&lt;dt&gt;元素。 创建一个&lt;dd&gt;列表项元素。 把title属性插入到这个&lt;dd&gt;元素。 把&lt;dt&gt;元素追加到第4步创建的&lt;dl&gt;元素上。 把&lt;dd&gt;元素追加到第4步创建的&lt;dl&gt;元素上。 把&lt;dl&gt;元素追加到explanation.html文档的body元素上。 按照上面的思路我将编写一个displayAbbreviations函数，并存入Enrich_document_content.js中。 1234567891011121314151617181920212223242526272829303132333435363738394041function displayAbbreviations()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有缩略词 var abbreviations = document.getElementsByTagName('abbr'); if(abbreviations.length &lt; 1) return false; var defs = new Array(); // 便利这些缩略词 for(var i = 0;i &lt; abbreviations.length; i++)&#123; var current_abbr = abbreviations[i]; var definition = current_abbr.getAttribute('title'); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; &#125; // 创建定义列表 var dlist = document.createElement('dl'); // 遍历定义 for(key in defs)&#123; var definition = defs[key]; // 创建定义标题 var dtitle = document.createElement('dl'); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); // 创建定义描述 var ddesc = document.createElement('dd'); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; // 创建标题 var header = document.createElement('h2'); var header_text = document.createTextNode('缩略词'); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 现在已经可以在页面显示出这个定义列表，不要忘记使用addLoadEvent函数加载。下面解析一下这个函数。 第一步仍然是检查我用到的DOM方法是否被支持。 第二步是遍历获取到的所有&lt;abbr&gt;元素，为了防止html中没有&lt;abbr&gt;元素，所以在遍历之前也做了检查，避免javascript报错。 第三步用数组保存&lt;abbr&gt;元素的文本和title属性，当一个元素中只有一个子节点，用lastChild获取其子节点是一个好的方法，这里将文本作为数组的下标使用，将字符串作为数组的下标也是一种常用的方式，不要被数组的下标通常为数字就被禁锢住想法。 第四步用for…in循环，去遍历之前的数组，for…in是遍历用字符串作为下标的数组的首选，将下标(key)和下标对应的值(value)添加到&lt;dt&gt;和&lt;dl&gt;元素中。 第五步是将这个定义列表和标题插入到body中，这一步没什么特别的。 4、displayAbbreviations函数的兼容性问题按理说这个函数即检查了方法、又全部使用的DOM方法，应该不存在兼容性问题，但问题还是有，就是有的浏览器不支持&lt;abbr&gt;元素，如果是这样那么不仅没有缩略语列表，还会导致javascript报错。 出现这个隐患，如果现在去替换&lt;abbr&gt;元素太过麻烦，不论何时，要替换html中的元素都不应该作为首选。所以保证displayAbbreviations函数在IE中能够平稳退化没这个方案实现起来最简单，也就是如果浏览器不支持&lt;abbr&gt;元素就可以提前退出。 接下来要解决这个兼容性问题，做到平稳退化，我要在第一个for循环中加入一个判断。if(current_abbr.childNodes.length &lt; 1) continue;这条语句会让当前元素没有子节点的话就进入下一次循环，不支持&lt;abbr&gt;元素的浏览器在统计&lt;abbr&gt;元素的子节点个数总会返回错误值。 此时因为defs数组是空的，所以它将不会创建出任何&lt;dt&gt;和&lt;dd&gt;元素，在for…in循环之后，写一个函数出口，if(dlist.childNodes.length &lt; 1) return false;如果dlist没有子节点，那么直接跳出函数，这样就避免了报错的可能性。以下是改进后的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243function displayAbbreviations()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有缩略词 var abbreviations = document.getElementsByTagName('abbr'); if(abbreviations.length &lt; 1) return false; var defs = new Array(); // 便利这些缩略词 for(var i = 0;i &lt; abbreviations.length; i++)&#123; var current_abbr = abbreviations[i]; if(current_abbr.childNodes.length &lt; 1) continue; var definition = current_abbr.getAttribute('title'); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; &#125; // 创建定义列表 var dlist = document.createElement('dl'); // 遍历定义 for(key in defs)&#123; var definition = defs[key]; // 创建定义标题 var dtitle = document.createElement('dl'); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); // 创建定义描述 var ddesc = document.createElement('dd'); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; if(dlist.childNodes.length &lt; 1) return false; // 创建标题 var header = document.createElement('h2'); var header_text = document.createTextNode('缩略词'); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 如果浏览器不支持&lt;abbr&gt;标签，也不会出任何错误，但是也会看不到缩略语列表，不过缩略语列表也算不上页面必不可少的组成部分，如果真的是必不可少的内容，从一开始就应该把它包括在标记里。 5、显示文献来源链接表在这个案例中，还有另一个增强文档的例子，先来看看html中这段标记。 123&lt;blockquote cite="http://www.w3.org/DOM/"&gt; &lt;p&gt;一个平台和语言中立的接口，将允许程序和脚本动态访问和更新的内容，结构和风格的文档。&lt;/p&gt;&lt;/blockquote&gt; &lt;blockquote&gt;元素包含一个cite属性，它可以是一个URL地址，告诉人们&lt;blockquote&gt;元素的内容引自哪里，从理论上讲这是一个文献资料与县官网页链接起来的好办法。但实际上浏览器会完全忽略cite属性，所以我要把这些信息收集起来，以一种更有意义的方式把它们显示在网页上。 按照以下步骤完成displayCitetions函数，并存入Enrich_document_content.js文件中。 遍历这个文档里所有&lt;blockquote&gt;元素。 从&lt;blockquote&gt;元素提取出cite属性的值。 创建一个标识文本是source的链接。 把这个链接赋值为&lt;blockquote&gt;元素的cite属性值。 把这个链接插入到文献节选的末尾。 1234567891011121314151617181920212223242526272829function displayCitetions()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有引用 var quotes = document.getElementsByTagName('blockquote'); // 遍历引用 for(var i = 0;i &lt; quotes.length;i++)&#123; // 如果没有cite属性，继续循环 if(!quotes[i].getAttribute('cite')) continue; // 保存cite属性 var url = quotes[i].getAttribute('cite'); // 取得引用中的所有元素节点 var quoteChildren = quotes[i].getElementsByTagName('*'); // 如果没有元素节点进入下一次循环 if(quoteChildren.length &lt; 1) continue; // 取得引用中的最后一个元素节点 var elem = quoteChildren[quoteChildren.length - 1]; // 创建标记 var link = document.createElement('a'); var link_text = document.createTextNode('source'); link.appendChild(link_text); link.setAttribute('href',url); var superscript = document.createElement('sup'); superscript.appendChild(link); // 把标记添加到引用中的最后一个元素节点 elem.appendChild(superscript) &#125;&#125; 函数执行完毕后这个&lt;blockquote&gt;元素的引用将会添加到段落最后的source上标中。下面来解析一下这个函数。 第一部分是筛选出cite属性，再去获取&lt;blockquote&gt;元素的最后一个子节点，这里&lt;blockquote&gt;的lastChild有可能是个换行符，所以在函数中是获取的&lt;blockquote&gt;下的所有元素对象，这样就可以方便的获取&lt;blockquote&gt;的最后一个子元素。 第二部分是创建链接和插入链接，最终让&lt;sup&gt;元素包含&lt;a&gt;元素，而&lt;a&gt;元素href属性保存了cite的属性值，也就是一个url地址。最后将&lt;sup&gt;元素插入到&lt;blockquote&gt;元素的最后。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM编程艺术--五、动态创建标记]]></title>
      <url>%2F2017%2F06%2F03%2FDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E4%BA%94%E3%80%81%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[这一章节主要通过一些DOM方法，通过创建新元素和修改现有元素来改变网页结构，用DOM的方法改变标记。 1、创建元素节点和文本节点DOM是文档的表示，DOM所包含的信息与文档里的信息一一对应，你只要学会问正确的问题，就可以从获取DOM节点上任何一个节点的细节。 DOM是一条双向车道，不仅可以获取文档的内容，还可以更新文档的内容，如果改变了DOM节点树，文档在浏览器里的呈现就会发生变化，所以与其说是创建标记，不如说是在改变DOM节点树，在DOM的角度来看，一个文档就是一颗节点树，如果想在节点树上添加内容，就必须插入新的节点，如果想添加一些标记文档，就必须插入元素节点。 比如现有一个HTML元素&lt;div id = &quot;testdiv&quot;&gt;&lt;/div&gt;，我要在其中插入一段文本，需要4个步骤。 创建一个新的元素。 把这个新的元素插入节点树。 创建一个文本节点。 把文本节点插入新元素的节点树。 1234567window.onload = function()&#123; var pare = document.createElement('p'); var testdiv = document.getElementById('testdiv'); testdiv.appendChild(pare); var txt = document.createTextNode('Hello World'); pare.appendChild(txt);&#125; 这些代码会在页面上显示”Hello World”，并且包含在&lt;div id = &quot;testdiv&quot;&gt;&lt;/div&gt;中。 首先用document.createElement方法创建一个&lt;p&gt;元素，创建以后&lt;p&gt;元素还不是任何一颗DOM树的组成部分，它只是游荡在javascript世界里的一个孤儿，这种情况被称为文档碎片(document frogment)，不过，这时&lt;p&gt;元素已经有了自己的DOM属性，比如nodeType和nodeName。 现在要让&lt;p&gt;元素成为testdiv的一个子节点，appendChild方法可以完成这一任务，这个方法的语法是parent.appendChild(child)。 最后我要给&lt;p&gt;元素增加文本内容，也就是创建一个文本节点并让其成为&lt;p&gt;元素的子节点，使用document.createTextNode方法可以实现，用法和document.createElement相同，同样这个本文节点也是一个孤儿节点，需要使用appendChild添加到&lt;p&gt;元素中。 其实我也可以改变上面的执行顺序，先创建两个节点，再依次加入DOM树中也是一样的。 2、重回图片库案例现在图片库的html文件中有一个图片和一段文字仅仅是为showPic脚本服务的，既然这些元素的存在只是为了让DOM方法处理它们，那么用DOM方法来创建它们才是最合适的选择。动态创建需要完成的步骤如下： 创建一个img元素节点。 设置这个节点的id属性、src属性、alt属性。 创建一个p元素节点。 创建这个节点的id属性。 创建一个文本节点。 把这个本文节点追加到p元素上。 把p元素和img元素插入到gallery.html文档。 1234567891011121314151617function preparePlaceholder()&#123; if(!document.createElement) return false; if(!document.createTextNode) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var placeholder = document.createElement('img'); placeholder.setAttribute('id','placeholder'); placeholder.setAttribute('src','images/placeholder.gif'); placeholder.setAttribute('alt','my image gallery'); var description = document.createElement('p'); description.setAttribute('id','description'); var desctext = document.createTextNode('Chose an image'); description.appendChild(desctext); var gallery = document.getElementById('imagegallery'); insertAfter(placeholder,gallery); insertAfter(description,placeholder);&#125; 现在我可以将html中图片展示的元素和文字描述的元素删除了。 为了确保退路，函数的第一部分仍是检测浏览器是否支持这些方法，这里主要说一下insterAfter方法，它的功能是把一个节点插入到另一个节点之后，DOM本身并没有提供这个方法，所以我们可以自己编写一个函数。 12345678function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 这个函数的步骤如下： 这个函数有连个参数，第一个是要插入的新元素，第二个是目标元素。 获取目标元素的父元素，存到parent变量。 检测目标元素是不是其父元素的最后一个元素。 如果是就用appendChild把新元素追加到parent元素上。 如果不是就把新元素插入到目标元素和其下一个兄弟元素之间，使用nextSibling属性获取这个元素的下一个兄弟元素，使用insertBefore方法把下一个元素插入到另一个元素之前，语法是parentElement.insertBefore(newElement,targetElement)。 3、AjaxAjax主要用于异步加载页面内容的技术，用Ajax可以做到只更新页面的一小部分，不必刷新整个页面。 Ajax的优势就是对页面的请求以异步的方式发送到服务器，而服务器不会用整个页面来相应请求，它会在后台处理请求，与此同时用户还能继续浏览页面并与页面交互，而脚本则可以按需加载内容。 XMLHttpRequest对象Ajax技术的核心就是XMLHttpRequest对象，这个对象充当着浏览器中的脚本与服务器之间的中间人的角色，以往的请求都是浏览器发出，而javascript通过这个对象也可与自己发送请求，同时也自己处理响应。 不同浏览器对实现XMLHttpRequest对象方式不太一样，为了解决兼容性问题，我们可以自己封装一个函数。 1234567891011121314151617function getHttpObject()&#123; if(typeof XMLHttpRequest == 'undefind')&#123; XMLHttpRequest = function()&#123; try&#123; return new ActiveXObject('Msxml2.XMLHTTP6.0'); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject('Msxml2.XMLHTTP3.0'); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject('Msxml2.XMLHTTP'); &#125;catch(e)&#123;&#125; return false; &#125; &#125; return new XMLHttpRequest();&#125; 这个函数通过对象检测技术检测了XMLHttpRequest，如果失败则继续检测其他方法，最终返回一个false或新的XMLHttpRequest对象。 其中ActiveXObject是IE的实现方法，实现了一个名叫XMLHTTP的对象，IE版本中使用的XMLHTTP对象也不完全相同。 XMLHttpRequest发送请求的方法XMLHttpRequest对象有许多的方法，下面通过一个新的函数来具体看XMLHttpRequest的执行过程和方法，这里假设example.txt是接口的地址 1234567891011121314function getNewContent()&#123; var request = getHttpObject(); if(request)&#123; request.open('GET','example.txt',true); request.onreadystatechange = function()&#123; if(request.readyState == 4)&#123; var txt = request.responseText; &#125; &#125; request.send(null); &#125;else&#123; alert('你的浏览器不支持XMLHttpRequest') &#125;&#125; 首先最有用的就是open方法，用open方法来指定服务器上要访问的文件、指定请求类型、指定请求是否以异步的方法发送和处理。 onreadystatechange方法会在服务器给出回应的时候被触发执行，在这个函数中，可以根据服务器的具体响应做相应的处理。 send方法用于发送数据，通常写在指定请求的目标并明确如何处理响应之后。 服务器回响XMLHttpRequest的方法服务器在向XMLHttpRequest对象发送回响时，该对象有许多属性可用。 readyState属性，浏览器会在不同阶段更新readyState属性的值。 0 表示未初始化。 1 表示正在加载。 2 表示加载完毕。 3 表示正在交互。 4 表示完成。 所以只要readyState属性的值变为4，就可以访问服务器发送回来的数据了。 responseText和responseXML属性用于保存服务器发送回来的数据，responseText用于保存文本字符形式的数据，responseXML用于保存Content-Type头部中制定为’text/xml’的数据。 另外，只要是依赖于服务器响应的脚本，都要写在onreadystatechange属性的函数中，因为在发送XMLHttpRequest请求之后，脚本仍然会继续执行，不会等待响应返回，如果把依赖服务器返回内容的代码写在onreadystatechange之后，可能会导致这些代码执行了但数据还没有获取到。send方法就是最好的证明，它会优先于onreadystatechange执行。 Ajax应用的一个特色就是减少重复加载页面的次数，但这种缺少状态记录的技术会与浏览器的一些使用惯例产生冲突，导致用户无法使用后退按钮或者无法为特定状态下的页面添加书签，理想情况，用户每一次操作都应该得到一个清晰明确的结果，为此，web设计人员必须在向服务器发出请求和服务器返回相应时，给用户明确提示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM编程艺术--四、图片库改进]]></title>
      <url>%2F2017%2F06%2F03%2FDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E5%9B%9B%E3%80%81%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%2F</url>
      <content type="text"><![CDATA[在这一章主要是用上一章的思想改进图片库，所以我会把之前的javascript图片库案例拿来看看是不是符合上一章所说的规则。 1、支持平稳退化吗？可以确定，图片库如果禁用了javascript功能，也已经留了退路，网页里的所有链接都是可用的，虽然用户体验游影响，但网页的功能并未受到损害，而如果当时在href中写的不是链接而是伪协议或是’#’，那么禁用javascript后它会无法使用。 2、javascript与html分离吗？在图片库中它们确实是混在了一起，onclick直接插入到了html中，理想情况下，应该在外部文件里添加onclick事件处理函数。 我需要编写一个简短的函数把有关操作关联到onclick事件上，我想让函数完成以下工作： 检查浏览器是否理解getElementsTagByName。 检查浏览器是否理解getElementById。 检查网页是否存在一个id为imagegallery的元素。 遍历imagegalery元素中的所有链接。 设置onclick事件，让它在有关链接被点击时完成以下操作。 把这个链接作为参数传递给showPic函数。 取消链接被点击时的默认行为。 12345678910111213function prepareGallery()&#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i = 0; i &lt; links.length; i++)&#123; links[i].onclick = function()&#123; showPic(this); return false; &#125; &#125;&#125; 为了方便获取元素，我将&lt;ul&gt;的id设为’imagegallery’。 函数的第一部分是检查点，如果不支持或没有检查的内容就离开，其实也可以写为if(!document.getElementsByTagName || !document.getElementById) return false;将两个检查写到一起，但是这样写代码太过冗长不利于阅读，所以将代码写在一行并不一定是个好主意。 代码中我用变量名存储获取到的元素，避免了代码写得太长，在给变量起名时，应该选择一些有意义的单词来命名，可以让代码更容易阅读和理解，并且一定要避免使用保留字和函数或方法名。 函数的最后是一个遍历，links存储了列表中的所有a元素，并且是一个伪数组，所以可以遍历得到每个a元素并且将onclick事件绑定给该元素，这样绑定之后，该事件处理函数的this就是绑定该事件的元素，至此可以从html中彻底删除onclick事件了。 3、共享onload事件现在我还需要一个功能，就是要在DOM树加载完之后再执行上面的prepareGallery函数，如果只有一个函数用window.onload = prepareGallery即可，但如果有多个函数，就不能直接这样写，后面的会覆盖前面的，所以我还要再写一个函数完成这个绑定功能。 把现有的window.onload事件处理函数的值存入变量oldonload。 如果在这个处理函数上还没有绑定函数，就像平时那样把新函数添加给它。 如果在这个处理函数上已经绑定了函数，就把新函数追加到现有指令的末尾。 1234567891011function addLoadEvent(func)&#123; var oldonload = window.onload; if(typeof window.onload != 'function')&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; oldonload(); func(); &#125; &#125;&#125; 这个函数将把那些在页面加载完毕时执行的函数创建一个队列，参数func就是要执行的函数。 4、不要做太多的假设下面我要改造一下showPic函数，因为我发现showPic函数并没有任何检查和测试，所以需要一些语句来检查这些元素是否存在。 showPic函数负责完成两件事： 找出id属性是placeholder的图片并修改其src属性。这个是核心功能，必须完成的任务。 找出id属性是description的元素并修改其第一个子元素的nodeValue属性。这个功能只是锦上添花，所以只要placeholder图片存在，即使description元素不在，切换显示新图片的操作也将照常进行。 123456789101112function showPic(whichpic) &#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src", source); if(document.getElementById('description'))&#123; var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; &#125; return true;&#125; 现在这个函数完成了检测，只要图片可以正常获取就返回true，但是还有一个问题，就是如果把placeholder图片从标记文档里删掉，无论点击imagegallery清单里的哪一个链接，都没有任何反应，这不符合平稳退化，此时应该让浏览器打开那个被点击的链接，而不是什么都不发生。 导致这个问题的原因是prepareGallery函数中是假设showPic肯定会切换图片成功，基于这一点才取消了a元素onclick事件的默认行为links[i].onclick = function(){showPic(this);return false;}，但是现在在showPic中，如果图片切换成功才返回true，如果图片切换失败会返回false。所以如果showPic返回了false就不应该取消点击事件，而是该让a元素的链接正常打开，让切换图片的操作照常进行。所以是否取消默认行为应该由showPic函数决定。 为了达到这个目的，应该先验证showPic的返回值，以便决定是否阻止默认行为，如果showPic返回true，那么更新placeholder，取消默认事件。如果showPic返回false，那么就不取消默认事件。在onclick事件处理函数中，我们可以利用逻辑非来对showPic的返回值进行取反。 123links[i].onclick = function()&#123; return !showPic(this);&#125; 现在这个函数已经相当完善，虽然它们的长度有所增加，但它们对标记的依赖和假设已经比原来少多了，尽管如此，在showPic函数里仍存在一些需要处理的假设。 如果a元素的title属性存在，变量text将被赋值a元素的title属性，如果不存在，变量text将被赋值为一个空字符串。 假设placeholder元素是否是一张图片，可以用nodeName属性来测试，要注意的是，nodeName属性总是返回的值总是大写字母。 假设description元素的第一个子元素是一个文本节点，可以用nodeType属性来检测，如果nodeType的值是3，就是一个文本节点。 123456789101112131415function showPic(whichpic) &#123; if (!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); if (placeholder.nodeName != 'IMG') return false; placeholder.setAttribute("src", source); if (document.getElementById('description')) &#123; var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : ''; var description = document.getElementById('description'); if(description.firstChild.nodeType == 3)&#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125; showPic的代码变得更多了，在实际中，你需要自己决定是否真的需要这些检查，它们针对的是html文档有可能不再你的控制范围内的情况，但理想情况下，脚本不应该对html文档的内容和结构做太多假设。 5、键盘访问事件前面的代码只能用鼠标操作，而浏览器web页面也是可以用键盘进行操作的，有个名叫onkeypress的事件处理函数就是专门用来处理键盘事件的，按下键盘的任何一个按键都会触发onkeypress事件。 如果想把onkeypress事件加到上面的案例并完成和onclick相同的操作，只需要这样写links[i].onkeypress = links[i].onclick;，但是在这个案例中我认为并不需要键盘访问事件，有onclick事件足矣，我想说的是，在这里完全体现出了javascript和html分离带来的方便，如果像是最开始那样把javascript写在html中，将不得不去修改每行html语句，而现在只要在javascript代码中加一条语句即可。 6、DOM Core和HTML-DOM至此，我在编写javascript代码时只用到了以下几个DOM方法：getElementById、getElementsByTagName、getAttribute、setAttribute。 这些方法都是DOM Core的组成部分，它们并不是专属javascript语言，支持DOM的任何一种程序设计语言都可以使用它们，它们的用途也并非仅限于处理网页，它们可以用来处理任何一种标记语言(比如XML)编写出来的文档。像onclick属于HTML-DOM，它们在DOM Core出现之前很久就已经为人们所熟知，比如HTML-DOM提供了一个forms对象，写法是document.forms可以代替document.getElementsByTagName(forms)。还有element.src可以代替element.getAttribute。 它们的区别是HTML-DOM只能处理web文档，我使用DOM Core也是因为其兼容多种类型的文档，其实这个完全是根据使用场景来选择，并没有绝对的对错之分。 7、增加css1234567891011121314151617181920212223242526272829303132333435363738394041424344body &#123; font-family: "Helvetica","Arial",serif; color: #333; background-color: #ccc; margin: 1em 10%;&#125;h1 &#123; color: #333; background-color: transparent;&#125;a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none;&#125;ul &#123; padding: 0;&#125;li &#123; float: left; padding: 1em; list-style: none;&#125;img&#123; display: block;&#125;#imagegallery &#123; list-style: none; overflow: hidden;&#125;#imagegallery li &#123; display: inline;&#125;#imagegallery li a img &#123; border: 0;&#125; 8、把图片的文字链接改为缩略图12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" type="" href="./css/style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul id="imagegallery"&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" title = "A fireworks display"&gt; &lt;img src="images/thumbnail_fireworks.jpg" alt="Fireworks"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" title = "A cup of black offee"&gt; &lt;img src="images/thumbnail_coffee.jpg" alt="Coffee"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" title = "A red,red rose"&gt; &lt;img src="images/thumbnail_rose.jpg" alt="Rose"&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigben.jpg" title = "The famous clock"&gt; &lt;img src="images/thumbnail_bigben.jpg" alt="Big Ben"&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = "placeholder" src = "images/placeholder.gif" alt = "my image galley"/&gt; &lt;p id="description"&gt;Choose an image&lt;/p&gt; &lt;script src="script/script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM编程艺术--三、最佳实践]]></title>
      <url>%2F2017%2F06%2F03%2FDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E4%B8%89%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[1、平稳退化和渐进增强什么是平稳退化不管你想通过javascript个改变哪个网页的行为，都必须三思而后行，首先要确认，为这个网页增加这种额外的行为是否有必要。 在所有的javascript特效当中，最臭名昭著的莫过于那些在人们打开网页时弹出的广告窗口，不幸的是有不少用户为此干脆彻底禁用了javascript，这是一个典型的滥用javascript的例子，从技术上讲弹窗解决了如何向用户发送信息，但在实践中，频繁弹出的广告窗口却让用户不胜其烦，令人欣慰的是这一问题已经收到了所有人的关注，那些不遵守用户至上原则的网站都在自取灭亡。 所以如果要使用javascript就要确认，这么做会对浏览体验产生怎样的影响，最重要的是，如果用户的浏览器不支持或禁用了javascript的情况下仍能顺利浏览你的网址，这就是平稳退化。虽然某些功能无法使用，但最基本的操作仍能顺利完成。 举个例子以弹出窗口的例子来说明平稳退化的思想。这里并不是指在加载网页时弹出，而是点击后弹出，例如服务条款，邮费列表等等。 javascript使用window.open(url,name,features)来创建新的浏览器窗口。 参数1：新窗口里页面的url地址，省略这个参数就是一个空白网页。 参数2：新窗口的名字，代码可以通过这个名字与新窗口交互。 参数3：以逗号分隔的字符串，包括新窗口尺寸(工具条、菜单条、初始显示位置等等)。 123function popUp(winURL)&#123; window.open(winURL,"popup","width=320,height=480");&#125; 这个函数将打开一个320x480像素的新窗口”popup”。 使用popUp函数的一个办法是使用伪协议。 真协议用来在因特网上的计算机之间传输数据包，比如HTTP、FTP协议等，协议则是一种非标准化的协议。 1&lt;a href = "javascript:popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 通过”javascript:”为协议调用popUp()函数。 1&lt;a href = "#" onclick = "popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 这是内嵌式的事件处理函数，这个链接的href没什么用，所以用”#”，表示一个空连接，实际工作由onclick完成。 但是以上两种方法都很糟糕，因为它们都不能平稳退化。有以下两点原因。 用户如果禁用了javascript功能，这样的链接将毫无作用。 第二点是不利于搜索引擎排名，搜索机器人浏览web页的目的是把各种网页添加到搜索引擎的数据库，很少有机器人能理解javascript代码。 其实为javascript代码预留退路很简单，给href设置真实的URL地址。 1&lt;a href = "http://www.example.com/" onclick = "popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 这样即使javascript被禁用，这个链接也不是失效的，只是功能上打了点折扣，这是一个经典的平稳退化的例子。 渐进增强所谓”渐进增强”就是用一些额外的信息层去包裹原始数据，按照”渐进增强”原则创建出来的网页几乎都符合”平稳退化”原则，在一个网页中，良好的内容就是一切，只有正确的使用标记语言才能对内容做出准确的描述，CSS指令构成了一个表示层使文档呈现出各种模式，但即使去掉这个表示层，文档的内容也依然可以访问。 2、分离javascript就像css那样把style写到html文档中，虽然可以用，但是这种做法弊大于利，最好的方法是把样式信息存入一个外部文件。在文档的head部分用&lt;link&gt;标签调用这个文件，这样更容易阅读和理解，样式信息也更容易更改，不用去文档里逐一搜索和替换，这个结论同样适用于javascript。 现在我要把上面弹窗例子中的onclick事件分离出来。具体步骤如下： 把文档里的所有链接全放入一个数组里。 遍历数组。 如果某个链接的class属性等于popup，就表示这链接在被点击时应该调用popUp()函数 1234567891011121314window.onload = function()&#123; if(!document.getElementsByTagName) return false; var links = document.getElementsByTagName('a'); if(links.length &gt; 0)&#123; for(var i = 0;i &lt; links.length;i++)&#123; if(links[i].getAttribute('class') == 'popup')&#123; links[i].onlcick = function()&#123; popUp(this.getAttribute('href')); return false; &#125; &#125; &#125; &#125;&#125; 以上代码把调用popUp()函数添加到有关的链接上，存入一个外部javascript文件中。 这里使用了window.onload事件，当onload事件触发时代表整个文档已经加载完毕，当然也包括DOM树，我要让HTML文档先加载这样才可以生成DOM树，起码要在DOM树生成后才可以加载javascript文件，否则获取不到文档中的各个元素，即使把javascript文件放到body的底部，也不能保证哪个先加载结束，浏览器可能一次加载多个文件，因为javascript加载时文档可能还没加载完成，所以DOM也没有加载完，很多功能会无法使用。 3、向后兼容性上面的代码中，针对访问者可能未启用javascript功能的情况，需要进行对象检测，在这里用if语句检测访问者的浏览器是否支持document.getElementsByTagName方法。如果不支持，就不会再继续执行，直接return false;这是一种很常见的向后兼容的方法，适用于很多地方。 4、性能考虑在上面案例的for循环开始前检测是否获取到了a元素，没有的话后面的代码也没必要执行，这里将所有a元素存入link变量。出入对性能考虑，我们应该检查查询DOM中某些元素的操作，搜索整个DOM树对性能并没有好处，总之把搜索结果保存在一个全局变量里，或者把一组元素直接以参数形式传递给函数，是最好的方法。 另外，js文件在HTML标签中的位置对页面初次加载时间也有很大影响，通常我习惯放在head中，但位于head中的脚本会导致浏览器无法并行加载其他文件。根绝HTTP规范，浏览器每次从一个域名中最多可能同时下载两个文件，所以把script标签放到文档末尾，之前可以让页面加载更快]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM编程艺术--二、javascript图片库]]></title>
      <url>%2F2017%2F06%2F03%2FDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E4%BA%8C%E3%80%81javascript%E5%9B%BE%E7%89%87%E5%BA%93%2F</url>
      <content type="text"><![CDATA[从这一篇开始会逐步完成一个图片库的案例，但我们不能直接把所有的图片直接放到一个页面里，因为图片下载的时间较长，用户需要等待很长时间去加载一个网页，所以我们需要一个图片库，把整个图片库的浏览链接集中安排在主页里，只在用户点击了这个主页里的某个图片链接时才把相应的图片加载。 1、建立基础的HTML结构123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" title = "A cup of black offee"&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" title = "A red,red rose"&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigen.jpg" title = "The famous clock"&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2、改进图片库这个网页现在的功能是： 清单列表中的每个链接分别指向不同的图片，点击跳转到相应的图片页面。 从图片返回列表要借助于浏览器的back功能。 需要改进的地方： 点击某个链接时，能留在这网页而不是转到另一个窗口。 点击某个链接时，能在这个网页上同时看到那张图片及原有清单列表。 点击某个链接时，在图片的下方显示改图片的描述文字。 完成上述目标要完成的几项改进： 通过增加一个占位图片的办法在这个主页上为图片预留一个浏览区域。 点击某个链接时，拦截这个网页的默认行为。把占位图片替换为与那个链接相对应的图片。 点击某个链接时，获取链接的描述文字，保存到图片下方的位置。 第一步、增加占位图片html部分 1&lt;img id = "placeholder" src = "images/placeholder.jpg" alt = "my image galley"/&gt; js部分 12345function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source);&#125; 为了把占位图片替换为要查看的图片，需要一个方法来改变它的src属性。参数whichpic代表一个指向某个图片的a元素，变量source是参数a元素的href属性值，变量placeholder是占位图片的元素对象。 我们还有另一种方法，也就是非DOM方法，直接用placeholder.src = source;，效果等同于placeholder.setAttribute(&quot;src&quot;,source);，我选择DOM方法的原因是setAttribute是第1级DOM，它的兼容性和可移植性更好，DOM本身适用于任何一种标记语言，DOM是一种适用于多种环境和多种程序设计语言的通用型API，而非DOM方法只能适用于web浏览器，所以在以后的选择时，尽量选择DOM方法。 最后将该方法单独存为一个叫做show_pic.js的文件并引用。在实际开发中，可以将多个功能放到一个js文件中，这样可以减少对站点的请求次数，提高性能。 1&lt;script src="script/script.js"&gt;&lt;/script&gt; 第二步、事件处理函数事件处理函数的作用是在特定事件发生时，调用特定的javascript代码。这个案例中要使用的是onclick点击事件。 1&lt;a href = "images/fireworks.jpg" onclick = "showPic(this);return false;" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; 在每一条链接上增加onlcick事件和处理程序。showPic就是之前写好的方法，将this作为参数传进去，this这里指的就是a元素对象。 return false的作用是阻止默认行为被调用，a元素的默认行为是打开一个新窗口，我不需要这个效果，所以要组织。 事件处理函数的工作机制：在给某个元素添加了事件处理函数后，一旦事件发生，javascript代码便会执行，这些被调用的javascript代码可以返回一个值，这个值将被传递给事件处理函数，具体到此案例中，当onclick被触发时，如果执行的代码返回true，onclick事件处理函数就会认为这个链接被点击了，如果返回false，onclick事件处理函数就认为这个链接没有被点击，所以当onclick认为没有点击链接，自然也不会打开一个新链接。 第三步、增加图片描述文字现在我要用DOM给图片增加一段描述，这段描述的位置在img标签之后，同时也起到了占位符的作用 1&lt;p id="description"&gt;Choose an image&lt;/p&gt; 为了实现这个功能也需要扩展一下showPic函数。 获取a标签的title属性值，并存入变量text。 获取描述文本的元素，id值为description的p元素，保存到变量description。 把description对象的第一个子节点的nodeValue属性值设置为变量text的值。 12345678function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source); var text = whichpic.getAttribute('title'); // 1 var description = document.getElementById('description'); // 2 description.firstChild.nodeValue = text; // 3&#125; 这里设置描述文本我使用的是nodeChild属性，nodeChild属性可以设置和获取文本元素的文本内容。需要注意的是必须是文本节点。 比如description是一个元素节点，那么description.nodeChild获取的就是null，用description的子节点才有效description.firstChild.nodeChild，这里description只有一个子节点并且是文本节点，所以使用firstChild和lastChild都一样，如果description有好几个子元素，要获取其中的某个可以用children[index]来获取。 最终效果最后我们增加一些css样式来美化一下页面,创建style.css文件并引入html文件中。 123456789101112131415161718192021222324252627282930313233body &#123; font-family: "Helvetica","Arial",serif; color: #333; background-color: #ccc; margin: 1em 10%;&#125;h1 &#123; color: #333; background-color: transparent; &#125;a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none;&#125;ul &#123; padding: 0;&#125;li &#123; float: left; padding: 1em; list-style: none;&#125;img &#123; display: block; clear:both;&#125; 以下是script.js文件的最终内容 12345678function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source); var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text;&#125; html文件的最终结构如下 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" type="" href="./css/style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" onclick = "showPic(this);return false;" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" onclick = "showPic(this);return false;" title = "A cup of black offee"&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" onclick = "showPic(this);return false;" title = "A red,red rose"&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigben.jpg" onclick = "showPic(this);return false;" title = "The famous clock"&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = "placeholder" src = "images/placeholder.gif" alt = "my image galley"/&gt; &lt;p id="description"&gt;Choose an image&lt;/p&gt; &lt;script src="script/script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面的最终效果如下，点击i链接可以改变图片和描述文字。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记四]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%E6%9D%82%E8%AE%B0%E5%9B%9B%2F</url>
      <content type="text"><![CDATA[BOM操作的常用属性和方法open()：打开一个新的页面，格式为open(页面的url,打开的方式)，如果url为空则打开一个空白页面。如果打开方式为空，默认为新窗口方式打开。这个方法返回新窗口的window对象。 close()：关闭一个页面，但是这个方法有点兼容性问题，firefox默认无法关闭，chrome默认直接关闭，ie：询问用户。 navigator.userAgent：返回浏览器的名称和版本。 location：浏览器地址信息，本身不是字符串，是object格式。 location：就是url地址本身。 location.search：url中?后面的内容。 location.hash：url中#后面的内容。 窗口尺寸与大小可视区的尺寸：document.documentElement.clientWidth和document.documentElement.clientHeight。 滚动条滚动的距离：document.documentElement.scrollTop和document.documentElement.scrollLeft。在chrome浏览器中要使用document.body.scrollTop和document.body.scrollLeft。 元素内容的宽高：div.scrollHeight和div.scrollWidth。 文档的宽高：document.documentElement.offsetHeight和document.documentElement.offsetWidth。也可以使用document.body.offsetHeight和document.body.offsetWidth。 事件onscroll：当滚动条滚动的时候触发。 onresize：当浏览器尺寸改变的时候触发。 onfocus：当元素获取焦点时触发。 onblur：当元素失去焦点时触发。 focus()：给元素设置焦点。 blur()：让元素失去焦点。 select()：选择指定元素里面的文本内容。只能选择用户可以输入的内容。 onmousemove：鼠标在一个元素上移动时触发。 onkeydown：当键盘按键按下的时候触发。能够响应用户输入的元素才支持键盘事件，和焦点事件一样。如果按下不抬起来会连续触发。 onkeyup：当键盘按键抬起时触发。 oncontextmenu：当右键菜单显示出来时触发。 event事件对象：当一个事件发生时，这个对象发生的这个事件有关的一些详细的信息都会临时保存到event对象中，以便在需要时使用。 事件绑定标准浏览器的方法：div.addEventListener(事件名称，事件处理函数，捕获/冒泡);。false是冒泡，true是捕获。 有捕获。 事件名称没有on。 this指向调用该函数的对象。 事件执行的顺序是正序。 非标准浏览器方法：div.attachEvent(&#39;on&#39;+事件名称，事件处理函数); 没有捕获。 事件名称有on。 this指向window(可以通过call()来解决这个问题)。 事件执行的顺序是倒序。 事件取消非标准浏览器方法：div.dettachEvent(&#39;on&#39;+事件名称,事件处理函数); 标准浏览器方法：div.removeEventListener(事件名称，事件处理函数，捕获/冒泡) 事件流事件流和样式位置没关系，和html的结构有关系 事件冒泡：当一个元素接收到事件的时候，会把它接收到的所有事件传播给它的父级，一直到顶层(window)。父级元素只要有相关的事件处理函数，那么就会被执行。阻止冒泡设置事件函数：event.cancelBubble = true; 冒泡最主要的作用是父元素和子元素都需要的事件处理函数，只需要绑定给父元素就可以了，而如果希望只有子元素才执行的事件处理函数可以通过设置阻止冒泡来接解决。 事件捕获：捕获和冒泡相反，是从最外层元素传播到目标元素。其他并没什么不同。 控制事件是捕获还是冒泡是由addEventListener中的第三个参数决定的，false为冒泡事件监控是出去的由内向外的，true为捕获事件监控是进来的由外向内的。 cookiecookie的作用就是存储数据。长时间去保存一个值，比如用户上次访问的时间等。 当用户访问了某个网站时候，可以通过cookie向访问者的电脑上存储数据，每个浏览器存储的位置不同，所以不同浏览器存储的cookie不能互相通用。 cookie的存储是以域名的形式区分的，也就是说每个网站的cookie文件是不同文件夹存放的，一个域名下的cookie也可能有多个文件。所以每个cookie文件是可以设置名字的。否则cookie文件会很大很乱。 document.cookie = &#39;username=ypj&#39;;这就设置了一个cookie文件的名字和值。 document.cookie;读取当前网站下的下所有的cookie的内容，是字符串格式。 一个域名下存放cookie的个数是有限制的，不同浏览器存放的个数不同。 每个cookie存放的内容大小也是有限制的，也是根据浏览器不同限制也不同。 默认情况下，cookie的周期是整个浏览器结束进程的时候。 如果想长时间存放一个cookie，需要在设置这个cookie的时候同时给他设置一个过期的时间。当过期后cookie就会被销毁。 123var oDate = new Date();oDate.setDate(oDate.getDate() + 5); // 保存5天document.cookie = 'username=ypj;expires=' + oDate.toGMTString() // 将oDate又object转为string; cookie在存储特殊字符的时候可能会出现问题，需要通过encodeURI()编码来解决。解码使用decodeURI()方法。参数都是字符。 用js读取cookie时候只能获取整个字符串，没法直接获取某个cookie的键值，同样设置的时候也不方便，所以可以写两个方法来方便操作。 获取cookie 123456789function getCookie(key)&#123; var arr1 = document.cookie.split(';'); for(var i = 0;i &lt; arr1.length;i++)&#123; var arr2 = arr1[i].split('='); if(arr2[0] == key)&#123; return decodeURI(arr[1]); &#125; &#125;&#125; 设置cookie 12345function setCookie(key,value,t)&#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + t); document.cookie = key + '=' + value + ';expires=' + oDate.toGMTString();&#125; 删除cookie 123function removeCookie(key)&#123; setCookie(key,'',-1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo配置]]></title>
      <url>%2F2017%2F06%2F01%2Fhexo%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[安装hexo安装过程使用以下命令下载hexo $ npm install hexo-cli -g 如果在安装过程中遇到以下错误 ERROR Deployer not found : github 则运行以下命令,或者你直接先运行这个命令更好。 $ npm install hexo-deployer-git --save 新建hexo的文件夹，以后的博客相关的操作都在这个文件夹里边，不要有中文目录。在该文件夹内部执行下面命令 $ hexo init 安装依赖包 $ npm install hexo常用的命令 $ hexo g 完整命令为hexo generate，用于生成静态文件。 $ hexo s 完整命令为hexo server，用于启动服务器，主要用来本地预览。 $ hexo d 完整命令为hexo deploy，用于将本地文件发布到github上。 $ hexo n 完整命令为hexo new，用于新建一篇文章。 查看hexo的本地服务器网页 http://localhost:4000/ 连通githubgithub中的项目名称必须是name.github.io格式 编辑本地hexo目录下的_config.yml文件。以下配置的name要改成自己的 1234deploy: type: git repository: http://github.com/name/name.github.io.git branch: master 配置好之后使用$ hexo g和$ hexo d发布到github。第二个命令会要求输入github的账号密码。如果成功的话打开name.github.io就可以查看博客了。 最好已经搞定了ssh配置，否则每次都要输入密码。 正式发布博客按照自己的意愿修改完后，执行$ hexo g，$ hexo s，打开localhost:4000看看效果。 新建一篇博客$ hexo new &quot;my new post&quot; 在\hexo\source\_post中打开my-new-post.md，开始编辑。 1234567title: my new post #可以改成中文的，如“新文章”date: 2015-04-08 22:56:29 #发表日期，一般不改动categories: blog #文章文类tags: [博客，文章] #文章标签，多于一项时用这种格式，只有一项时使用tags: blog---#这里是正文，用markdown写，你可以选择写一段显示在首页的简介后，加上&lt;!--more--&gt;#在&lt;!--more--&gt;之前的内容会显示在首页，之后的内容会被隐藏，当游客点击Read more才能看到。 写完文章后，使用$ hexo g生成静态文件。$ hexo s在本地预览效果。$ hexo d同步到github，然后使用http://name.github.io进行访问。 清除缓存清除缓存文件db.json和已生成的静态文件public。如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 $ hexo clean 文章的各种格式https://hexo.io/zh-cn/docs/tag-plugins.html next主体设置下载主题$ cd your-hexo-site打开电脑的hexo站点目录。$ git clone https://github.com/iissnan/hexo-theme-next themes/next 在hexo的配置文件中设置theme: next。 主题设定在主题配置文件中可以设置三种主题。 1scheme: Muse || Mist || Pisces 语言设置在hexo配置文件中设置language: zh-Hans。这是简体中文，英文是en。 设置菜单菜单设置包括三个部分，菜单项、菜单项显示文本、菜单项对应图标。在主题配置文件中设置 1234567menu: home: / #主页 archives: /archives #归档页 #about: /about #关于页 categories: /categories #分类页 tags: /tags #标签页 commonweal: /404.html #公益404 现在菜单的文字是固定的，如果要修改文字要打开themes\next\languages\zh-Hans.yml去设置对应中文名称，也可以新建。 图标设置在主题配置文件下,与菜单设置一一对应。 123456789menu_icons: enable: true # Icon Mapping. home: home #about: user categories: th tags: tags archives: archive commonweal: heartbeat 设置侧栏通过修改主题配置文件控制侧栏行为，一个是侧栏位置，一个是侧栏显示时机。 侧栏位置： 12sidebar: position: left 侧栏的行为 12sidebar: display: post #目录列表时显示 || always #一直显示 || hide # 一直隐藏 || remove #完全移除 设置头像主题配置文件中 1avatar: /images/avatar.png # 路径是next/source/images/ 昵称和描述站点配置文件中author参数是昵称，description参数是站点的描述 设置字体在主题配置文件中查找font字段修改。各项所指定的字体将作为首选字体，当他们不可用时会自动 Fallback 到 NexT 设定的基础字体组： 非代码类字体：Fallback 到 “PingFang SC”, “Microsoft YaHei”, sans-serif 代码类字体： Fallback 到 consolas, Menlo, “PingFang SC”, “Microsoft YaHei”, monospace 添加菜单栏的页面打开hexo的目录站点下，运行hexo new page categories，这样就新建了categories页面，其他菜单类似，新建之前先去删除之前的。 侧边栏社交在主题配置文件中设置 设置显示文本和链接地址 123social: GitHub: https://github.com/your-user-name 微博: http://weibo.com/your-user-name 设定链接的图标 123social_icons: GitHub: github 微博: weibo 设置友情链接 1234links_title: Linkslinks: MacTalk: http://macshuo.com/ Title: http://example.com/ ### 设置动画效果 在主题配置文件中设置，要等到js加载完才会显示动画和内容。 12use_motion: true # 开启动画效果use_motion: false # 关闭动画效果 设置动画背景自带两种动画效果，在主题配置文件中设置 1234567# canvas_nestcanvas_nest: true //开启动画canvas_nest: false //关闭动画# three_wavesthree_waves: true //开启动画three_waves: false //关闭动画 添加百度/谷歌/本地 自定义站点内容搜索安装 hexo-generator-searchdb，在站点的根目录下执行以下命令npm install hexo-generator-searchdb --save hexo站点配置文件新增配置 12345search: path: search.xml field: post format: html limit: 10000 主题站点配置文件设置 123# Local searchlocal_search: enable: true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记三]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%E6%9D%82%E8%AE%B03%2F</url>
      <content type="text"><![CDATA[DOM操作的一些常用属性和方法元素节点的nodeType是1 属性节点的nodeType是2 文本节点的nodeType是3 节点的获取childNodes：获取某个元素下的所有子节点，包含文本节点和元素节点。 children：获取某个元素下的所有元素子节点。 nextElementSibling：获取元素的下一个兄弟元素节点。 previousElementSibling：获取元素的上一个兄弟元素节点。 firstElementChild：获取元素下的第一个元素子节点。 lastElementChild：获取元素下的第一个元素子节点。 parentNode：获取元素的父节点。 nodeValue：查看节点的属性值。 nodeName：查看节点的属性名。 nodeType：查看节点的类型。 属性的获取和设置offsetParent：获取最近有定位属性的祖先节点。如果没有直接获取body。 offsetLeft：左外边框到有定位的最近的父级元素的内边框的距离。不带px单位。父级没有带定位的就是到body的距离。 offsetTop：上外边框到有定位的最近的父级元素的内边框的距离。不带px单位。父级没有带定位的就是到body的距离。 getAttribute()：获取元素的行内设置的属性值。参数是属性名。 setAttribute()：设置元素的行内设置的属性值。参数是属性名和属性值。 removeAttribute()：删除元素的行内设置的属性值。参数是属性名。 getBoundingClientRect()： 当前元素距离body的四个方向的距离和宽高的对象。获取的值会随着页面滚动位置而改变。值是不带单位的。 clientWidth：获取元素不计算边框的宽度。document.documentElement.clientWidth是浏览器窗口可是区域的宽度。 clientHeight：获取元素不计算边框的高度。document.documentElement.clientHeight是浏览器窗口可是区域的高度。 offsetWidth：获取元素计算边框的宽度。 offsetHeight：获取元素计算边框的高度。 操作节点document.createElement()：创建一个元素节点，参数是元素的名称，字符串格式。 appendChild()：将一个元素节点添加到另一个元素节点的最后，格式为父节点.appendChild(要添加的节点)。 insertBefore()：将一个元素节点添加到一个元素节点的指定子节点的前面。格式为父节点.insertBefore(要添加的节点,添加到这个节点之前)，假如第二个参数是不存在的，节点将会添加到父节点的最后。 removeChild()：删除一个指定的元素子节点，如果指定的节点找不到会报错。格式为父节点.removeChild(要删除的节点)。 replaceChild()：替换一个元素节点，格式是父节点.replaceChild(要添加的节点,被替换的节点)。 cloneNode()：克隆一个元素节点，默认只会克隆节点本身，不会克隆它的子节点，如果要将这个节点下的所有子节点也都克隆需要传参数true，格式为要克隆的节点.cloneNode(true)。 appendChild()、insertBefore()、replaceChild()在操作一个已有元素时，是将已有元素移动，而不是复制一份进行操作。 操作表格对于表格的操作javascript提供了一些简单的获取方式。 假设table是已经获取到的表格元素。 table.tHead：获取表格头部。 table.tFoot：获取表格底部。 table.tBodies：获取表格主体。 table.tBodiesn.rows[n]：获取表格的行，就是tr。 table.tBodiesn.rows[n].cells[n]：获取单元格，就是td。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记二]]></title>
      <url>%2F2017%2F06%2F01%2Fjavascript%E6%9D%82%E8%AE%B02%2F</url>
      <content type="text"><![CDATA[日期对象常用方法new Date() 获取当前时间 以下获取的都是数值类型。 getFullYear() 获取年 getMonth() 获取月份，从0开始算 getDate() 获取天 getDay() 获取星期几，0是周日 getHours() 获取小时 getMinutes() 获取分钟 getSeconds() 获取秒 getTime() 时间戳，返回从1970年1月1日0点0分0秒0毫秒开始计算的毫秒时间。 获取一个时间点设定一个时间点new Date(2017,4,22,22,48,20); 得出的是毫秒。 也可以通过new Date(&#39;November 10,2013 22:3:0&#39;);来获取。主要是用来计算倒计时用到。 毫秒的转换毫秒转为天：Math.floor(毫秒 / 86400) 毫秒转为小时：Math.floor(毫秒 % 86400 / 3600) 毫秒转为分钟：Math.floor(毫秒 % 86400 % 3600 / 60) 毫秒转为秒：毫秒 % 60 英文的月份一月 January、二月 February、三月 March、四月 April、五月 May、六月 June、七月 July、八月 August、九月 September、十月 October、十一月 November、十二月 December。 字符串的方法length字符串长度，字符串里的空格也占用一个长度 charAt()返回字符串索引位置的字符，如果不传参数默认获取第一个。 123var str = 'abs';alert(str.charAt(1)) // balert(str.charAt()) // a charCodeAt()使用方式和charAt相同，区别是返回的是字符的编码值 String.fromCharCode()参数里输入一个编码，返回相对应的字符，多个编码用逗号间隔 indexOf()返回查找字符在字符串中的索引位置，没找到返回-1。 &#39;str&#39;.indexOf(&#39;t&#39;) //1返回t在字符串str中的索引位置。 &#39;strstr&#39;.indexOf(&#39;t&#39;,2) // 4从strstr字符串的索引2的位置r之后开始找t的位置。不能是负数。 indexOf()每次只能返回查找到的第一个索引位置，如果要查找所有的索引位置需要写一个循环 1234567var str = 'aaabaaababaaaaaaaabaaab';var s = 'b';var i = 0;while( str.indexOf(s,i) != -1 )&#123; alert( str.indexOf(s,i) ); i = str.indexOf(s,i) + s.length;&#125; 这个循环会打印b在字符串中的所有索引位置 lastIndexOf()和indexOf()相对应，indexOf()是从左往右找，lastIndexOf()是从右往左找。第二个参数索引值也是从右向左查找。 字符串的大小比较中文字符也是可以进行比较的，比如&#39;山东&#39; &gt; &#39;青岛&#39;，比较的是第一个字符的编码值的大小，也就是山的编码值和青的编码值的比较，和后面的所有字符没有关系。 同样的道理，&#39;aaaabbbb&#39; &gt; &#39;c&#39;，比较的是a和c的大小，和后面字符没有关系。&#39;1000&#39; &gt; &#39;2&#39;比较的也是1和2的编码值的大小。 substring()截取类方法，对字符串当中的某些文字进行截取。负数会直接当0来处理。 传入一个参数时，从字符串的参数数值的索引位置开始截取后面的所有内容。 传入两个参数时，截取字符串参数一的索引到参数二的索引之间的字符。另外，如果第二个参数比第一个参数小那么会自动调换两个参数的位置。 123var str = 'abcdefg';alert(str.substring(4); // efg alert(str.substring(0,2); // ab slice()和substring()用法基本一样。但是传两个参数时不会交换位置。 和substring()方法不同的是： 只传入一个参数并且是负数，那么就是从字符串的最后开始截取。 传入两个参数，通常第一个是负数第二个也是负数，截取两个参数索引之间的字符 123var str = 'abcdefg';alert(str.slice(-1)) // falert(str.slice(-4,-2)) // cd toUpperCase()字符串转为大写，只能针对英文 toLowerCase()字符串转为小写，只能针对英文 split()将字符串分割为数组。参数是按照什么字符分割，如果不传参数默认会将整个字符串当做一个数组的一个元素。 12345var str = 'www.baidu.com';alert(str.split('.')) // ['www','baidu','com'];var str1 = 'abc';alert(str1.split('')) // ['a','b','c']; 第二个参数是限制截取多少段。 12var str = '2017-05-27-19-47';alert(str.split('-',3)); // ['2017','05','27'] 数组的方法push()在数组最后一位添加一个元素，返回值是增加后的数组的长度。 unshift()在数组第一位插入一个元素，返回值是增加后的数组的长度。ie6、ie7不支持这个方法的返回值。 pop()从数组的最后删除一个元素，返回值是删除的那个元素。 shift()从数组的开头删除一个元素，返回值是删除的那个元素。 splice()splice方法可以删除、替换、添加 删除时候可以传两个参数，第一个是开始删除的索引，第二个是删除的长度。返回值是删除的元素。 替换的话将要替换的内容写在第二个参数之后。返回值仅是被删除的内容。 添加的时候第一个参数是要添加的后面那个元素的索引，第二个参数是0，代表不替换，要添加的元素写在第二个参数之后。没有返回值 1234var arr = ['a,'b','c','d','e'];arr.splice(0,2) // arr = ['c','d','e']arr.splice(0,2,'z','x') // arr = ['z','x','c','d','e']arr.splice(1,0,'x') // arr = ['a','x','b','c','d','e'] sort()对数组进行排序，默认全部按照字符串的规则进行排序，会将数字转为字符串，然后按照字符串的比较方式，由小到大排序。 12var arr = [4,3,2,30];arr.sort(); // arr = [2,3,30,4] 要按照数值类型来排序的话需要在sort内部写一个函数 1234arr = [4,3,2,30];arr.sort(function(a,b)&#123; return a - b&#125;) 这里用a-b代表从小到大排序，意思是第一个数减第二个数。 也可以b-a是从大到小排序。是第二个数减第一个数。 只要return 为true，那么就会换位置。 join()将数组转为字符串，用传入的参数去分割数组每个元素，组成一个字符串，如果不传参数默认用逗号分割。 concat()将多个数组拼接起来，参数可以传过个，传几个就连接几个，会拼成一个新的数组，不会改变原来的数组。 123var arr1 = [1,2,3];var arr2 = [4,5,6];alert(arr1.concat(arr2)); // [1,2,3,4,5,6] reverse()颠倒数组内部元素的位置。对字符串也可以进行操作，只是从头到尾颠倒位置。不会进行比较。 12var arr = [1,2,3,4];arr.reverse(); // arr = [4,3,2,1] Math系列方法Math.random()产生0-1之间的随机数 Math.round()对参数进行四舍五入操作。 生成5-10之间的随机数1Math.round( Math.random() * 5 + 5 ) 通常第二个加的数是区间中那个下限的数，第一个乘的数是区间上限的数与第二个加的数的差值。 当求一个x-y之间的数公式就是：Math.round( Math.random() * ( y - x ) + x )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css杂记一]]></title>
      <url>%2F2017%2F05%2F21%2Fcss%E6%9D%82%E8%AE%B0%E4%B8%80%2F</url>
      <content type="text"><![CDATA[word-spacing 单词间距判断是否是单词的依据是有没有空格 行高的测量方式假如文字是12px，行高是16px，那么文字上下空隙分别是2px，假如行高是15px，那么上方是1px，下方是2px。 white-space 强制不换行值为nowrap为强制不换行，默认是normal。 text-indent 首行缩进。通常设置em，这样文字尺寸改变了也不用该缩进值，只需要设置2em便一直是2个字的距离。 文字和空格的大小字体本身原本是一张张的图片，通过一定的编码方式确定是哪个文字，文字和文字之间本身也有一定的缝隙，算上缝隙才算是一个文字的大小，所以文字大小最好是从上到下测量。而宋体中一个空格的大小差不多是一个文字的一半。 伪类的顺序a:link 未访问过,a:visited 访问过后,a:bover 鼠标移入,a:active 鼠标按下。 clear属性给一个元素加上clear属性，那么对应方向上的元素就不会浮动了。值可以设置为left|right|both|none|inherit。clear:both是左右两侧都不能浮动。 清除浮动的方法清除浮动是为了让元素回归文档流，回归到同一层级。 加高度给浮动元素的父元素加一个固定的高度。缺点是扩展性不好。有时候高度不能写死。 父级浮动给浮动元素的父元素加浮动，缺点是父元素的父元素仍然会有问题，当前元素的父元素同时也是更上级元素的子元素。而且margin:0 auto;会失效 inline-block给浮动元素的父元素加inline-block，缺点也是margin:0 auto;会失效 使用空白元素在浮动元素的后面增加一个没有内容的块级元素设置css为clear:both。缺点是只要清除浮动就要放一个空白元素，而且ie6仍会有2px的默认高度。 br在浮动元素后面增加一个&lt;br clear=&quot;all&quot; /&gt;。缺点也是只要清除浮动就要放一个空白元素。 伪类清除浮动假设浮动元素的父元素添加一个class名为clearfix。 12345678.clearfix &#123; *zoom:1;&#125;.clearfix:after &#123; content:&apos;&apos;; display:block; clear:both;&#125; zoom是为了兼容ie浏览器，当设置了zoom之后会检索设置对象的缩放比例，所设置的元素就会扩大或缩小，高度就被重新计算了，所以可以清除浮动，*号是hack的写法，只有ie6、7浏览器可以识别。 overflow给浮动元素的父元素设置overflow:hidden。原理是触发BFC。缺点是比浮动长的内容会被直接剪裁掉。 BFC和haslayoutBFC(block formatting context):BFC是块级元素格式化上下文。是标准浏览器块级元素的标准(除了ie6、7、8之外都是标准浏览器)。 haslayout:ie浏览器特有的。 只要触发了这两个其一，那么这个触发的区域就是一个独立的区域不受外界影响，也可以理解为元素就不会脱离标准文档流了。 触发BFC的情况 float的值不会none。 overflow的值不为visble(这就是overflow:hidden可以清楚浮动的原理，让其触发BFC)。 display的值为table-cell、table-caption、inline-block中的任何一个。 position的值不为relative和staic。 width|height|min-width|min-height的值不是auto的时候。 触发haslayout的情况 zoom的值不会normal的时候。给ie浏览器设置zoom:1清楚浮动就是为了触发haslayout。 css hack \9所有ie10及以下的浏览器。\9是写在属性值的后面。 *ie7及以下浏览器，写在属性的开头。 _ie6及以下浏览器，写在属性的开头。 hack的书写顺序要从高版本往低版本写，因为css是按照顺序执行，后面的覆盖前面的，所以先做统一处理，最后再去处理个别低版本浏览器。另外hack不是一个标准的方法，所以一般不要使用。 禁止选中文字不同的浏览器设置的内容不一样，user-select不是一个W3C的标准，浏览器的支持不完成，需要对不同的浏览器进行调整。 user-select有2个值（none表示不能选中文本，text表示可以选择文本） 123456789-moz-user-select:none; /*火狐*/-webkit-user-select:none; /*webkit浏览器*/-ms-user-select:none; /*IE10*/-khtml-user-select:none; /*早期浏览器*/user-select:none; ie6至ie9还没发现有css属性支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript杂记一]]></title>
      <url>%2F2017%2F05%2F21%2Fjavascript%E7%AC%94%E8%AE%B01%2F</url>
      <content type="text"><![CDATA[this的基本用法首先有一个函数 123function fn1()&#123; alert(this);&#125; 直接调用则this指向window 1fn1(); // 指向window; 如果是被元素对象调用 123456div.onclick = function()&#123; var _this = this; // 这个this指的就是div元素对象 fn1(); // 这里打印的this值的就是window，因为上面fn1函数的环境就是在全局，所以如果直接调用函数，那么this都是window&#125;div.onclick = fn1; // 这里打印的this就是div元素对象，这里已经改变了fn1函数的环境，赋值给了div元素对象的事件属性中，环境自然也从全局变为div元素对象。 判断浏览器名称123456789101112131415161718function myBrowser()&#123; var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串 if (userAgent.indexOf("Opera") &gt; -1) &#123; //判断是否Opera浏览器 return "Opera" &#125;; if (userAgent.indexOf("Firefox") &gt; -1) &#123; //判断是否Firefox浏览器 return "FF"; &#125;; if (userAgent.indexOf("Chrome") &gt; -1)&#123; //判断是否Chrome浏览器 return "Chrome"; &#125; if (userAgent.indexOf("Safari") &gt; -1) &#123; //判断是否Safari浏览器 return "Safari"; &#125; if (userAgent.indexOf("compatible") &gt; -1 &amp;&amp; userAgent.indexOf("MSIE") &gt; -1) &#123; //判断是否IE浏览器 return "IE"; &#125;;&#125; 火狐浏览器禁止页面滚动12345if (navigator.userAgent.toLowerCase().indexOf('firefox')&gt;=0)&#123; if (e.preventDefault) e.preventDefault(); e.returnValue = false;&#125; 鼠标滚轮事件非FireFox浏览器是使用onmousewheel事件，而FireFox浏览器使用DOMMouseScroll事件。 非FireFox浏览器使用的是wheelDelta方法判断滚动方向，FireFox浏览器使用的是detail方法判断滚动方向。 wheelDelta:-120和detail:3 代表向下滚动。wheelDelta:120和detail:-3代表向上滚动。 12345678document.body.onmousewheel = function(event) &#123; event = event || window.event; console.log(event.wheelDelta)&#125;;document.body.addEventListener("DOMMouseScroll", function(event) &#123; console.log(event.detail)&#125;); jquery兼容性的滚轮事件12345678910111213$('#scrollSelect-view').on("mousewheel DOMMouseScroll", function (e) &#123; var delta = (e.originalEvent.wheelDelta &amp;&amp; (e.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) || // chrome &amp; ie (e.originalEvent.detail &amp;&amp; (e.originalEvent.detail &gt; 0 ? -1 : 1)); // firefox if (delta &gt; 0) &#123; // 向上滚 console.log("wheelup"); &#125; else if (delta &lt; 0) &#123; // 向下滚 console.log("wheeldown"); &#125;&#125;); 自定义属性有时候写方法时会定义大量变量，有的变量其实比较多余，很多数据可以存储到元素对象的自定义属性中去。这样不用去考虑作用域的问题，因为只要这个元素对象存在在这个方法内就可以去使用，但是最好只保存和这个元素对象有关的属性。 比如：下面代码就是，在事件处理函数内部只能获取i循环完毕之后的值，而通过把i的值作为元素对象的自定义属性赋值，就没有作用域的限制。 1234567for(var i = 0; i &lt; 5; i++) &#123; div.index = i; div[i].onclick = function()&#123; alert(i); alert(this.index); &#125;&#125; 排他思想和清空上一个排他通常在tab栏切换中经常用到排他，比如有10个选项，只有当前项才有背景色，通常颜色是通过一个类名挂钩到css中去设置的，那么排他就是每次先将所有导航选项的类名清空，然后只给当前点击的这个元素对象添加类名。 1234567891011for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始排他 for(var i = 0; i &lt; Lis.length;i++)&#123; Lis[i].className = ''; &#125; // 单独设置当前选项 Lis[this.index].className = 'active'; &#125;;&#125;; 清空上一个这种效果除了排他之外还可以通过清除上一个选项来完成。创建一个变量存储上一个选中元素，在点击当前元素时候清空上一个类名，之后把自己赋值给这个变量，如此每次只需要清空一个元素的类名即可。 1234567891011121314var oElem = null;// 初始化，默认第一个元素是当前项Lis[0].className = 'active';Elem = Lis[0];for(var i = 0;i &lt; Lis.length;i++)&#123; Lis[i].index = i; Lis[i].onclick = function()&#123; // 这里开始清空上一个 Elem.className = ''; Elem = this; Lis[this.index].className = 'active'; &#125;;&#125;; jquery的stop()方法$(selector).stop(stopAll,goToEnd) stopAll 可选。规定是否停止被选元素的所有加入队列的动画。 goToEnd 可选。规定是否允许完成当前的动画。该参数只能在设置了 stopAll 参数时使用。 使用懒加载插件使用的 jquery.lazyload 调用下载好的插件 123456$(function()&#123; $("img.imglazyload").lazyload(&#123; threshold : 200, effect : "fadeIn" &#125;);&#125;); html部分，一定要在外层包一个div并且设置宽高，不要用图片去撑开。 123&lt;div class="item-image"&gt; &lt;img class="imglazyload" data-original="图片地址"&gt;&lt;/div&gt; js中的NaN NaN是一个数字类型但不是一个数值。 出现NaN肯定是进行了非法操作而不是获取数值有错，如果获取数值有错是undefind。 NaN与自己本身也是不相等的。 NaN转为布尔是false。 NaN本身的意思是’不是一个数值’ isNaN可以判断某些类型是不是一个数字类型。如果判断到是一个数字为false(不是一个数值这个判定是错的)，而不是数字类型的是true(不是一个数值这个判定是对的)。 NaN在判断时是在内部使用Number()方法转换，所以是不是数字类型的依据主要是看Number()转出的是什么类型。比如布尔值、空字符串、字符串数字都会被认为是数字类型而返回false。 js的作用域基础作用域实际上是浏览器js解析器的一种工作方式。 浏览器的js解析器在读取javascript代码时会先提升变量和函数，再去逐行解读代码。这是每个作用域的解析步骤。 预解析根据var、function、参数 找一些东西。 首先js解析器会搜索所有var和function找到所有变量，var声明的变量提升时值都是未定义，提升function时候会将整个函数代码块一起提升。 当var和function重名时，会保留function，覆盖var,但是如果两个以上同名的function，那么就看声明的先后顺序了。 逐行解析变量提升之后，js解析器会开始逐行解析代码，这时只有表达式可以改变变量的值，用下边的案例来说明。 1234567891011alert(a); // function a()&#123;alert(4);&#125;var a = 1;alert(a); // 1function a()&#123;alert(2);&#125;alert(a); // 1var a = 3;alert(a) // 3function a()&#123;alert(4);&#125;alert(a); // 3a(); // 报错 第一个alert打印出函数的原因是变量提升的规则，后面的a打印的都是变量的值而不是函数，因为变量赋值是一种表达式，而函数只是一个声明并不是表达式。并且因为现在a是一个数值，所以调用时自然会报错。 多组script自上而下的作用域大部分指的是多组script标签，如下代码 12345678910&lt;script&gt; alert(a); // 报错&lt;/script&gt;&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; alert(a); // 1&lt;/script&gt;/ 如果碰到这种情况，js解析器会对每个script代码块进行独立预解析和逐行解析，第一块script的代码还没声明a，第二块script的代码声明和赋值了，这时到第三块script代码块时a已经声明并赋值了，所以直接会打印1。 函数由内而外主要指函数，一个函数也是一个单独的作用域，javascript中，函数是唯一能分隔作用域的。 1234567var a = 1;function fn1()&#123; alert(a); var a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1()&#123; alert(a); a = 2;&#125;fn1(); // 1alert(a); // 2 第一个例子中在函数内部声明了a，那么在fn1中的a变量就和上级作用域的a变量没有任何关系了。按照预解析的步骤这里打印的是undefined。 第二个例子没有声明a变量，所以在fn1作用域中就找不到a，这时就会去上级作用域中寻找，上级作用域声明了a并且赋值为1了，所以打印1。 如果是下面这种情况 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(); // undefinedalert(a); // 1 1234567var a = 1;function fn1(a)&#123; alert(a); a = 2;&#125;fn1(a); // 1alert(a); // 2 参数其实就是一个局部变量，第一个例子没有传参，参数就相当于var a; 第二个例子传了参数就相当于var a = 1; 一个函数的解析顺序是先从参数开始的。 下面看一个最常见的案例 12345for(var i = 0; i &lt; 3; i++)&#123; btn[i].onclick = function()&#123; alert(i); // 3 &#125;&#125; 最开始我以为这里打印的i是会随着遍历打印出0,1,2的，但实际上onclick函数中相当于一个独立的作用域，这个作用域中没有声明i变量，所以就要去上级作用域去获取，那为什么是3呢，因为函数只有在点击时才会调用，只有调用时才会发生预解析和逐步解析，这时去获取i的值上级作用域早已遍历完毕。 js运算符%取余的应用下面的例子中要在li元素中添加背景色，颜色存储在arr数组。如果不用取余运算符只能写两层for循环，而使用取余运算，可以直接让取余后的值自己循环。 arr的长度是3，i是0开始每次+1，那么arr数组每次的索引就是：arr[0%3=0],arr[1%3=1],arr[2%3=2],arr[3%3=0],arr[4%3=1],arr[5%3=2],arr[6%3=0]，这样就达到了遍历颜色数组的目的。这种操作很适合于在一个数组的遍历内部又需要遍历另外一个数组的情况。 12345var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];for(var i = 0; i &lt; li.length; i++)&#123; li[i].style.backgroundColor = arr[i%arr.length];&#125; 下面扩展一下这个案例，加上任意li元素点击后变色，再去点击另一个li，另一个li元素变色，上一个li元素变回原来的颜色。通常这种功能会用排他来做，这次不用排他，使用取余操作来写。 12345678910111213141516var li = document.getElementsByTagName('li');var arr = ['yellow','pink','orange'];var elem = null;for(var i = 0; i &lt; li.length; i++)&#123; li[i].index = i; li[i].style.backgroundColor = arr[i%arr.length]; li[i].onclick = function()&#123; if(elem)&#123; elem.style.backgroundColor = arr[elem.index%arr.length]; &#125; elem = this; this.style.backgroundColor = 'gray'; &#125;&#125; 排他是将所有li元素变色，再去更改当前点击的元素的背景色，而这种思路是记录上一次点击的元素，在下一次点击时只改变上一次点击的元素的背景色就可以了。这里elem.index和i的作用是相同的。 另外取余操作还可以换算时间，比如现在要将70秒转为分钟，那么可以这样写 12var s = 70;var m = Math.floor( 70/60 + '分' + 70%60 + '秒'); js获取浏览器计算后的属性值像width或者height这种属性直接获取只能得到行内样式，如果不写在行内就获取不到，使用getComputerStyle可以获取浏览器计算后的样式，也就是被浏览器渲染之后得到的元素实际的属性的值。格式是getComputerStyle(element).width; 但是这个方法在ie6、7、8不兼容。这三个非标准浏览器使用的currentStyle属性。格式是element.currentStyle.width;。 不要用这两个方法去获取没有设置过的属性。 不能用这两个属性去获取复合样式，比如要获取背景色不要用background而是要用backgroundColor，不论css是怎么写的，都要写具体的属性。因为如果写background的话会获取到所有这个属性可以设置的属性值，如果css没写的会获取到默认的。 另外在firefox浏览器4.0版本之前，getComputerStyle的参数要写两个，第二个参数可以随便写比如getComputerStyle(element,&#39;&#39;).width;或getComputerStyle(element,true).width;，总之只要写一个参数就可以。 jq中的即使搜索事件在jq中实现input搜索框的即时搜索和其他即时性的改变需要用到input和propertychange(兼容ie8及以下浏览器)事件。 input是标准的浏览器事件，一般应用于input元素，当input的value发生变化就会发生，无论是键盘输入还是鼠标黏贴的改变都能及时监听到变化。 propertychange只要当前对象属性发生改变都会触发，所以使用propertychange时最好排除一下不想触发事件的元素。 window.parent在b.html页面使用iframe的时候，引入一个Html页面名称暂定为a.html，呢么在a.html中，window指的是a的window对象，而window.parent指的就是b.html的window对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git]]></title>
      <url>%2F2017%2F04%2F13%2FGit%2F</url>
      <content type="text"><![CDATA[Git是通过监控文件的状态来实现版本的控制的。 文件的三种状态分别是已提交(commotted)、已修改(modified)、已暂存(staged)。 状态改变Git都是可以监听到的。由此引入对应Git项目的。 Git的三个区域介绍 Git仓库目：就是Git用来保存项目的源数据和对象数据库的地方。Git中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录：是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供用户使用或修改 暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index）,不过一般说法还是叫暂存区。 Git的基本工作流程 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 Git操作方法和命令本地仓库根目录右键，打开Git Bash。 输入git init初始化一个git仓库。 这样就可以让git来管理目录。这个命令只是创建了一个名为.git的隐藏目录，这个目录就是存储我们历史版本的仓库。 添加到缓存git add *将已修改的文件放到暂存区，也可以直接写文件名或者文件夹名，git会自动过滤空目录。 查看状态git status 检测当前仓库文件的状态，红色表示被修改，放到暂存区的文件被标记成了绿色等待提交。 git checkout index.html 将index.html从暂存区还原到工作区。 提交git commit -m &#39;提交信息&#39; -m是mark的意思，将暂存区的内容全部文件提交，将暂存区被标记成绿色的文件，全部提交到本地仓库存储。 其他git log 查看存盘点，每次提交会生成一个随机id值 git reset --hard id值 还原代码到该id值得版本 第一次使用git时需要配置。git config --global user.name pj.Yu 设置自己的名字。git config --global user.email 406490508@qq.com 设置自己的邮箱 Git分支同时开发多个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要来修复，这个时候我们当然希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。通过Git创建分支来解决实际开发中类似的问题。 开发时在另一个分支上开发新功能A然后上线，然后再写另一个分支另外一个功能B，这时A功能有bug再去调试，不会影响其他分支的状态。 当我们初始化仓库时候，实际上就是产生了第一次提交。Git会默认帮我们创建一个master的分支，每次commit操作生成一个新的版本（存盘点）。而且会生成一个sha值，master是主干，这些版本就是在主干上的存盘点，每一次的历史按本都是基于分支存在的。 分支功能基本操作建立新的分支git branch share 建立一个名为share的分支，建立后现在还是在master主干上。 git checkout share 切换到share分支，切换之前尽量先commit。 git branch 查看当前都有哪些分支。*号表示当前处于哪个分支。 git checkout -b share 创建并切换到share分支 另外分支是有继承关系的。新建的自分支会继承父分支的所有提交历史。 合并两个分支git merge share 当前分支合并share分支。同一个文件被修改会产生冲突。 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 冲突开始的位置 =========== 之上是当前分支的代码，之下是share分支的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; share 冲突结束的位置 根据需求留下想要的代码，将标识符都删除掉就解决冲突了。 删除分支git branch -d share 删除share分支 git的分支管理规范(主要指在gitLab上的分支) 不要有太多的分支，分支太多管理起来太费劲，毕竟是多人开发制定策略太复杂 要有一个稳定的平行分支，即master分支不要轻易修改，这个稳定的文分支不能有bug。 要有一个开发分支(developer)，保证master分支的稳定性 所有的功能分支(feature)从developer创建，功能写完后合并到developer，但不能直接合并到master，因为要保证始终有一个没有bug的稳定分支 所有功能开发完成后新建发布分支(release)，用作测试，测试完全没问题就合并到master分支。 GitHub多个人共同开发，改完代码后放到共享仓库，其他人就可以取到代码。借助一个远程仓库，大家可以共享代码、历史版本等数据，GitHub就是这样的一个代码仓库。 在gitHub中新建一个项目 首先创建一个新的项目，要输入项目名，项目描述，是否公开。其实就相当于新建一个共享库。 以表格形式创建一个仓库，并且会提供给我们一个仓库地址。 由于主机名太长，可以简写成主机名。以后只填写主机名就行，就不用写远程仓库地址了 git remote add &quot;主机名&quot; &quot;远程仓库地址&quot; 添加远程主机，其实就是给远成仓库地址起一个比较短的名字 git remote show &quot;主机名&quot; 查看这个主机名对应的主机名是谁 git remote 显示所有主机名 地址下面会告诉用户应该怎样操作，如何创建.git并上传等设置，这里根据自己的实际情况，并不是每一步骤都要设置，有可能之前已经设置好了 设置之后就可以push了，但是这时会有权限问题，也就是公钥和私钥，需要将本电脑的公钥传到gitHub上， 设置公钥为了免密码共享代码需要通过SSH来实现： ssh-keygen -t rsa 创建一个公钥，一直回车。在用户的文件里创建了一文件夹.ssh里边创建了对公钥和私钥.pub是公钥。 将公钥放到gitHub对应账号下，在个人设置里有SSH的选项，复制进去就行。相当于在自己电脑和gitHub之间建立了连接。私钥不需要管。 如果有两台电脑就要添加两个SSH key git push 仓库地址 分支 将本地提交的更改推送到远程仓库。 git pull 仓库地址 分支 将远程仓库的代码拉取到本地仓库。 git push origin 本地的分支:远程仓库分支 把本地分支的修改共享到远程的分支上去 如果远程没有这个分支就会创建一个。 fork功能GitHub除了创建共享仓库，还有一个目的是coding，大家一起来共享代码 这里的项目都是公开的开源项目，除了自己可以维护功能，其他来自全世界的人都可以共同进行开发，并且其他开发者可以对原有的项目进行修改 但是程序员水平参差不齐，所以项目不允许其他人直接修改。需要先forking一份到自己的目录下，然后通过克隆、pull、push等操作，修改自己目录下的这份副本。 自己改完以后经过自己测试，没问题的话可以申请原有项目合并自己的修改。申请合并是pull requests选项，在gitLab中是Merge Requests选项。要填写合并哪个项目的哪个分支，还要填写更改的说明，和发邮件类似，这样发送请求就成功了。 对方会受到申请并且检验，如果对方觉得改的不错，同意后可进行合并，否则拒绝 克隆远程仓库当远程仓库已经有项目了，项目已经开始开发了，可以执行克隆操作。 git clone &quot;仓库地址&quot; 拿下来的就是仓库了，就不用再执行init了。 克隆下来后，查看分支，当前只有master分支，因为克隆的就是主干分支。 git fetch &quot;仓库地址&quot; 这时就把其他分支都拿下来了 git branch -A 可以看远程仓库的分支，除了主干都是红色的 总结来看，我如果使用克隆功能，相当于完成了以下步骤： mkdir 目录 -&gt; cd 目录 -&gt; git init -&gt; git remote add origin “仓库地址” -&gt; git pull origin master GitLab通过GitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，私有仓库又是需要交“保护费”的，而gitLab就是免费私有的这么一个网站。 gitLab也是一个可以通过Web界面管理仓库的网站程序，我们可以把它架设到公司自已的服务器上，实现仓库私有化，这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。 给项目添加成员进入一个项目后，右上角的设置有个Menbers选项，就是成员的意思，如果希望有个人一起合作写这个项目，就可以邀请并分配权限，通常分配Developer权限。现在对方就可以随意push代码，但是不能操作master分支。 分组很多时候我们需要创建一个分组，相当于建立一个群Groups，在左边的菜单栏里。 分组可以直接添加分组成员，步骤和项目添加成员相同。 在分组里可以建立项目，作为小组的成员也会自动生成一个项目目录，大家就可以一起开发这个项目，之后的步骤和上面相同。 Protexted Branches受保护的分支，默认情况下保护的是master分支， 也可以自行根据权限设置保护的分支。 gitignore 忽略文件有些文件不需要提交，比如笔记，图片等。这时就可以忽略掉 忽略方式：创建一个没有文件名的.gitignore后缀文件，通过另存为来保存。也可以用命令行创建将要忽略的文件名存进去，就忽略了。 比较差异当内容被修改时，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 用git difftool比较暂存区和修改的文件的差异 接一个sha值比较暂存区和历史记录的差异,两个sha值就是历史版本和历史版本的差异 回滚（撤销）操作如果刚刚上传完后又发现一个bug， 可以用git reset把某一个版本的代码还原到工作目录。 –hard 工作区会变，历史会变，暂存区也会变。 –soft 只会变历史区域的代码，即是回滚在工作区也看不见。 –mixed 历史会变，暂存区也会变，工作区不变。 工作区指的能看的见的代码。 .git目录就是仓库区域。 暂存区也在.git目录下，就是index文件。 git checkout SHA值 -- index.html 只拿出index到工作区中，其他文件不变 历史不变 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch &quot;远程主机&quot; 或者git fetch &quot;远程主机&quot; &quot;分支名称&quot;获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。 用git merge remotes/主机名/分支名 当前分支合并remotes/主机名/分支名 也可以用git pull 主机名 分支名，这个命令等于做了两个操作，git fetch和 git merge origin/某个分支 git branch -a 便可以查看所有(本地+远程仓库)分支了 git push origin --delete 分支名称 可以删除远程分支。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM编程艺术--一、DOM]]></title>
      <url>%2F2017%2F04%2F13%2FDOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E4%B8%80%E3%80%81DOM%2F</url>
      <content type="text"><![CDATA[1、DOM的含义 文档(D)，指的是document，当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生，DOM把我们编写的网页文档转换为一个文档对象。 对象(O)，指的就是javascript中的三种对象，用户定义对象、内建对象、宿主对象。 模型(M)，可以理解为模型Model或者地图Map，我们可以通过javascript代码来读取这张地图。 要理解模型或者地图的概念，首先我们要理解DOM是把一份文档表示为一棵树。以下面文档为例。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt; &lt;head&gt; &lt;meta charset = "utf-8"&gt; &lt;title&gt;Shopping list&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;What to buy&lt;/h1&gt; &lt;p title = "a gentle reminder"&gt;Don't forget to buy this stuff&lt;/p&gt; &lt;ul id = "purchases"&gt; &lt;li&gt;A tin of beans&lt;/li&gt; &lt;li class = "sale"&gt;Cheese&lt;/li&gt; &lt;li class = "sale"&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 上面的一长串代码可以理解为以下的DOM树 从上图可以看出，html永远是一个文档的开始，可以看作是树根，再深一层就是head和body，它们位于一层，所以是兄弟关系(sibling)，它们都有各自的子元素(child)，有着共同的父元素(parent)。 实际上用parent、silbling、child就可以代表整个DOM树的结构，比如ul是ul是body的child元素，而ul又是li的parent元素，ul和p是sibling元素，并且这棵树上的每个元素都是一个DOM节点。 2、节点上面介绍了DOM的概念，由图也可以看出，DOM树是由一个个节点组成的，这些就是DOM节点。分为三种类型。 元素节点 标签的名字就是元素节点，例如”p”、”ul”、”body”等等。 文本节点 被元素包括的文本内容就是文本节点，比如上面文档中被包含的”A tin of beans”。 属性节点 属性节点用来对元素做出更具体的描述，比如的title属性，也包括id和class属性，属性节点也总是被包含在元素节点内部。 那么我们如何区分这三种节点呢？可以使用nodeType属性。nodeType属性总共有12种可取值，但其中仅有3种有实用价值。 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 实际使用中可以通过元素对象的nodeType属性值来判断节点类型。 3、获取元素有3种DOM方法可以获取元素节点，分别是通过元素id、通过标签名、通过class获取。 通过id名获取这个方法将返回一个与给定id属性值的元素节点对应的元素对象，它是document对象特有函数。1document.getElementById(&apos;box&apos;); 获取id属性值是’box’的元素对象。 这里一直再说元素对象这个概念，其实就是指的html元素，但是在DOM里html元素都是DOM节点。而DOM节点本身就是一个对象，所以叫做元素对象。另外函数和方法其实也是一个概念，对象的方法其实就是一个函数。 通过标签名获取这个方法返回一个对象数组，与getElementById不同的是，这个返回的是一个数组，返回的数组中，每个元素都是获取到的元素对象，可以用length属性查出这个数组的长度。 1document.getElementsByTagName('li'); 这个方法允许把一个通配符作为它的参数，可以获取文档里的所有元素，也可以和getElementById结合使用 12var box = document.getElementById('box');var lis = box.getElementsByTagName('*'); 这样可以获取id为box的元素下的所有元素对象。 通过class获取这是HTML5中新增的方法，可以通过class名获取元素，返回的也是一个对象数组。 1document.getElementsByClassName('sale important'); 获取class属性为sale和important的元素对象，这个元素必须同时有这两个class名，顺序无所谓。也可以和getElementById结合使用。 12var box = document.getElementById('box');var sales = box.getElementsByClassName('sale'); 获取id值为box的元素下的所有class名为sale的元素。 需要注意的是这个方法比较新，所以用的时候要小心，为了弥补这个不足，我们可以自己封装一个获取class名的方法以适用于旧版浏览器。 获取class名的兼容性处理 1234567891011121314function getElementsByClassName(node, className) &#123; if (node.getElementsByClassName) &#123; return node.getElementsByClassName(className); &#125; else &#123; var results = new Array(); var elems = node.getElementsByClassName('*'); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(className) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 这个函数接收两个参数，node表示搜索起点，className是要搜索的class名，这个方法不足的地方是不适用多个class名。 4、获取和设置属性已经了解了三种获取元素节点的方法，现在可以去获取它们的属性。 获取属性1234567var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; var title_text = paras[i].getAttribute('title'); if(title_text != null)&#123; alert(title_text); &#125;&#125; getAttribute用于获取属性，需要用元素节点去调用，参数是要获取的属性名，如果调用的元素节点里没有要查找的属性就会返回null。 设置属性12345var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; paras[i].setAttribute('title','brand new title text'); alert(paras[i].getAttribute('title'));&#125; setAttribute用于设置属性，不管调用的元素原来有没有设置的属性，最终都会被设置上，用setAttribute对文档做出修改后，在浏览器中查看源代码仍是改变前的属性，这就是DOM的工作模式，对页面内容更新却不需要在浏览器里刷新。]]></content>
    </entry>

    
  
  
</search>
