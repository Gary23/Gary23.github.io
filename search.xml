<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《锋利的jQuery》十一、jQuery的技巧]]></title>
      <url>%2F2017%2F08%2F18%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%8D%81%E4%B8%80%E3%80%81jQuery%E7%9A%84%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[禁用页面的右键菜单12345$(function()&#123; $(document).on('contextmenu',function()&#123; return false; &#125;)&#125;) 返回头部动画123456789101112$.fn.scrollTo = function(speed,elem)&#123; var targetOffset = $(this).offset().top; elme.stop().animate(&#123; scrollTop: targetOffset, &#125;,speed); return this;&#125;$('.goto').click(function()&#123; $('body').scrollTo(500,$('html body')); return false;&#125;) 模拟输入框的placeholder1234567891011121314151617$(function()&#123; $('input.text1').val('输入搜索内容'); textFill($('input.text1')); function textFill(input)&#123; var originalvalue = input.val(); input.focus(function()&#123; if($.trim(input.val()) == originalvalue)&#123; input.val(''); &#125; &#125;).blur(function()&#123; if($.trim(input.val()) == '')&#123; input.val(originalvalue); &#125; &#125;) &#125;&#125;) 获取鼠标位置12345$(function()&#123; $(document).mousemove(function(e)&#123; $('#xy').html('x: ' + e.pageX + '| y: ' + e.pageY); &#125;)&#125;) 判断元素是否存在12345$(function()&#123; if($('#id').length)&#123; // do something &#125;&#125;) 点击div也可以跳转1&lt;div&gt;&lt;a href="index.html"&gt;index&lt;/a&gt;&lt;/div&gt; 1234$('div').click(function()&#123; window.location = $(this).find('a').prop('href'); return false;&#125;) 根据浏览器大小添加不同样式1234567891011$(function()&#123; function checkWindowSize()&#123; if($(window).width() &gt; 1200)&#123; $('body').addClass('large'); &#125;else&#123; $('body').removeClass('large'); &#125; &#125; $(window).resize(checkWindowSize)&#125;) 设置div在屏幕中央12345$.fn.center = function()&#123; this.css('position','absolute'); this.css('top',($(window).height() - this.height()) / 2 + $(window).scrollTop() + 'px' ); this.css('left',($(window).width() - this.width()) / 2 + $(window).scrollLeft() + 'px' );&#125; 关闭所有动画效果1234$(function()&#123; $.fx.off = true;&#125;) 检测鼠标左键和右键123$('#xy').mousedown(function(e)&#123; alert(e.which) // 1是鼠标左键 2是鼠标中键 3是鼠标右键&#125;) 设置全局Ajax参数123456789$('#load').ajaxStart(function()&#123; showLoading(); // 显示 loading disableButtons(); // 禁用按钮&#125;);$('#load').ajaxComplete(function()&#123; hideLoading(); // 隐藏loading enableButtons(); // 启用按钮&#125;) 获取选中的下拉框12$('#someElement').find('option:selected');$('#someElement option:selected'); $.proxy()的使用123&lt;div id="panel" style="display:none;"&gt; &lt;button&gt;Close&lt;/button&gt;&lt;/div&gt; 123456$('#panel').fadeIn(function()&#123; $('#panel button').click(function()&#123; $(this).fadeOut(); console.log(this); &#125;)&#125;) 以上代码中因为 this 指向了 button 所以会隐藏 button 元素，而不是 #panle 元素。 123456$('#panel').fadeIn(function()&#123; $('#panel button').click($.proxy(function()&#123; $(this).fadeOut(); console.log(this); &#125;,this));&#125;) 这样利用 $.proxy() 方法可以将this改变为 #panel 。 限制输入框的字数123456789101112131415161718$.fn.maxLength = function(max)&#123; this.each(function()&#123; var type = this.tagName.toLowerCase(); var inputType = this.type ? this.type.toLowerCase() : null; if(type == 'input' &amp;&amp; inputType == 'text' || inputType == 'password')&#123; // 标准的maxLength this.maxLength = max; &#125;else if(type == 'textarea')&#123; this.onkeyup = function(e)&#123; console.log(this.value.length); if(this.value.length &gt; max)&#123; console.log(11); this.value = this.value.substring(0,max); &#125; &#125; &#125; &#125;)&#125; 删除元素内部的html标签，只留下文本内容1234567$.fn.stripHTML = function()&#123; var regexp = /&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/gi; this.each(function()&#123; $(this).html($(this).html().replace(regexp,'')); &#125;) return $(this);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》十、jQuery性能优化]]></title>
      <url>%2F2017%2F08%2F16%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%8D%81%E3%80%81jQuery%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[使用合适的选择器以下选择器是按照性能由高到低排序的 $(‘#id’)使用id来定位DOM元素无疑是最佳提高性能的方式，因为jQuery将直接调用document.getElementById()方法，如果用id无法直接获取元素那么可以用$(&#39;#id&#39;).find()方法。为了提高性能，最好从最近的id开始找。 $(‘div’)标签选择器性能也是不错的，是第二选择。jQuery将直接调用document.getElementsByTagName()。 $(‘.class’)这个方法如果是ie9以上或标准浏览器会调用document.getElementsByClassName()，对于旧的浏览器将使用DOM搜索的方式，所以相比前两个比较耗费性能。 $(‘[attribute=value]’)对于利用属性来定位DOM元素，没有js方法直接实现。基本是通过querySelectorAll()方法实现，如果是旧浏览器会使用DOM搜索的方法。总体来说性能并不理想，尽量避免使用。 $(‘:hidden’)和上面用属性定位DOM元素类似，这种伪类选择器也没有js方法直接实现，并且jQuery需要搜索每一个元素来定位这个选择器，同样性能不理想，如果必须要用可以在前面加一个id选择器缩小搜索范围。 如果要查看性能区别，可以使用一个在线工具jsPerf。 缓存对象在书写jQuery代码时经常看到如下代码： 1234$('#traffic_light input.on').on('click',function()&#123;...&#125;);$('#traffic_light input.on').css('border','1px solid yellow');$('#traffic_light input.on').css('background-color','orange');$('#traffic_light input.on').fadeIn('show'); 这种思维是无可厚非的，但这样导致的结果是jQuery会在创建每一个选择器的过程中，查找DOM，创建多个jQuery对象。比较好的书写方式如下： 12345var $active = $('#traffic_light input.on'); // 缓存对象$active.on('click',function()&#123;...&#125;);$active.css('border','1px solid yellow');$active.css('background-color','orange');$active.fadeIn('show'); 当然如果采用链式操作将更加简洁，但这里只是强调缓存对象。总之不要让同样的选择器多次出现在代码中。 循环时的DOM操作使用jQuery可以很方便的添加、删除或修改DOM节点，但是在一些循环，比如for()、while()、或者$.each()中处理节点时，下面有个实例指的注意： 12345var top_100_list = [...], // 假设这里是100个独一无二的字符串$myList = $('#myList'); // jQuery选择到&lt;ul&gt;元素for(var i = 0, l = top_100_list.length; i &lt; l; i++)&#123; $myList.append('&lt;li&gt;' + top_100_list[i] + '&lt;/li&gt;');&#125; 上面的代码中将每个遍历生成的新元素都作为节点添加到容器$(&#39;#myList&#39;)中，这样操作也是非常耗性能的，更好的方法是尽可能的减少DOM操作，这里应该将整个遍历生成的元素都拼接成字符串，最后统一添加到$(&#39;#myList&#39;)中： 1234567var top_100_list = [...],$myList = $('#myList'),top_100_li = '';for(var i = 0, l = top_100_list.length; i &lt; l; i++)&#123; top_100_li += '&lt;li&gt;' + top_100_list[i] + '&lt;/li&gt;';&#125;$myList.html(top_100); 这里如果不使用缓存对象，对性能的损耗将更加严重，将会产生100个jQuery对象。 数组方式使用jQuery对象jQuery对象会感觉像是一个定义了索引和长度的数组，在性能方面，建议使用for或while循环来处理，而不是使用$.each()，这样能使代码更快。 另外，检查长度也是检查jQuery对象是否有效的的方式： 12345var $content = $('#content');if($content.length)&#123; // do something&#125; 事件代理假设有一张表格，要为每个&lt;td&gt;增加一个事件，点击变色： 123$('#myTable td').click(function()&#123; $(this).css('background','red');&#125;) 假设有100个&lt;td&gt;元素，在使用方式上将绑定100个事件，这将带来很负面的性能影响。更好的方式是利用事件冒泡。向它们的父级绑定一次一次事件： 1234$('#myTable').click(function(e)&#123; var $clicked = $(e.target); $clicked.css('background','red');&#125;) 也可以使用on方法来绑定： 123$('myTable').on('click','td',function()&#123; $(this).css('background','red');&#125;) 使用join()来拼接字符串可以用join()的方式来代替+的方式来拼接字符串，更有助于性能优化，尤其是长字符串处理的时候。 12345var arr = [];for(var i = 0; i &lt;= 1000; i++)&#123; arr[i] = '&lt;li&gt;' + i + '&lt;/li&gt;'&#125;$('#list').html(arr.join('')); 尽量使用原声的js方法下面的代码是用来判断多选框是否被选中： 123456var $cr = $('#cr');$cr.click(function()&#123; if($(this).is(':checked'))&#123; console.log('被选中') &#125;&#125;) 这里用了is()方法来判断多选框是否被选中，但其实可以直接使用原声的js方法： 1234567var $cr = $('#cr');$cr.click(function()&#123; if(this.checked)&#123; console.log('被选中') &#125;&#125;) 第二种方法不需要拐外抹角的去调用许多函数。还有更多类似的操作： $(this).css(&#39;color&#39;,&#39;red&#39;);优化成this.style.color = &#39;red&#39;;。 $(&#39;&lt;p&gt;&lt;/p&gt;&#39;)优化成$(document.createElement(&#39;p&#39;))。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》九、XMLHttpRequest对象]]></title>
      <url>%2F2017%2F08%2F15%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B9%9D%E3%80%81XMLHttpRequest%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[XMLHttpRequest对象是Ajax的核心，它有许多的属性、方法和事件以便于js处理和控制HTTP的请求与响应。 readyState属性当一个XMLHttpRequest被创建后，通过readyState属性可以查看此次请求的状态。 值 说明 0 初始化状态：此时，已经创建了一个XMLHttpRequest对象，但是没有初始化。 1 准备发送状态：已经调用了open()方法，并且XMLHttpRequest对象已经准备好将一个请求发送到服务器。 2 已发送状态：已经通过send()方法把一个请求发送到服务器端。 3 正在接受状态：已经接到HTTP的响应头部信息，但是消息体部分还没有完全接收到。 4 完成响应状态：已经完成了HttpResponse响应的接收。 responseText属性包含客户端接收到的HTTP响应的文本内容。readyState为0、1、2时是一个空字符串，readyState为3时响应中包含客户端还未完成的响应信息，readyState为4时才是完整的信息。 responseXML属性只有当readyState为4时，并且响应头部的Content-Type的MIME类型被指定为XML(text/xml)时，该属性才会有值并且被解析为一个XML文档。 status属性描述了HTTP的状态码，只有在readyState为3或者4时才可以使用该属性，否则会报错。 statusText属性和上面相同，只是描述了HTTP的状态码文本，而不只是状态码。 open()方法XMLHttpRequest对象是通过调用open()方法来进行初始化工作的。调用该方法将得到一个可以用来进行发送的对象。 该方法有五个参数 open(method,uri,async,username,password)。 method：该参数是必须提供的，用于确定GET发送还是POST发送，该参数要大写。 uri：用于指定XMLHttpRequest对象把请求发送到的服务器相应的URI。 async：用于指定是否请求是异步的，默认值是true，发送同步请求需要设置为false。 如果服务器要验证访问用户的情况，那么可以设置username及password。 send()调用send()方法可以将open()方法设定的参数请求进行发送。send()方法在readyState属性值为1时，即是在open()之后才可以调用。 send()的参数可以作为POST方式发送的参数，在调用send()之前，先使用setRequestHeader()方法设置Content-Type的头部。 abort()方法该方法可以暂停一个HttpRequest的请求发送或者HttpResponse的接收，并将XMLHttpRequest设置为初始化状态。 setRequestHeader()方法用来设置头部信息，当readyState属性值为1时，可以在调用open()方法后调用这个方法，该方法的格式为：setRequestHeader(header, value)。 getRequestHeader()方法检索响应的头部值，仅当readyState值为3或者4时才可以调用这个方法，否则会返回一个空字符串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[1、创建Vue实例]]></title>
      <url>%2F2017%2F07%2F25%2F1%E3%80%81%E5%88%9B%E5%BB%BAVue%E5%AE%9E%E4%BE%8B%2F</url>
      <content type="text"><![CDATA[一个最简单的Vue的例子Vue的核心是：允许采用简洁的模板语法、声明式的将数据渲染进DOM(与声明式相对应的是命令式)。 首先要创建一个模板，这是html模板(最简单的一种模板) 123&lt;div id="app"&gt; &lt;p v-on:click="clickHandle"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 下面是创建Vue的实例，参数是一个选项对象，可以包含数据、模板、挂载元素、方法、声明周期钩子等选项。 123456789101112var app = new Vue(&#123; el: '#app', // 挂载元素 data: &#123; // 代理数据,这里所有数据都具有响应的功能，新添加的就没有响应功能。 message: 'Hello Vue' &#125;, methods: &#123; // 定义方法，用于执行函数，key:fun的格式 // 可以把事件处理函数都放在这里 clickHandle: function()&#123; alert('click') &#125; &#125;&#125;) 这样就渲染生成了一个简单的Vue应用，现在数据和DOM已经被绑定到了一起，所有元素都是响应式的。 数据是可以动态的修改的，修改之后页面中的显示也会随之渲染。 1app.message = '123' 这样页面中的Hello Vue就会变为123。这是利用的Object.delinedProperty中的getter和setter代理数据，监控对数据的操作。 Vue渲染DOM树的过程 读取html模板 用Vue中的渲染函数，根据html模板的元素生成标签的节点、属性、子节点 根据渲染函数生成一个虚拟的DOM树对象。 将虚拟的DOM树编译为html中的DOM结构，在整个html的DOM结构中，只会改变虚拟DOM树对应的部分，DOM树的其他部分不受影响，但是如果是通过原生js修改的话，会导致整个DOM树重新加载。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》八、jQuery插件的使用和写法]]></title>
      <url>%2F2017%2F07%2F24%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%85%AB%E3%80%81jQuery%E6%8F%92%E4%BB%B6%E7%9A%84%E5%86%99%E6%B3%95%2F</url>
      <content type="text"><![CDATA[编写插件的目的是给已有的一系列方法或函数做一个封装，以便在其他地方重复使用，方便后期维护和提高开发效率。 插件的种类1.封装对象方法的插件这种插件是将对象方法封装起来，用于通过选择器获取jQuery对象进行操作，是最常见的一种插件。比如parent()、appendTo()、addClass()等。 2.封装全局函数的插件可以将独立的函数加载到jQuery的命名空间之下。例如$.ajax()、$.trim()等。 3.选择器插件个别情况下，会需要使用到选择器插件，虽然jQuery的选择器十分强大，但还是会需要扩充一些自己喜欢的选择器。 插件的基本要点插件的文件名推荐命名为jquery.[插件名].js。 所有的对象方法都应该附加到jQuery.fn对象上，而所有的全局函数都应该附加到jQuery对象本身上。 在插件内部，this只想的是当前通过选择器获取的jQuery对象，例如click()方法指向的是DOM元素。可以通过this.each来遍历所有元素。 插件应该返回一个jQuery对象，以保证插件的可链式操作。除非插件需要返回的是一些需要获取的量，例如字符串或者数组。 避免在插件内部使用$作为jQuery对象的别名，而应该用完整的jQuery来表示。这样可以避免冲突，如果使用$作为jQuery的别名，要用必报来避免冲突。 插件中的闭包利用闭包的特性，既可以避免内部临时变量影响全局空间，又可以在插件内部继续使用$作为jQuery别名。 12345678910(function($)&#123; // 将$作为匿名函数的形参 // 这里编写插件的代码 var foo; var bar = function()&#123; // 在匿名函数内部的函数都可以访问foo，即便是在匿名函数的外部调用bar()的时候，也可以在bar()的内部访问到foo，但在匿名函数的外部直接访问foo是做不到的。 &#125; // 下面的语句让匿名函数内部的函数bar()返回到全局可访问的范围内，这样就可以在匿名函数的外部通过调用jQuery.BAR()来访问内部定义的函数bar()，并且内部函数bar()也能访问匿名函数内的变量foo。 $.BAR = bar;&#125;)(jQuery) // jQuery作为实参传递给匿名函数 jQuery的插件机制jQuery提供了两个用于扩展jQuery功能的方法，jQuery.fn.extend()方法和jQuery.extend()方法。第一个方法用于封装对象方法的插件，第二个适用于封装全局函数插件和选择器插件。这两个方法都接收一个参数，类型是Object。 jQuery.extend()除了扩展插件能用到，还有一个用处是扩展已有的对象，也就是传递两个参数，类型都是object，第二个对象会和第一个对象合并，相同的属性第二个会覆盖第一个。 1234var settings = &#123; validate: false , limit: 5 , name: 'foo' &#125;;var options = &#123; validate: true , name: 'bar' &#125;;var newObj = jQuery.extend(settings,options);console.log(newObj) // &#123; validate: true , limit: 5 , name: 'bar' &#125; 所以jQuery.extend()方法经常用于设置插件方法的一些默认参数。 编写jQuery插件封装jQuery对象插件设置和获取颜色的插件首先编写设置和获取颜色的插件color。该插件的功能是： 设置匹配元素的颜色 获取匹配的元素(元素集合中的第一个)的颜色。 由于是在jQuery对象上扩展方法所以使用jQuery.fn.extend，这里要注意的是插件扩展内部的this指的是jQuery对象而不是普通的dom对象，然后插件如果不是返回字符串之类的特定值，应当使其具有可链接性，为此要直接返回这个this对象。12345678910111213(function($)&#123; $.fn.extend(&#123; 'color': function(value)&#123; if(value == undefined)&#123; return this.css('color'); // 获取颜色。css方法本身就默认返回第一个的颜色 &#125;else&#123; return this.each(function()&#123; $(this).css('color',value); // 设置颜色，由于this是jQuery对象，所以不需要each遍历 &#125;) &#125; &#125; &#125;);&#125;)(jQuery) 表格隔行变色插件12345678910111213141516171819202122(function($)&#123; $.fn.extend(&#123; 'alterBgColor': function(options)&#123; options = $.extend(&#123; odd: 'odd', // 偶数行样式 even: 'even', // 奇书行样式 selected: 'selected' // 选中行样式 &#125;,options); $('tbody&gt;tr:odd' , this).addClass(options.odd); $('tbody&gt;tr:even' , this).addClass(options.even); $('tbody&gt;tr' , this).click(function()&#123; // 判断当前是否选中 var hasSelected = $(this).hasClass(options.selected); // 如果选中，则移出selected类，否则就加上selected类 $(this)[hasSelected ? 'removeClass' : 'addClass'](options.selected).find(':checkbox').prop('checked',!hasSelected); &#125;); // 如果单选框默认情况下是选择的，则高亮 $('tbody&gt;tr:has(:checked)' , this).addClass(options.selected); return this; // 返回this，可以继续链式操作 &#125; &#125;);&#125;)(jQuery) 需要注意的是上面两个插件内部this都是可以匹配多个元素，但是如果遇到只能匹配一个元素的时候，要each遍历匹配的jQuery对象，而在each内部，this就是dom对象不是jQuery对象了。 封装全局函数这类插件是在jQuery命名空间内部添加一个函数。 增加两个函数，用于去除左侧空格和右侧空格。1234567891011(function($)&#123; $.extend(&#123; ltrim: function(text)&#123; // 假如text是undefined等非正确参数，就取空字符串，防止replace方法报错 return (text || '').replace(/^\s+/g,''); &#125;, rtrim: function(text)&#123; return (text || '').replace(/\s+$/g,''); &#125; &#125;)&#125;)(jQuery) 由于是全局函数，所以要由jQuery或者$调用，不能用jQuery对象去调用。 12$.ltrim(' text');$.rtrim('text '); 自定义选择器jQuery提供了一套方法让用户客户以通过制作选择器插件来使用自定义选择器。jQuery选择器执行的步骤如下： jQuery的选择符解析器首先会使用一组正则表达式来解析选择器 针对解析出的每个选择符执行一个选择器函数 根据这个函数返回的是true还是false来决定是否保留这个元素。 按照上面的步骤，以$(&#39;div:gt(1)&#39;)来举例： 选择器首先获取所有的div元素 逐个将这些div元素作为参数，连同括号里的1等一些参数一起传递给gt对应的选择器函数进行判断 如果gt对应的选择器函数返回true则这个div元素保留，如果返回false则不保留，这样得到的结果就是一个符合要求的div元素集合 现在来看一下最关键的gt的选择器函数： 123gt: function(a,i,m)&#123; return i &gt; m[3] - 0;&#125; 选择器一共接受三个参数： 第一个参数为a，指向的是当前遍历到的dom元素。 第二个参数为i，指的是当前遍历到的dom元素的索引值，从0开始。 第三个参数m最为特别，它是由jQuery正则解析引擎进一步解析后的产物(用match匹配出来的)，m是一个数组。在这时m[3]的值就是’1’。m[0]的值是:gt(1)m[1]的值是:m[2]的值是gtm[4]在上面的例子没有体现，假如是div:l(ss(dd))这样一个选择器，m[4]就指向了(dd)这部分，另外这里的m[3]的值就是ss(dd)。 编写一个between选择器例如使用$(&#39;div:between(2,5)&#39;)能实现获取索引3、4元素的功能。 选择器仅仅是jQuery.expr[&#39;:&#39;]对象的一部分，所以这里是将between函数扩展到jQuery.expr[&#39;:&#39;]对象中。12345678(function($)&#123; $.extend(jQuery.expr[':'],&#123; between: function(a,i,m)&#123; var tmp = m[3].split(','); // 将m[3]'最小值,最大值'改为['最小值','最大值'] return tmp[0] - 0 &lt; i &amp;&amp; i &lt; tmp[1] - 0; // 将索引与最小和最大值进行比较，符合要求的返回true，这里-0 是隐式转换的意思 &#125; &#125;)&#125;)(jQuery)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》六、jQuery的表单与表格]]></title>
      <url>%2F2017%2F07%2F23%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%85%AD%E3%80%81jQuery%E7%9A%84%E8%A1%A8%E5%8D%95%E4%B8%8E%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[表单的应用表单的组成部分 表单标签：包含处理表单数据所用的服务器端程序URL以及数据提交到服务器的方法。 表单域：包含文本框、密码框、隐藏域、多行文本框、复选框、单选框、下拉选择框和文件上传框等。 表单按钮：包括提交按钮、复位按钮和一般按钮，用于将数据传送到服务器上或者取消传送，还可以用来控制其它定义了处理脚本的处理工作。 文本框单行文本框有失去和获取焦点事件。 12345$('input').focus(function()&#123; &#125;).blur(function()&#123; &#125;) 也可以不传参数直接focus()和blur()，可以直接让文本框失去和获得焦点。 复选框jQuery可以控制复选框的就是是否被选择，checked属性如果为true就是被选中，为false就是没有选中。而最常用的就是全选、反选、全不选这三种按钮控制复选框的状态。 123456789101112// 全选$('input:checkbox').prop('checked','true');// 全不选$('input:checkbox').prop('checked','false');// 反选$('input:checkbox').each(function()&#123; $(this).prop('checked',!$(this).prop('checked')); // 这里也可以直接用原生来写 // this.checked = !this.checked;&#125;) 还有一种复选框是 全选/全不选，这是用一个复选框控制其他复选框选项的状态。 12345678910111213// 全选和全不选$('#allChecked').click(function()&#123; $('input:checkbox').prop('checked',$(this).prop('checked'))&#125;)// 在其他选项被取消勾选后，全选的状态也应该改为false$('input:checkbox').click(function()&#123; var flag = true; if(!$(this).prop('checked'))&#123; flag = false; &#125; $('#allChecked').prop('checked',flag);&#125;) 下拉框下拉框的应用通常是在左右两个&lt;select&gt;元素中相互移动&lt;option&gt;选项，常用的包括将选中项添加到右边/左边，全部添加到右边/左边。还有双击移动选中的选项。 选项从左边&lt;select&gt;移动到右边&lt;select&gt; 1234// 获取选中的选项var $options = $('#select1 option:selected');// 追加给对方，appendTo方法会移动且删除原来的元素。$options.appendTo($('#select2')); 全部添加到右边 1234// 获取全部选项var $options = $('#select1 option');// 追加给对方$options.appendTo($('#select2')); 双击某个选项添加给对方1234$('#select1').dblclick(function()&#123; var $options = $(this).find('option:selected'); $options.appendTo('#select2')&#125;) 表单验证表单注册最常用的地方就是登录注册，比如有些设置为required的必填项要检查其是否填写正确。 123456789101112131415161718192021222324252627282930$('form:input').blur(function()&#123; var $parent = $(this).parent(); // 需要先将上次的提示删除 $parent.find('span').remove(); // 验证用户名 if($(this).is('#username'))&#123; if(this.value == '' || this.value.length &lt; 6)&#123; var errMsg = '至少要输入6位的用户名'; $parent.append('&lt;span class="tips error"&gt;' + errMsg + '&lt;/span&gt;'); &#125;else&#123; var okMsg = '输入正确'; $parent.append('&lt;span class="tips success"&gt;' + okMsg + '&lt;/span&gt;'); &#125; &#125; // 其他密码、邮箱等验证都是类似的，只是判断规则不同 ......&#125;)// 表单提交时对整个表单再做一次验证$('#submit').click(function()&#123; $('form:input').blur(); var numErr = $('form:input .error').length; if(numErr)&#123; // 阻止表单提交 return false; &#125; alert('注册成功')&#125;) 除了在表单blur时判断，也可以在其输入文字时进行实时判断。 123456$('form:input').blur(function()&#123; // 上面的事件处理程序，这里就不再重复写了&#125;).keyup(function()&#123; // 输入文字时执行blur的事件处理程序，triggerHandler不会触发blur的浏览器默认事件，所以不会真的失去焦点导致无法输入 $(this).triggerHandler('blur') &#125;) 表格的应用表格变色普通的隔行变色css部分123456.even &#123; background:#fff38f;&#125;.odd &#123; background:#ffffff;&#125; js部分12$('tbody &gt; tr:odd').addClass('odd'); // 奇数行$('tbody &gt; tr:even').addClass('even'); // 偶数行 :odd和:even选择器的索引是从0开始，所以第一行是偶数。 单选框控制表格行高亮有种表格的选择是，点击当前行之后，当前行会变色，有可能在第一列是一个单选框，也需要被选中。 123456$('tbody&gt;tr').click(function()&#123; // 给当前行增加selected样式 $(this).addClass('selected').siblings().removeClass('selected').end().find(':radio').attr('checked',true);&#125;)// 初始化表格时让默认选中的行业要变色$('table :radio:checked').parent().parent().addClass('selected') 这里使用了end()方法，当执行siblings()时，this已经被改变为当前元素的兄弟元素，而使用end()则会让this重新回归原本的元素。 复选框控制表格高亮和上面的样式相似，只是单选改为复选框 12345678910$('tbody&gt;tr').click(function()&#123; // 判断是否被选中，有selected类名就是被选中了 var hasSelected = $(this).hasClass('selected'); // 如果选中移除selected类，否则就加上 $(this)[hasSelected?'removeClass':'addClass'].('selected'); // 查找内部的checkbox，设置相对应的属性 $(this).find(':checkbox').attr('checked',!hasSelected);&#125;)// 初始化表格时让默认选中的行业要变色$('table :checkbox:checked').parent().parent().addClass('selected') 表格的内容筛选相对是在表格内部进行姓名的搜索，输入’王’就显示出所有名字带有’王’字的行。 123$('#inputName').keyup(function()&#123; $('table tbody tr').hide().filter(':contains("' + ( $(this).val() ) + '")').show();&#125;).keyup(); // 打开页面时自动执行一次 :contains()是匹配包含指定文本的元素，在这里指的是输入的文字，filter()是在this中筛选出符合条件的元素集合 其他应用网页字体大小假设字体的放大和缩小都是span标签，文字内容元素的id为para。 1234567891011121314$('span').click(function()&#123; var thisEle = $('#para').css('font-size'); var textFontSize = parseInt(thisEle,10); // 获取现在的字号的单位 var unit = thisEle.slice(2); var cName = $(this).attr('class'); // 根据按钮的类名判断是放大还是缩小 if(cName == 'bigger')&#123; textFontSize += 2; &#125;else if(cName == 'smaller')&#123; textFontSize -= 2; &#125; $('#para').css('font-size',textFontSize + unit);&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》七、jQuery和Ajax的应用]]></title>
      <url>%2F2017%2F07%2F23%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B8%83%E3%80%81jQuery%E5%92%8CAjax%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[在jQuery中对Ajax进行了封装，在jQuery中$.ajax()属于最底层方法，第二层是$.post()、load()、$.get()方法，第三层是$.getScript()和$.getJson()方法。通常第二层的方法使用频率最高。 load()方法load()方法能载入远程html页面到dom中。 格式为：load( url , [data] , [callback] ) url：请求html页面的地址。 data: 可选参数，发送至服务器的数据。 callback：可选参数，请求完成后的回调，不论请求成功或者失败。 载入html文档假设有一个test.html的页面，那么只需要这样写就能引入这个test到当前页面。 当前页面的html部分1&lt;div id=""resText&gt;&lt;/div&gt; 当前页面发送请求 1$('#resText').load('text.html'); 筛选载入html文档上面是将test.html的所有内容都加载进来，如果只需要加载一部分那么只需要改变url参数即可，格式为：url selector。 只将test.html页面中类名为.para的元素加载进来。 1$('#resText').load('text.html .para') 回调函数load()的回调有三个参数，分别是： responseText：请求返回的内容。 textStatus：请求状态：success、error、notmodified、timeout 四种。 XMLHttpRequest： XMLHttpRequest对象。 $.get()和$.post()方法使用get的方式进行异步请求，格式为：$.get( url , [data] , [callback] , [type] )。 url：请求的文件地址。 data：可选参数，发送至服务器的数据，会附加到url地址中。 callback：可选参数，载入成功时回调函数，只有当Response返回的状态是success才能调用。 type：可选参数，服务器返回的格式，包括 xml、html、script、json、text、_default。 回调函数回调函数只有当数据成功返回(success)才能被调用，这点和load()方法不同，回调函数有两个参数，分别是data、textStatus。 data是成功后返回的数据，textStatus是请求状态。 $.getScript()和$.getJson()方法$.getScript()用于加载一个新的js文件，和写一个&lt;script&gt;标签的效果是一样的，但因为在页面初次加载时就取得所有js文件是没有必要的，所以就需要这个方法。 $.getScript()的第一个参数是js文件的地址，第二个参数是回调函数，回调只会在js文件成功加载后才会运行。 $.getJson()用于获取json文件，使用方法和$.getScript()相同。只是在回调函数中可用一个参数来获取json的内容。 $.ajax()方法$.ajax()是jQuery最底层的ajax实现，上面的所有方法都可以用这个方法代替。 $.ajax()的参数是一个对象，对象中的每个参数都是可选的，具体的参数如下： 参数名称 类型 说明 url string 默认是当前页面，发送请求的地址 type string 请求方式，默认为get方式 timeout number 设置请求超时的时间，单位是毫秒 data object或string 发送到服务器的数据 dataType string 预期服务器返回的数据类型，如果不指定，jQuery将自动根绝http的MIME信息返回responseXML或responseText，可选择的格式有：xml(xml文档)、html(纯html文本，包含的script标签会在插入dom时执行)、script(返回纯文本js代码，不会自动缓存结果，如果是跨域请求，则post方式都会转为get方式)、json(返回json数据)、jsonp(跨域获取数据，使用jsonp形式调用函数时，url地址的最后一个参数名是callback，值是?，这个?将由jQuery替换为正确的函数名，用以执行回调函数)、text(纯文本) beforeSend function 发送请求前可以更改XMLHttpRequest对象的函数，例如添加自定义http头，在beforeSend中返回false可以取消本次ajax的请求，改函数的唯一参数就是XMLHttpRequest对象，this是本次ajax请求时传递的options参数 complete function 请求完成后调用的回调函数，失败和成功都会调用，第一个参数是XMLHttpRequest对象，第二个参数是描述成功请求类型的字符串，this是本次ajax请求时传递的options参数 success function 请求成功后的回调函数，第一个参数是返回的数据，第二个参数是描述状态的字符串，this是本次ajax请求时传递的options参数 error function 请求失败时调用的函数，第一个参数是XMLHttpRequest对象，第二个参数是错误信息，第三个参数是捕获的错误对象，this是本次ajax请求时传递的options参数 global boolean 默认为true，表示是否触发全局ajax事件，设置为false将不会触发。 需要注意的是，如果将传递给服务器的数据使用字符串拼接的方式拼接到url上，必须使用encodeURIComponent()方法转码，如果是写到data属性则不需要。 序列化元素serialize()方法在提交表单的时候，需要给服务器传表单中的数据，如果表单的内容比较多，一个个获取比较麻烦，jQuery提供了一个简化的方法serialize(),它能够将dom元素的内容序列化为字符串，用于ajax请求。例如表单的id为form，那么可以将ajax的data属性直接写为$(&#39;#form&#39;).serialize()。 serializeArray()方法和serialize()方法类似，但是serializeArray()方法不是返回字符串，而是将DOM元素序列化后，返回json格式的数据。 html代码1234&lt;input type="checkbox" name="user" value="1" checked&gt;&lt;input type="checkbox" name="user" value="2" checked&gt;&lt;input type="checkbox" name="user" value="3"&gt;&lt;input type="checkbox" name="user" value="4"&gt; js代码12var fields = $(":checkbox").serializeArray();console.log(fields); // 打印一个数组[ &#123;name:'user',value:'1'&#125; , &#123;name:'user',value:'2'&#125; ] $.param()方法这是serialize()方法的核心，用以将一个数组或对象按照key/value进行序列化。比如将一个普通对象序列化 123var obj = &#123; a:1,b:2,c:3 &#125;;var k = $.param(obj);console.log(k); // 输出a=1&amp;b=2&amp;c=3 Ajax全局事件通过jQuery提供的一些自定义全局函数，能够为各种与Ajax相关的事件注册回调函数。 例如当请求开始时，会触发ajaxStart()方法的回调函数，当请求结束时，会触发ajaxStop()方法的回调函数。这些都是全局方法，因此无论创建它们于代码何处，只要有Ajax请求发生时，就会触发它们。 html代码1&lt;div id="loading"&gt;加载中...&lt;/div&gt; js代码 1234567$('#loading').ajaxStart(function()&#123; $(this).show();&#125;)$('#loading').ajaxStop(function()&#123; $(this).hide();&#125;) 还有另外几个方法： 方法名称 说明 ajaxComplete(callback) Ajax请求完成时执行的函数 ajaxError(cakkback) Ajax请求发生错误时执行的函数，捕捉到的错误可以作为最后一个参数传递 ajaxSend(callback) Ajax请求发送前执行的函数 ajaxSuccess(callback) Ajax请求成功时执行的函数 如果不想让Ajax触发这些全局方法，可以将global设置为false，在jQuery1.5版本之后可以设置：123$.ajaxPrefilter(function(options)&#123; options.global = true;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》五、jQuery的动画]]></title>
      <url>%2F2017%2F07%2F14%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%BA%94%E3%80%81jQuery%E7%9A%84%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[show()和hide()hide()方法是让元素隐藏，执行时候其实有两步，第一步是记住元素隐藏前的display属性值，第二步是将display设置为none。 show()方法会获取hide()第一步获取的那个属性并重新设置给元素的display属性。 这两个方法可以接收一个速度参数，显示和隐藏的毫秒值，$(&#39;#box&#39;).hide(1000)这样$(&#39;#box&#39;)元素从显示到隐藏会经过1000毫秒的动画过度，不会突然消失，执行过渡时，会同时改变元素的高度、宽度和不透明度，直至这三个属性都为0最后元素css会改为display: none。 参数也可以直接传入&#39;slow&#39;、&#39;normal&#39;、&#39;fast&#39;，分别代表600毫秒、400毫秒、200毫秒。也可以传入毫秒数。 fadeIn()和fadeOut()与show()方法不同的是，这两个方法只改变不透明度。fadeOut()方法会在指定的一段时间内降低元素的不透明度，直到display:none。fadeIn()方法则相反。 slideUp()和slideDown()改变元素的高度，如果一个元素是display:none，当调用slideDown()时，这个元素将由上至下延伸显示。slideUp()方法正好相反。元素将由下至上缩短隐藏。 以上几种动画第一个参数是速度，都可以传&#39;slow&#39;、&#39;normal&#39;、&#39;fast&#39;参数或者直接传入毫秒数。第二个参数是easing，是动画的运动方式，可选&#39;swing&#39;、&#39;linear&#39;分别是慢-快-慢和匀速。第三个参数是callback回调函数。 自定义动画animate()常用格式为animate(params,speed,easing,callback)。 params:一个包含样式属性及值的对象。例如{top:&#39;200px&#39;,left:&#39;200px&#39;} speed:速度参数，可选参数。 easing:设置动画的节奏，可选值是swing慢-快-慢和linear匀速，可选参数。 callback:在动画完成时执行的函数，可选参数。 定义一个普通的动画123$('#box').click(function()&#123; $(this).animate(&#123;left:'500px'&#125;,3000);&#125;) 累加、累减动画123$('#box').click(function()&#123; $(this).animate(&#123;left:'+=500px'&#125;,3000);&#125;) 在当前位置累加500px;当然也可以累减。 多重动画同时改变元素的高度的位置。 123456$('#box').click(function()&#123; $(this).animate(&#123; left:'500px', height:'200px' &#125;,3000);&#125;) 先改变元素的位置，移动完成后再改变元素的高度。在left执行完之前不会改变height的值。这种有先后顺序执行的动画称为动画队列。 1234567$('#box').click(function()&#123; $(this).animate(&#123; left:'500px' &#125;,3000).animate(&#123; height:'200px' &#125;,3000);&#125;) 这里如果在最后直接写.css(...)，那么会不等动画执行，直接执行css的改变。css()方法不会加入队列，只有动画的方法才能加入队列。如果想让非动画方法方法加入队列就要写在回调函数里。 停止动画格式为：stop([clearQueue],[gotoEnd]) clearQueue和gotoEnd都是可选参数，布尔值。 clearQueue代表是否要清空未执行完的动画队列。gotoEnd代表是否将正在执行的动画跳转到末状态。 判断动画执行状态使用animate要避免动画重复累计的执行，可以提前进行判断。 123if(!$('#box')is(':animate'))&#123; // 如果没有动画正在执行就加入新动画。&#125; 延迟动画在动画执行过程中，如果想延迟执行，可以使用delay()方法。可以将队列中的函数延迟执行，参数是毫秒值。 123456789$('#box').click(function()&#123; $(this).animate(&#123; left:'500px' &#125;,3000) .delay(1000) .animate(&#123; height:'200px' &#125;,3000);&#125;) 用于交互的动画方法toggle()格式为：toggle(speed,easing,callback) toggle()方法可以切换元素的可见状态。如果元素是可见的，则切换为隐藏的；如果元素是隐藏的，则切换为可见的。相当于先后执行了show()和hide()。 slideToggle()格式为：slideToggle(speed,easing,callback) 通过高度变化来切换匹配元素的可见性，这个动画效果只调整元素的高度。相当于先后执行了slideUp()和slideDown()方法。 可以设置参数speed、callback。 fadeTo()格式为：fadeTo(speed,opacity,easing,callback) 把元素的不透明度以渐进的方式调整到指定的值。只调整元素的不透明度。 fadeToggle()格式为：fadeToggle(speed,easing,callback) 通过不透明度来切换匹配元素的可见性，只能调整不透明度，相当于先后执行了fadeOut()和fadeIn()方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》四、jQuery的事件]]></title>
      <url>%2F2017%2F07%2F06%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E5%9B%9B%E3%80%81jQuery%E7%9A%84%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[加载DOMjQuery中$(document).ready()方法运行时代表DOM已经加载完毕，用此方法代替window.onload方法可以极大地提高web应用程序的响应速度。 此方法的另一种写法是$(function(){})。 事件绑定使用bind()来进行事件绑定。格式为bind( type,[data],fn )。 第一个参数是事件类型，不需要加on。 第二个参数是可选参数，是传递给事件对象的额外数据对象。 第三个参数是事件处理函数。 123$('#box').bind('click',function()&#123; &#125;) 还有一种简写方式 123$('#box').click(function()&#123; &#125;) bind()还可以为一个元素绑定多个事件：$(&#39;#box&#39;).bind(&#39;mouseover mouseout&#39;,function(){})。 合成事件hover()用于模拟光标悬停事件，格式为hover(enter,leave)，当光标移动到元素上时，会触发指定的第一个函数，当光标移出这个元素时，会触发指定的第二个函数。 12345$('#box').hover(function()&#123; // 光标移入&#125;,function()&#123; // 光标移出&#125;) toggle()用于模拟鼠标连续单击事件，格式为toggle(fn1,fn2...fnN)，第一次单机触发指定的第一个函数，再点击同一元素时，触发第二个函数，如果有更多函数则依次触发直到最后一个函数，随后的每次单机都重复对这几个函数的轮番调用 1234567$('#box').toggle(function()&#123; // 第一次点击&#125;,function()&#123; // 第二次点击&#125;,function()&#123; // 第三次点击，下次点击将从第一次开始&#125;) 这个方法还有另一种用法，可以切换元素的可见状态，如果元素是可见的，点击后则为隐藏，如果是隐藏的，点击后则为可见的。 12345$('#box').toggle(function()&#123; $(this).next().toggle();&#125;,function()&#123; $(this).next().toggle();&#125;) 事件冒泡通过事件对象的stopPropagation()方法来阻止事件冒泡。 123$('span').bind('click',function(event)&#123; event.stopPropagation();&#125;) jQuery中并不支持事件捕获 阻止默认行为通过事件对象的preventDefault()方法来阻止元素的默认行为。 有时候元素的默认行为需要阻止，比如阻止链接的跳转和阻止表单的提交，此时就需要用到此方法。 123$('span').bind('click',function(event)&#123; event.preventDefault();&#125;) 如果既需要阻止冒泡也需要阻止默认行为，可以在事件处理函数中简写为return false。 事件对象的属性jQuery对事件对象进行了封装，不存在兼容性问题，下面介绍几个常用的属性 event.type该方法的作用是可以获取到事件的类型 123$('#box').click(function(event)&#123; console.log(event.type) // 打印'click'&#125;) event.preventDefault()阻止默认的事件行为 event.stopPropagation()阻止事件的冒泡行为 event.target获取到触发事件的元素 123$('#box').click(function(event)&#123; console.log(event.target) // 打印整个$('#box')元素&#125;) event.reatedTarget获取比如mouseover和mouseout事件发生所相关的元素，对于mouseout，event.relatedtarget指向将进入的页面元素；而mouseover, 指向的是刚掠过的页面元素。 和event.target的区别是，一个是触发事件的主体元素，一个是存在过渡的事件的相关主体之一。 event.pargeX和event.pageY获取到光标相对于页面的x坐标和y坐标 event.which在鼠标点击事件中获取到鼠标的左、中、右键，在键盘相关事件中获取键盘的按键。 1234567$('#box').mousedown(function(event)&#123; console.log(event.which) // 1=鼠标左键 2=鼠标中键 3=鼠标右键&#125;)$('#box').keydown(function(event)&#123; console.log(event.which) // 获取按下的那个按键&#125;) event.metaKey在键盘事件中获取ctrl按键。 移除事件通过unbind()方法来移除元素的方法，格式为unbind([type],[data]) 第一个参数是事件类型，第二个参数是将要移除的函数 如果没有参数则删除所有绑定事件 如果提供了事件类型作为参数，则只删除该类型的绑定事件。 如果把在绑定时传递的处理函数作为第二个参数，则只有这个特定的事件处理函数会被删除。 1234567$('#box').bind('click',fun1 = function()&#123; // 绑定一个点击事件&#125;)$('#btn').click(function()&#123; $('#box').unbind('click',fun1); // 删除绑定函数fun1 &#125;) 另外jQuery还提供了一种简写方法，当事件处理函数触发一次后，立即删除，就是one()方法，使用方法和bind()相同。 模拟操作常用模拟以上的事件都是需要用户去操作才能触发的，jQuery中还可以模拟用户的操作，可以使用trigger()方法完成模拟操作。 $(&#39;#btn&#39;).trigger(&#39;click&#39;);这样就模拟了点击事件，也可以直接简写为$(&#39;#btn&#39;).click(); trigger(type,[data])方法有两个参数，第一个参数是要出发的事件类型，第二个参数是要传递给事件处理函数的附加数据，以数组形式传递。通常可以通过传递一个参数给回调函数来区别这次事件是代码触发的还是用户触发的。 12345$('#btn').click(function(event,msg1,msg2)&#123; alert(msg1 + msg2); // 页面加载时打印12,&#125;)$('#btn').trigger('click',['1','2']) trigger()方法有一个问题，那就是会触发事件的浏览器默认行为，比如$(&#39;input&#39;).trigger(&#39;focus&#39;);，我想触发表单的focus事件处理函数，但是不想真的让表单获取焦点，这时就可以使用triggerHandler()方法，$(&#39;input&#39;).triggerHandler(&#39;focus&#39;);这样既会触发表单的获取焦点的处理函数，还不会让表单获取焦点。 事件的命名空间可以把为元素绑定的多个事件类型用命名空间规范起来。 123456789101112131415$('#box').bind('click.plugin',function()&#123; &#125;)$('#box').bind('mouseover.plugin',function()&#123; &#125;)$('#box').bind('dbclick',function()&#123; &#125;)$('#btn').click(function()&#123; $('#box').unbind('.plugin'); // 删除$('#box')元素带有.plugin命名空间的事件&#125;) 这样添加命名空间后，在删除事件时只需要删除指定命名空间即可，没有指定该命名空间的事件不会被删除。 命名空间还有另外一种用法，元素绑定相同的事件类型，然后以命名空间的不同可以按需调用。 123456789101112$('#box').bind('click',function()&#123; &#125;)$('#box').bind('click.pligin',function()&#123; &#125;)$('#btn').click(function()&#123; $('#box').trigger('click!');&#125;) 如果点击$(&#39;#box&#39;)会同时触发click事件和click.plugin事件。如果点击$(&#39;#btn&#39;)元素则只触发click事件，因为trigger(&#39;click!&#39;);中的叹号是匹配所有不包含命名空间的方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》三、jQuery的DOM操作]]></title>
      <url>%2F2017%2F07%2F03%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B8%89%E3%80%81jQuery%E7%9A%84DOM%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[插入节点append()向每个匹配的元素内部追加内容 $(&#39;p&#39;).append(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;);结果为&lt;p&gt;一个p元素&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;。 appendTo()将所有的匹配元素追加到指定的元素中，和append是相反的。$(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).appendTo(&#39;p&#39;);结果为&lt;p&gt;一个p元素&lt;b&gt;你好&lt;/b&gt;&lt;/p&gt;。 prepend()向每个匹配的元素内部前置内容 $(&#39;p&#39;).prepend(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;) 结果为 &lt;p&gt;&lt;b&gt;你好&lt;/b&gt;一个p元素&lt;/p&gt;。 prependTo()将所有匹配的元素前置到指定的元素中。和prepend是相反的。 $(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).prependTo(&#39;p&#39;) 结果为 &lt;p&gt;&lt;b&gt;你好&lt;/b&gt;一个p元素&lt;/p&gt;。 after()在每个匹配的元素之后插入内容。$(&#39;p&#39;).after(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;) 结果为 &lt;p&gt;一个p元素&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; insertAfter()将所有匹配的元素插入到指定元素的后面，和after是相反的。$(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).insertAfter(&#39;p&#39;) 结果为 &lt;p&gt;一个p元素&lt;/p&gt;&lt;b&gt;你好&lt;/b&gt; before()在每个匹配的元素之前插入内容。 $(&#39;p&#39;).before(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;) 结果为 &lt;b&gt;你好&lt;/b&gt;&lt;p&gt;一个p元素&lt;/p&gt; insertBefore()将所有匹配的元素插入到指定的元素的前面，和before是相反的。$(&#39;&lt;b&gt;你好&lt;/b&gt;&#39;).insertBefore(&#39;p&#39;) 结果为 &lt;b&gt;你好&lt;/b&gt;&lt;p&gt;一个p元素&lt;/p&gt; 删除节点remove()删除匹配元素本身和所有后代节点。返回值是所有删除的节点的引用，因此可以在以后再使用这些删除的元素。 $(&#39;ul li:eq(1)&#39;).remove() 获取第2个&lt;li&gt;元素节点后，将它从网页中删除。 该方法还可以传递参数，通过参数选择性的删除元素。 $(&#39;ul li&#39;).remove(&#39;li[title!=&quot;菠萝&quot;]&#39;); 将&lt;li&gt;元素中属性title不等于菠萝的&lt;li&gt;元素删除。 detach()和remove()一样也是从DOM中去掉匹配的元素，但是不会从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。和remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。 empty()empty()并不是删除节点，而是清空节点，清空匹配元素的所有后代节点。 $(&#39;ul li:eq(1)&#39;).empty() 获取第2个&lt;li&gt;元素节点后，清空此元素里的内容。 复制节点clone()通过clone()克隆一个节点，默认不可隆节点的事件，需要传参数true就可以同时复制节点中绑定的事件。 替换节点replaceWith() 和 replaceAll()替换节点是replaceWith()和replaceAll()。如果在替换之前，已经为元素绑定事件，替换后原先绑定的事件将会与被替换的元素一起消失，需要在新元素上重新绑定事件。 $(&#39;p&#39;).replaceWith(&#39;&lt;span&gt;替换为span元素&lt;/span&gt;&#39;) 将页面中的p元素替换为span元素。 $(&#39;&lt;span&gt;替换为span元素&lt;/span&gt;&#39;).replaceAll(&#39;p&#39;) 用span元素去替换页面中的p元素。 包裹节点wrap()将匹配的每个元素用其他标记包裹起来，而且它不会破坏原始文档的语义。 $(&#39;strong&#39;).wrap(&#39;&lt;b&gt;&lt;/b&gt;&#39;); 用&lt;b&gt;标签把&lt;strong&gt;元素包裹起来。结果为&lt;b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/b&gt; &lt;b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/b&gt; &lt;b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;/b&gt;。 wrapAll()将所有匹配的元素用一个标签包裹起来。 $(&#39;strong&#39;).wrapAll(&#39;&lt;b&gt;&lt;/b&gt;&#39;); 用&lt;b&gt;标签把页面中所有&lt;strong&gt;元素包裹起来。结果为&lt;b&gt;&lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt; &lt;strong&gt;&lt;/strong&gt;&lt;/b&gt;。 wrapInner()将匹配的每个元素的子内容用其他标签包裹起来。 $(&#39;strong&#39;).wrapAll(&#39;&lt;b&gt;&lt;/b&gt;&#39;); 元素&lt;strong&gt;内的内容被一对&lt;b&gt;标签包裹了。结果为`&lt;strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/strong&gt; &lt;strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/strong&gt; &lt;strong&gt;&lt;b&gt;&lt;/b&gt;&lt;/strong&gt;。 属性操作attr()和prop()用于获取和设置属性，只传一个参数是获取一个属性的值，传两个参数是设置属性，要设置多个属性可以传入一个对象。 prop()比较适合用于设置和获取html元素的固有属性，而attr()比较适合设置和获取自定义属性。 最主要的区别是表单元素的属性，比如checked和selected，这也是固有属性，这种通常我会希望如果没有设置或者用户操作没有选中则返回false，设置了或者选中了则返回true。 1234// 用input这个标签举例子来看一下两者主要区别&lt;input type="checkbox" name="" id="ipt"/&gt;console.log($("input").attr("checked")) // 打印undefinedconsole.log($("input").prop("checked")) // 打印false 123&lt;input type="checkbox" name="" id="ipt" checked/&gt;console.log($("input").attr("checked")) // 打印checkedconsole.log($("input").prop("checked")) // 打印true removeAttr()和removeProp()只需要传一个参数，要删除的属性名。 removeAttr()会删除整个属性，而remobeProp()只会让该属性的值变为undefined，而且removeProp()对自定义属性无效。 样式操作addClass()此方法用来追加样式，在匹配元素原有类名基础之上追加一个类名，$(&#39;p&#39;).addClass(&#39;active&#39;) removeClass()删除类名，当不传参数时是删除匹配元素对象的所有类名，$(&#39;p&#39;).removeClass();就是删除所有p元素的所有类名。 也可以删除指定类名，$(&#39;p&#39;).removeClass(&#39;high&#39;);删除所有p元素的high类名。 toggleClass()替换类名，即如果传入的类名存在便删除，如果不存在就追加，$(&#39;p&#39;).toggleClass(&#39;active&#39;) hasClass()判断匹配的元素对象中是否还有某个类名，返回的是布尔值，$(&#39;p&#39;).hasClass(&#39;active&#39;) 设置和获取内容html()用于读取和设置匹配元素的html内容，和innerHTML方法的效果类似。不传参数即是获取。 text()用于读取和设置匹配元素的文本内容，和innerText方法类似，但是text()兼容所有浏览器，而innerText不兼容firefox。 val()用于读取和设置文本框、下拉列表、单选框、多选框元素的值，其中如果元素为多选，则会返回一个包含所有选择的值的数组。 如果不传参数则是获取值，传入参数是设置元素的值，由于val()专门针对表单元素，所以可以对下拉列表、单选框、多选框进行操作。 12$('#multiple').val('选项二'); //让下拉列表默认选择第二个选项，参数就是选项的文本内容$(':checbox').val(['check2','check3']) // 多选框，默认选择第二和第三项，多个参数用数组形式设置。 遍历节点children()此方法用来获取匹配元素的所有子元素的个数，这个方法只考虑子元素而不考虑后代元素。 next()获取匹配元素后面紧邻的同辈元素。 prev()获取匹配元素前面紧邻的同辈元素。 siblings()获取匹配元素前后所有的同辈元素，不包含自己。 closest()获取最近的匹配元素，首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则逐级向上查找直到找到匹配元素，如果什么都没找到返回一个空jQuery对象。 parent()、parents()parent()是获取匹配元素的父级元素，只返回一个节点。 parents()是获取匹配元素的祖先元素，返回多个节点。 find()搜索所有匹配元素下的指定的元素。 filter()获取匹配元素中符合参数表达式的元素，和find()不同的是find()是去后代中匹配，而filter()是在当前元素中去匹配。 还可以传入一个函数，函数内部return一个判断表达式，若为true，则返回表达式匹配的元素。 nextAll()获取匹配元素之后的所有同辈元素 prevAll()获取匹配元素之前的所有同辈元素 CSS-DOMcss()传入一个css属性就可以获取匹配元素的css属性值，不论行内还是外部引用的都可以获取。 传入两个参数，第一个是属性，第二个是属性值则可以设置匹配元素的css样式，也可以直接传入一个对象。对于带-符号的属性要用驼峰的写法，并且属性最好加上引号。 width()、height()直接获取匹配元素的宽度和高度，不带单位，而且这里获取的宽高和css设置无关，是元素在页面中实际的宽高。 也可以传递一个值设置高度和宽度，值的格式是字符串。 offset()获取元素在当前视窗的相对偏移，返回值是一个对象，即top和left，只对可见元素有效。 position()获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，也是返回一个对象并且又top和left。 scrollTop()、scrollLeft()获取元素的滚动条距顶端的距离和距左侧的距离。 可以给这两个方法指定一个参数，控制元素的滚动条滚动到指定位置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》二、jQuery的选择器]]></title>
      <url>%2F2017%2F06%2F13%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%BA%8C%E3%80%81jQuery%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[基本选择器 选择器 描述 返回 示例 #id 根据给定的id匹配一个元素 单个元素 $(&#39;#test&#39;)选取id为test的元素 .class 根据给定的类名匹配元素 集合元素 $(&#39;.test&#39;)选取所有class为test的元素 element 根据给定的元素名匹配元素 集合元素 $(&#39;p&#39;)选取所有&lt;p&gt;元素 * 匹配所有元素 集合元素 $(&#39;*&#39;)选取所有元素 selector1,selector2…` 将每个选择器匹配到的元素合并后一起返回 集合元素 $(&#39;div,span,p.myClass&#39;)选取所有&lt;div&gt;``&lt;span&gt;和拥有class为myClass的&lt;p&gt;标签的一组元素 层次选择器层次选择器用来获取后代元素、子元素、相邻元素和同级元素等。 选择器 描述 返回 示例 $(‘ancestor descendant’) 选取ancestor元素里所有的descendant(后代)元素 集合元素 $(&#39;div span&#39;)选取&lt;div&gt;里的所有的&lt;span&gt;元素 $(‘parent&gt;child’) 选取parent元素下的child(子)元素 集合元素 $(&#39;div&gt;span&#39;)选取&lt;div&gt;元素下元素名是&lt;span&gt;的子元素 $(‘prev + next’) 选取紧接在prev元素后的next元素 单个元素 $(&#39;.one + div&#39;)选取class为one的下一个&lt;div&gt;同级元素，可以用$(&#39;.one&#39;).next(&#39;div&#39;)代替 $(‘prev~siblings’) 选取prev元素之后的所有siblings元素 集合元素 $(&#39;#two~div&#39;)选取id为two的元素后面的所有&lt;div&gt;同级元素，可以用$(&#39;#two&#39;).nextAll(&#39;div&#39;)代替 过滤选择器通过特定的过滤规则来选定元素。 基本过滤选择器 选择器 描述 返回 示例 :first 选取第一个元素 单个元素 $(&#39;div:first&#39;)选取所有&lt;div&gt;元素中第1个&lt;div&gt;元素 :last 选取最后一个元素 单个元素 $(&#39;div:last&#39;)选取所有&lt;div&gt;元素中的最后一个&lt;div&gt;元素 :not(selector) 去除所有与给定选择器匹配的元素 集合元素 $(&#39;input:not(.myClass)&#39;)选取class不是myClass的&lt;input&gt;元素 :even 选取索引是偶数的所有元素 集合元素 $(&#39;input:even&#39;)选取索引是偶数的&lt;input&gt;元素 :odd 选取索引是奇数的所有元素 集合元素 $(&#39;input:odd&#39;)选取索引是奇数的&lt;input&gt;元素 :eq(index) 选取索引等于index的元素 单个元素 $(&#39;input:eq(1)&#39;)选取索引等于1的&lt;input&gt;元素 :gt(index) 选取索引大于index的元素(不包括index本身) 集合元素 $(&#39;input:gt(1)&#39;)选取索引大于1的&lt;input&gt;元素 :lt(index) 选取索引小于index的元素(不包括index本身) 集合元素 $(&#39;input:lt(1)&#39;)选取索引小于1的&lt;input&gt;元素 :header 选取所有标题元素 集合元素 $(&#39;:header&#39;)选取网页中所有标题元素 :animated 选取当前正在执行动画的所有元素 集合元素 $(&#39;div:animated&#39;)选取正在执行动画的&lt;div&gt;元素 :focus 选区当前获取焦点的元素 集合元素 $(&#39;:focus&#39;)选取当前获取焦点的元素 内容过滤选择器 选择器 描述 返回 示例 :contains(text) 选取含有文本内容为’text’的元素 集合元素 $(&#39;div:contains(&#39;我&#39;)&#39;)选取含有文本’我’的&lt;div&gt;元素 :empty 选取不包含子元素或者文本的空元素 集合元素 $(&#39;div:empty&#39;)选取不包含子元素(包含文本元素)的&lt;div&gt;空元素 :has(selector) 选取含有选择器所匹配的元素的元素 集合元素 $(&#39;div:has(p)&#39;)选取还有&lt;p&gt;元素的&lt;div&gt;元素 :parent 选取含有子元素或者文本的元素 集合元素 $(div:parent)选取拥有子元素(包含文本元素)的&lt;div&gt;元素 可见性过滤选择器 选择器 描述 返回 示例 :hidden 选取所有不可见的元素 集合元素 $(&#39;:hidden&#39;)选取所有不可见的元素，包括visibility:hidden、display:none、type=&#39;hidden&#39; :visible 选取所有可见的元素 集合元素 $(&#39;div:visible&#39;)选取所有可见的&lt;div&gt;元素 属性过滤选择器 选择器 描述 返回 示例 [attribute] 选取拥有此属性的元素 集合元素 $(&#39;div[id]&#39;)选取拥有属性id的&lt;div&gt;元素 [attribute=value] 选取属性的值为value的元素 集合元素 $(&#39;div[title=test]&#39;)选择属性title为’test’的&lt;div&gt;元素 [attribute!=value] 选取属性的值不等于value的元素 集合元素 $(&#39;div[title!=test]&#39;)选取属性title不等于’test’的&lt;div&gt;元素(没有title属性的元素也会被选取) [attribute^=value] 选取属性的值以value开始的元素 集合元素 $(&#39;div[title^=test]&#39;)选取属性title以’test’开始的&lt;div&gt;元素 [attribute$=value] 选取属性的值以value结束的元素 集合元素 $(&#39;div[title$=test]&#39;)选取属性title以’test’结束的&lt;div&gt;元素 [attribute*=value] 选取属性的值含有value的元素 集合元素 $(&#39;div[title*=test]&#39;) 选取属性title含有’test’的&lt;div&gt;元素 [attribute¦=value] 选取属性等于给定字符串或以该字符串为前缀(该字符串后跟一个连字符’-‘的元素) 集合元素 $(div[title¦=’en’])选取title属性等于en或以en为前缀的&lt;div&gt;元素 [attribute~=value] 选取属性用空格分隔的值中包含一个给定值的元素 集合元素 $(div[title~=&#39;uk&#39;])选取属性title用空格分隔的值中包含字符uk的元素 [attributeN] 用属性选择器合并成一个复合属性选择器，满足多个条件。每选择一次，缩小一次范围 集合元素 $(&#39;div[id][title$=&#39;test&#39;]&#39;)选取拥有属性id，并且属性title以’test’结束的&lt;div&gt;元素 子元素过滤选择器 选择器 描述 返回 示例 :nth-child(index/even/odd/equation) 选取每个父元素下的第index个子元素或者奇偶元素(index从1算起) 集合元素 :eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的，而:eq(index)是从0算起的 :first-child 选取每个父元素的第1个子元素 集合元素 :first只返回单个元素，而:first-child选择符将为每个父元素匹配第1个子元素。例如$(&#39;ul li:first-child&#39;);选取每个&lt;ul&gt;中第1个&lt;li&gt;元素 :last-child 选取每个父元素的最后一个子元素 集合元素 区别和上面相同，$(&#39;ul li:last-child&#39;);选取每个&lt;ul&gt;中最后一个&lt;li&gt;元素 :only-child 如果某个元素是它父元素中唯一的子元素，那么将会被匹配。如果父元素中含有其他元素，则不会被匹配 集合元素 $(ul li:only-child)在&lt;ul&gt;中选取是惟一子元素的&lt;li&gt;元素 表单属性过滤选择器 选择器 描述 返回 示例 :enabled 选取所有可用元素 集合元素 $(&#39;#form1 :enabled&#39;);选取id为form1的表单内所有可用的元素 :disabled 选取所有不可用元素 集合元素 $(&#39;#form1 :disabled&#39;);选取id为form2的表单内的所有不可用的元素 :checked 选取所有被选中的元素 集合元素 $(&#39;input:checked&#39;);选取所有被选中的&lt;input&gt;元素 :selected 选取所有被选中的选项元素 集合元素 $(select option:selected);选取所有被选中的选项元素 表单选择器为了使用户能够更加灵活的操作表单，可以使用表单选择器，更加方便的获取到表单的某个类型的元素。 选择器 描述 返回 示例 :input 选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;button&gt;元素 集合元素 $(&#39;:input&#39;)选取所有&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;button&gt;元素 :text 选取所有的单行文本框 集合元素 $(&#39;:text&#39;)选取所有的单行文本框 :password 选取所有的密码框 集合元素 $(&#39;:password&#39;)选取所有的密码框 :radio 选取所有的单选框 集合元素 $(&#39;:radio&#39;)选取所有的单选框 :checkbox 选取素有的多选框 集合元素 $(&#39;:checkbox&#39;)选取素有的多选框 :submit 选取所有的提交按钮 集合元素 $(&#39;:submit&#39;)选取所有的提交按钮 :image 选取所有的图像按钮 集合元素 $(&#39;:image&#39;)选取所有的图像按钮 :reset 选取所有的重置按钮 集合元素 $(&#39;:reset&#39;)选取所有的重置按钮 :button 选取所有的按钮 集合元素 $(&#39;:button&#39;)选取所有的按钮 :file 选取所有的上传域 集合元素 $(&#39;:file&#39;)选取所有的上传域 :hidden 选取所有不可见元素 集合元素 $(&#39;:hidden&#39;)选取所有不可见元素 使用选择器的注意事项含有’·’、’#’、’(‘或’]’等特殊字符碰到id或者class属性值带有这些特殊字符的需要转译之后才能使用，不能直接写 $(&#39;#box#b&#39;)这种不经过转译的写法是错误的，应该写为$(&#39;#box\\#b&#39;)，通过\\进行转译。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《锋利的jQuery》一、认识jQuery]]></title>
      <url>%2F2017%2F06%2F13%2F%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E3%80%8B%E4%B8%80%E3%80%81%E8%AE%A4%E8%AF%86jQuery%2F</url>
      <content type="text"><![CDATA[window.onload和$(document).ready()window.onload：必须等网页中所有的内容加载完毕后(包括图片)才能执行，不能同时编写多个。 $(document.ready())：网页中所有DOM结构绘制完毕后就执行，可能DOM元素关联的东西并没有加载完，可以同时编写多个，可以简写为$(function(){}) jQuery对象和DOM对象的转换jQuery转为DOM对象有两种方法，即[index]和get(index)。 123var box = $('#box')[0];var box1 = $('#box1').get(0); DOM转为jQuery对象,只需要用$()把DOM对象包装起来,$()就是一个jQuery对象的制造工厂。 123var box = document.getElementById('box');var $box = $(box); $快捷方式的更改$是jQuery的快捷方式，为防止冲突，也可以自定义这个快捷方式。 交给其他js库假如jQuery库在其他库之后引入，在其他库和jQuery库加载完成后就可以使用jQuery.noConflict()将变量$的控制权交给其他js库，如果先引入jQuery就不需要jQuery.noConflict()方法，直接写$即可。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery.noConflict(); // 将变量$的控制权移交给prototype.js jQuery(function()&#123; // 使用jQuery jQuery('p').click(function()&#123; alert( jQuery(this).text() ) &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 防止$冲突第一种方法：想确保jQuery不会与其他库冲突，可以自定义一个快捷方式。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; var $j = jQuery.noConflict(); // 自定义一个快捷方式 $j(function()&#123; // 利用刚自定义的快捷方式使用jQuery $j('p').click(function()&#123; alert($j(this).text()); &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 第二种方法：如果不想自定义名称，同时又想避免冲突可以这样。 12345678910111213141516171819&lt;body&gt; &lt;p id="pp"&gt;Test-prottype&lt;/p&gt; &lt;p&gt;Test-jQuery&lt;/p&gt; &lt;!--引入prototype--&gt; &lt;script src="lib/prototype.js"&gt;&lt;/script&gt; &lt;!--引入jQuery--&gt; &lt;script src="../jquery1.9.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery.noConflict(); // 将变量$的控制权移交给prototype.js jQuery(function($)&#123; // 将$通过参数传入 $('p').click(function()&#123; alert($(this).text()); &#125;) &#125;) $('pp').style.display = 'none'; // 使用prototype隐藏元素 &lt;/script&gt;&lt;/body&gt; 判断是否获取到了某元素在原生javascript中通过这样来判断页面中是否有这个元素 123if(document.getElementById('tt'))&#123; document.getElementById('tt').style.color = 'red';&#125; 在jQuery中因为$()获取的是一个对象，所以不能直接判断这个对象是否存在 123if($('#tt'))&#123; // 这里将永远判断为true，因为jQuery对象一直存在&#125; 应该这样判断 123if($('#tt').length &gt; 0)&#123; &#125; 或者 123if($('#tt')[0])&#123; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》六、充实文档内容]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%85%AD%E3%80%81%E5%85%85%E5%AE%9E%E6%96%87%E6%A1%A3%E5%86%85%E5%AE%B9%2F</url>
      <content type="text"><![CDATA[这一章将继续在实践中应用动态创建标记 1、不应该做什么从技术上讲，可以把任何内容动态添加到网页上，但重要的内容不要这么做，因为这样一来，javascript就没有任何空间去平稳退化，如果缺乏javascript的支持，用户会永远看不到重要的内容，而且各大搜索引擎也不支持javascript。 渐进增强和平稳退化两项原则要牢记在心，在这里再次总结一下这两项重要的原则。 渐进增强应该从最核心的部分，也就是从内容开始，应该根据内容使用标记实现良好的结构，然后再逐步加强这些内容，这些增强工作既可以是通过css改进呈现效果，也可以是通过DOM添加各种行为，如果你正在使用DOM添加核心内容，那么添加的时机未免太迟，核心内容应在刚开始写文档时就成为文档的组成部分。 平稳退化渐进增强的实现必然支持平稳退化，如果你按照渐进增强的原则去充实内容，你为文档添加的样式和行为自然就支持平稳退化。那些缺乏必要的css和DOM支持的访问者仍可以访问到你的核心内容，如果用javascript去添加这些内容，它就没法支持平稳退化，不支持javascript就看不到内容。 2、内容和往常一样，任何网页都以内容为出发点，现在拿下面这段内容作为出发点。 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;解释文档DOM&lt;/title&gt; &lt;style&gt; body &#123; font-family:'Helvetica','Arial',sans-serif; font-size: 10pt; &#125; abbr &#123; text-decoration: none; border: 0; font-style: normal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;什么是DOM&lt;/h1&gt; &lt;p&gt;&lt;abbr title="万维网联盟"&gt;W3C&lt;/abbr&gt;将&lt;abbr title="文档对象模型"&gt;DOM&lt;/abbr&gt;定义为:&lt;/p&gt; &lt;blockquote cite="http://www.w3.org/DOM/"&gt; &lt;p&gt;一个平台和语言中立的接口，将允许程序和脚本动态访问和更新的内容，结构和风格的文档。&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;这是一个&lt;abbr title="应用程序设计接口"&gt;API&lt;/abbr&gt;可以用来浏览&lt;abbr title="超文本标记语言"&gt;HTML&lt;/abbr&gt;和&lt;abbr title="可扩展标记语言"&gt;XML&lt;/abbr&gt;文档。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;abbr&gt;标签用于缩略语的显示，默认情况会显示为带有下划线或下划点，但是通过css的设置已经代替了浏览器的默认样式。 &lt;abbr&gt;的title属性在浏览器里是隐藏的，有些浏览器会在你把鼠标指针悬停在缩略语上时，将它的title属性显示为一个弹出式的提示消息，这也是浏览器所使用的默认行为，而不同浏览器的默认样式也不尽相同。所以就像刚才用css样式去代替浏览器默认样式那样，我们也可以用DOM去改变浏览器的默认行为。 3、显示缩略语下面我要做的是将&lt;abbr&gt;标签中的title属性集中起来显示在一个页面，我希望得到的定义列表是这个样子： 123456789101112&lt;dl&gt; &lt;dt&gt;W3C&lt;/dt&gt; &lt;dd&gt;万维网联盟&lt;/dd&gt; &lt;dt&gt;DOM&lt;/dt&gt; &lt;dd&gt;文档对象模型&lt;/dd&gt; &lt;dt&gt;API&lt;/dt&gt; &lt;dd&gt;应用程序设计接口&lt;/dd&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言&lt;/dd&gt; &lt;dt&gt;XML&lt;/dt&gt; &lt;dd&gt;可扩展标记语言&lt;/dd&gt;&lt;/dl&gt; 用DOM来具体实现这个定义列表的步骤如下： 遍历这份文档中的所有&lt;abbr&gt;元素。 保存每个&lt;abbr&gt;元素的title属性。 保存每个&lt;abbr&gt;元素包含的文本。 创建一个&lt;dl&gt;自定义列表元素。 遍历刚才保存的title属性和&lt;abbr&gt;元素的文本。 创建一个&lt;dt&gt;标题元素。 把&lt;abbr&gt;元素的文本插入到这个&lt;dt&gt;元素。 创建一个&lt;dd&gt;列表项元素。 把title属性插入到这个&lt;dd&gt;元素。 把&lt;dt&gt;元素追加到第4步创建的&lt;dl&gt;元素上。 把&lt;dd&gt;元素追加到第4步创建的&lt;dl&gt;元素上。 把&lt;dl&gt;元素追加到explanation.html文档的body元素上。 按照上面的思路我将编写一个displayAbbreviations函数，并存入Enrich_document_content.js中。 1234567891011121314151617181920212223242526272829303132333435363738394041function displayAbbreviations()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有缩略词 var abbreviations = document.getElementsByTagName('abbr'); if(abbreviations.length &lt; 1) return false; var defs = new Array(); // 便利这些缩略词 for(var i = 0;i &lt; abbreviations.length; i++)&#123; var current_abbr = abbreviations[i]; var definition = current_abbr.getAttribute('title'); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; &#125; // 创建定义列表 var dlist = document.createElement('dl'); // 遍历定义 for(key in defs)&#123; var definition = defs[key]; // 创建定义标题 var dtitle = document.createElement('dl'); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); // 创建定义描述 var ddesc = document.createElement('dd'); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; // 创建标题 var header = document.createElement('h2'); var header_text = document.createTextNode('缩略词'); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 现在已经可以在页面显示出这个定义列表，不要忘记使用addLoadEvent函数加载。下面解析一下这个函数。 第一步仍然是检查我用到的DOM方法是否被支持。 第二步是遍历获取到的所有&lt;abbr&gt;元素，为了防止html中没有&lt;abbr&gt;元素，所以在遍历之前也做了检查，避免javascript报错。 第三步用数组保存&lt;abbr&gt;元素的文本和title属性，当一个元素中只有一个子节点，用lastChild获取其子节点是一个好的方法，这里将文本作为数组的下标使用，将字符串作为数组的下标也是一种常用的方式，不要被数组的下标通常为数字就被禁锢住想法。 第四步用for…in循环，去遍历之前的数组，for…in是遍历用字符串作为下标的数组的首选，将下标(key)和下标对应的值(value)添加到&lt;dt&gt;和&lt;dl&gt;元素中。 第五步是将这个定义列表和标题插入到body中，这一步没什么特别的。 4、displayAbbreviations函数的兼容性问题按理说这个函数即检查了方法、又全部使用的DOM方法，应该不存在兼容性问题，但问题还是有，就是有的浏览器不支持&lt;abbr&gt;元素，如果是这样那么不仅没有缩略语列表，还会导致javascript报错。 出现这个隐患，如果现在去替换&lt;abbr&gt;元素太过麻烦，不论何时，要替换html中的元素都不应该作为首选。所以保证displayAbbreviations函数在IE中能够平稳退化没这个方案实现起来最简单，也就是如果浏览器不支持&lt;abbr&gt;元素就可以提前退出。 接下来要解决这个兼容性问题，做到平稳退化，我要在第一个for循环中加入一个判断。if(current_abbr.childNodes.length &lt; 1) continue;这条语句会让当前元素没有子节点的话就进入下一次循环，不支持&lt;abbr&gt;元素的浏览器在统计&lt;abbr&gt;元素的子节点个数总会返回错误值。 此时因为defs数组是空的，所以它将不会创建出任何&lt;dt&gt;和&lt;dd&gt;元素，在for…in循环之后，写一个函数出口，if(dlist.childNodes.length &lt; 1) return false;如果dlist没有子节点，那么直接跳出函数，这样就避免了报错的可能性。以下是改进后的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243function displayAbbreviations()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有缩略词 var abbreviations = document.getElementsByTagName('abbr'); if(abbreviations.length &lt; 1) return false; var defs = new Array(); // 便利这些缩略词 for(var i = 0;i &lt; abbreviations.length; i++)&#123; var current_abbr = abbreviations[i]; if(current_abbr.childNodes.length &lt; 1) continue; var definition = current_abbr.getAttribute('title'); var key = current_abbr.lastChild.nodeValue; defs[key] = definition; &#125; // 创建定义列表 var dlist = document.createElement('dl'); // 遍历定义 for(key in defs)&#123; var definition = defs[key]; // 创建定义标题 var dtitle = document.createElement('dl'); var dtitle_text = document.createTextNode(key); dtitle.appendChild(dtitle_text); // 创建定义描述 var ddesc = document.createElement('dd'); var ddesc_text = document.createTextNode(definition); ddesc.appendChild(ddesc_text); // 把它们添加到定义列表 dlist.appendChild(dtitle); dlist.appendChild(ddesc); &#125; if(dlist.childNodes.length &lt; 1) return false; // 创建标题 var header = document.createElement('h2'); var header_text = document.createTextNode('缩略词'); header.appendChild(header_text); // 把标题添加到页面主体 document.body.appendChild(header); // 把定义列表添加到页面主体 document.body.appendChild(dlist);&#125; 如果浏览器不支持&lt;abbr&gt;标签，也不会出任何错误，但是也会看不到缩略语列表，不过缩略语列表也算不上页面必不可少的组成部分，如果真的是必不可少的内容，从一开始就应该把它包括在标记里。 5、显示文献来源链接表在这个案例中，还有另一个增强文档的例子，先来看看html中这段标记。 123&lt;blockquote cite="http://www.w3.org/DOM/"&gt; &lt;p&gt;一个平台和语言中立的接口，将允许程序和脚本动态访问和更新的内容，结构和风格的文档。&lt;/p&gt;&lt;/blockquote&gt; &lt;blockquote&gt;元素包含一个cite属性，它可以是一个URL地址，告诉人们&lt;blockquote&gt;元素的内容引自哪里，从理论上讲这是一个文献资料与县官网页链接起来的好办法。但实际上浏览器会完全忽略cite属性，所以我要把这些信息收集起来，以一种更有意义的方式把它们显示在网页上。 按照以下步骤完成displayCitetions函数，并存入Enrich_document_content.js文件中。 遍历这个文档里所有&lt;blockquote&gt;元素。 从&lt;blockquote&gt;元素提取出cite属性的值。 创建一个标识文本是source的链接。 把这个链接赋值为&lt;blockquote&gt;元素的cite属性值。 把这个链接插入到文献节选的末尾。 1234567891011121314151617181920212223242526272829function displayCitetions()&#123; if(!document.getElementsByTagName || !document.createElement || !document.createTextNode)&#123; return false; &#125; // 取得所有引用 var quotes = document.getElementsByTagName('blockquote'); // 遍历引用 for(var i = 0;i &lt; quotes.length;i++)&#123; // 如果没有cite属性，继续循环 if(!quotes[i].getAttribute('cite')) continue; // 保存cite属性 var url = quotes[i].getAttribute('cite'); // 取得引用中的所有元素节点 var quoteChildren = quotes[i].getElementsByTagName('*'); // 如果没有元素节点进入下一次循环 if(quoteChildren.length &lt; 1) continue; // 取得引用中的最后一个元素节点 var elem = quoteChildren[quoteChildren.length - 1]; // 创建标记 var link = document.createElement('a'); var link_text = document.createTextNode('source'); link.appendChild(link_text); link.setAttribute('href',url); var superscript = document.createElement('sup'); superscript.appendChild(link); // 把标记添加到引用中的最后一个元素节点 elem.appendChild(superscript) &#125;&#125; 函数执行完毕后这个&lt;blockquote&gt;元素的引用将会添加到段落最后的source上标中。下面来解析一下这个函数。 第一部分是筛选出cite属性，再去获取&lt;blockquote&gt;元素的最后一个子节点，这里&lt;blockquote&gt;的lastChild有可能是个换行符，所以在函数中是获取的&lt;blockquote&gt;下的所有元素对象，这样就可以方便的获取&lt;blockquote&gt;的最后一个子元素。 第二部分是创建链接和插入链接，最终让&lt;sup&gt;元素包含&lt;a&gt;元素，而&lt;a&gt;元素href属性保存了cite的属性值，也就是一个url地址。最后将&lt;sup&gt;元素插入到&lt;blockquote&gt;元素的最后。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》五、动态创建标记]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%BA%94%E3%80%81%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[这一章节主要通过一些DOM方法，通过创建新元素和修改现有元素来改变网页结构，用DOM的方法改变标记。 1、创建元素节点和文本节点DOM是文档的表示，DOM所包含的信息与文档里的信息一一对应，你只要学会问正确的问题，就可以从获取DOM节点上任何一个节点的细节。 DOM是一条双向车道，不仅可以获取文档的内容，还可以更新文档的内容，如果改变了DOM节点树，文档在浏览器里的呈现就会发生变化，所以与其说是创建标记，不如说是在改变DOM节点树，在DOM的角度来看，一个文档就是一颗节点树，如果想在节点树上添加内容，就必须插入新的节点，如果想添加一些标记文档，就必须插入元素节点。 比如现有一个HTML元素&lt;div id = &quot;testdiv&quot;&gt;&lt;/div&gt;，我要在其中插入一段文本，需要4个步骤。 创建一个新的元素。 把这个新的元素插入节点树。 创建一个文本节点。 把文本节点插入新元素的节点树。 1234567window.onload = function()&#123; var pare = document.createElement('p'); var testdiv = document.getElementById('testdiv'); testdiv.appendChild(pare); var txt = document.createTextNode('Hello World'); pare.appendChild(txt);&#125; 这些代码会在页面上显示”Hello World”，并且包含在&lt;div id = &quot;testdiv&quot;&gt;&lt;/div&gt;中。 首先用document.createElement方法创建一个&lt;p&gt;元素，创建以后&lt;p&gt;元素还不是任何一颗DOM树的组成部分，它只是游荡在javascript世界里的一个孤儿，这种情况被称为文档碎片(document frogment)，不过，这时&lt;p&gt;元素已经有了自己的DOM属性，比如nodeType和nodeName。 现在要让&lt;p&gt;元素成为testdiv的一个子节点，appendChild方法可以完成这一任务，这个方法的语法是parent.appendChild(child)。 最后我要给&lt;p&gt;元素增加文本内容，也就是创建一个文本节点并让其成为&lt;p&gt;元素的子节点，使用document.createTextNode方法可以实现，用法和document.createElement相同，同样这个本文节点也是一个孤儿节点，需要使用appendChild添加到&lt;p&gt;元素中。 其实我也可以改变上面的执行顺序，先创建两个节点，再依次加入DOM树中也是一样的。 2、重回图片库案例现在图片库的html文件中有一个图片和一段文字仅仅是为showPic脚本服务的，既然这些元素的存在只是为了让DOM方法处理它们，那么用DOM方法来创建它们才是最合适的选择。动态创建需要完成的步骤如下： 创建一个img元素节点。 设置这个节点的id属性、src属性、alt属性。 创建一个p元素节点。 创建这个节点的id属性。 创建一个文本节点。 把这个本文节点追加到p元素上。 把p元素和img元素插入到gallery.html文档。 1234567891011121314151617function preparePlaceholder()&#123; if(!document.createElement) return false; if(!document.createTextNode) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var placeholder = document.createElement('img'); placeholder.setAttribute('id','placeholder'); placeholder.setAttribute('src','images/placeholder.gif'); placeholder.setAttribute('alt','my image gallery'); var description = document.createElement('p'); description.setAttribute('id','description'); var desctext = document.createTextNode('Chose an image'); description.appendChild(desctext); var gallery = document.getElementById('imagegallery'); insertAfter(placeholder,gallery); insertAfter(description,placeholder);&#125; 现在我可以将html中图片展示的元素和文字描述的元素删除了。 为了确保退路，函数的第一部分仍是检测浏览器是否支持这些方法，这里主要说一下insterAfter方法，它的功能是把一个节点插入到另一个节点之后，DOM本身并没有提供这个方法，所以我们可以自己编写一个函数。 12345678function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 这个函数的步骤如下： 这个函数有连个参数，第一个是要插入的新元素，第二个是目标元素。 获取目标元素的父元素，存到parent变量。 检测目标元素是不是其父元素的最后一个元素。 如果是就用appendChild把新元素追加到parent元素上。 如果不是就把新元素插入到目标元素和其下一个兄弟元素之间，使用nextSibling属性获取这个元素的下一个兄弟元素，使用insertBefore方法把下一个元素插入到另一个元素之前，语法是parentElement.insertBefore(newElement,targetElement)。 3、AjaxAjax主要用于异步加载页面内容的技术，用Ajax可以做到只更新页面的一小部分，不必刷新整个页面。 Ajax的优势就是对页面的请求以异步的方式发送到服务器，而服务器不会用整个页面来相应请求，它会在后台处理请求，与此同时用户还能继续浏览页面并与页面交互，而脚本则可以按需加载内容。 XMLHttpRequest对象Ajax技术的核心就是XMLHttpRequest对象，这个对象充当着浏览器中的脚本与服务器之间的中间人的角色，以往的请求都是浏览器发出，而javascript通过这个对象也可与自己发送请求，同时也自己处理响应。 不同浏览器对实现XMLHttpRequest对象方式不太一样，为了解决兼容性问题，我们可以自己封装一个函数。 1234567891011121314151617function getHttpObject()&#123; if(typeof XMLHttpRequest == 'undefind')&#123; XMLHttpRequest = function()&#123; try&#123; return new ActiveXObject('Msxml2.XMLHTTP6.0'); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject('Msxml2.XMLHTTP3.0'); &#125;catch(e)&#123;&#125; try&#123; return new ActiveXObject('Msxml2.XMLHTTP'); &#125;catch(e)&#123;&#125; return false; &#125; &#125; return new XMLHttpRequest();&#125; 这个函数通过对象检测技术检测了XMLHttpRequest，如果失败则继续检测其他方法，最终返回一个false或新的XMLHttpRequest对象。 其中ActiveXObject是IE的实现方法，实现了一个名叫XMLHTTP的对象，IE版本中使用的XMLHTTP对象也不完全相同。 XMLHttpRequest发送请求的方法XMLHttpRequest对象有许多的方法，下面通过一个新的函数来具体看XMLHttpRequest的执行过程和方法，这里假设example.txt是接口的地址 1234567891011121314function getNewContent()&#123; var request = getHttpObject(); if(request)&#123; request.open('GET','example.txt',true); request.onreadystatechange = function()&#123; if(request.readyState == 4)&#123; var txt = request.responseText; &#125; &#125; request.send(null); &#125;else&#123; alert('你的浏览器不支持XMLHttpRequest') &#125;&#125; 首先最有用的就是open方法，用open方法来指定服务器上要访问的文件、指定请求类型、指定请求是否以异步的方法发送和处理。 onreadystatechange方法会在服务器给出回应的时候被触发执行，在这个函数中，可以根据服务器的具体响应做相应的处理。 send方法用于发送数据，通常写在指定请求的目标并明确如何处理响应之后。 服务器回响XMLHttpRequest的方法服务器在向XMLHttpRequest对象发送回响时，该对象有许多属性可用。 readyState属性，浏览器会在不同阶段更新readyState属性的值。 0 表示未初始化。 1 表示正在加载。 2 表示加载完毕。 3 表示正在交互。 4 表示完成。 所以只要readyState属性的值变为4，就可以访问服务器发送回来的数据了。 responseText和responseXML属性用于保存服务器发送回来的数据，responseText用于保存文本字符形式的数据，responseXML用于保存Content-Type头部中制定为’text/xml’的数据。 另外，只要是依赖于服务器响应的脚本，都要写在onreadystatechange属性的函数中，因为在发送XMLHttpRequest请求之后，脚本仍然会继续执行，不会等待响应返回，如果把依赖服务器返回内容的代码写在onreadystatechange之后，可能会导致这些代码执行了但数据还没有获取到。send方法就是最好的证明，它会优先于onreadystatechange执行。 Ajax应用的一个特色就是减少重复加载页面的次数，但这种缺少状态记录的技术会与浏览器的一些使用惯例产生冲突，导致用户无法使用后退按钮或者无法为特定状态下的页面添加书签，理想情况，用户每一次操作都应该得到一个清晰明确的结果，为此，web设计人员必须在向服务器发出请求和服务器返回相应时，给用户明确提示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》四、图片库改进]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E5%9B%9B%E3%80%81%E5%9B%BE%E7%89%87%E5%BA%93%E6%94%B9%E8%BF%9B%2F</url>
      <content type="text"><![CDATA[在这一章主要是用上一章的思想改进图片库，所以我会把之前的javascript图片库案例拿来看看是不是符合上一章所说的规则。 1、支持平稳退化吗？可以确定，图片库如果禁用了javascript功能，也已经留了退路，网页里的所有链接都是可用的，虽然用户体验游影响，但网页的功能并未受到损害，而如果当时在href中写的不是链接而是伪协议或是’#’，那么禁用javascript后它会无法使用。 2、javascript与html分离吗？在图片库中它们确实是混在了一起，onclick直接插入到了html中，理想情况下，应该在外部文件里添加onclick事件处理函数。 我需要编写一个简短的函数把有关操作关联到onclick事件上，我想让函数完成以下工作： 检查浏览器是否理解getElementsTagByName。 检查浏览器是否理解getElementById。 检查网页是否存在一个id为imagegallery的元素。 遍历imagegalery元素中的所有链接。 设置onclick事件，让它在有关链接被点击时完成以下操作。 把这个链接作为参数传递给showPic函数。 取消链接被点击时的默认行为。 12345678910111213function prepareGallery()&#123; if(!document.getElementsByTagName) return false; if(!document.getElementById) return false; if(!document.getElementById('imagegallery')) return false; var gallery = document.getElementById('imagegallery'); var links = gallery.getElementsByTagName('a'); for(var i = 0; i &lt; links.length; i++)&#123; links[i].onclick = function()&#123; showPic(this); return false; &#125; &#125;&#125; 为了方便获取元素，我将&lt;ul&gt;的id设为’imagegallery’。 函数的第一部分是检查点，如果不支持或没有检查的内容就离开，其实也可以写为if(!document.getElementsByTagName || !document.getElementById) return false;将两个检查写到一起，但是这样写代码太过冗长不利于阅读，所以将代码写在一行并不一定是个好主意。 代码中我用变量名存储获取到的元素，避免了代码写得太长，在给变量起名时，应该选择一些有意义的单词来命名，可以让代码更容易阅读和理解，并且一定要避免使用保留字和函数或方法名。 函数的最后是一个遍历，links存储了列表中的所有a元素，并且是一个伪数组，所以可以遍历得到每个a元素并且将onclick事件绑定给该元素，这样绑定之后，该事件处理函数的this就是绑定该事件的元素，至此可以从html中彻底删除onclick事件了。 3、共享onload事件现在我还需要一个功能，就是要在DOM树加载完之后再执行上面的prepareGallery函数，如果只有一个函数用window.onload = prepareGallery即可，但如果有多个函数，就不能直接这样写，后面的会覆盖前面的，所以我还要再写一个函数完成这个绑定功能。 把现有的window.onload事件处理函数的值存入变量oldonload。 如果在这个处理函数上还没有绑定函数，就像平时那样把新函数添加给它。 如果在这个处理函数上已经绑定了函数，就把新函数追加到现有指令的末尾。 1234567891011function addLoadEvent(func)&#123; var oldonload = window.onload; if(typeof window.onload != 'function')&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; oldonload(); func(); &#125; &#125;&#125; 这个函数将把那些在页面加载完毕时执行的函数创建一个队列，参数func就是要执行的函数。 4、不要做太多的假设下面我要改造一下showPic函数，因为我发现showPic函数并没有任何检查和测试，所以需要一些语句来检查这些元素是否存在。 showPic函数负责完成两件事： 找出id属性是placeholder的图片并修改其src属性。这个是核心功能，必须完成的任务。 找出id属性是description的元素并修改其第一个子元素的nodeValue属性。这个功能只是锦上添花，所以只要placeholder图片存在，即使description元素不在，切换显示新图片的操作也将照常进行。 123456789101112function showPic(whichpic) &#123; if(!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src", source); if(document.getElementById('description'))&#123; var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text; &#125; return true;&#125; 现在这个函数完成了检测，只要图片可以正常获取就返回true，但是还有一个问题，就是如果把placeholder图片从标记文档里删掉，无论点击imagegallery清单里的哪一个链接，都没有任何反应，这不符合平稳退化，此时应该让浏览器打开那个被点击的链接，而不是什么都不发生。 导致这个问题的原因是prepareGallery函数中是假设showPic肯定会切换图片成功，基于这一点才取消了a元素onclick事件的默认行为links[i].onclick = function(){showPic(this);return false;}，但是现在在showPic中，如果图片切换成功才返回true，如果图片切换失败会返回false。所以如果showPic返回了false就不应该取消点击事件，而是该让a元素的链接正常打开，让切换图片的操作照常进行。所以是否取消默认行为应该由showPic函数决定。 为了达到这个目的，应该先验证showPic的返回值，以便决定是否阻止默认行为，如果showPic返回true，那么更新placeholder，取消默认事件。如果showPic返回false，那么就不取消默认事件。在onclick事件处理函数中，我们可以利用逻辑非来对showPic的返回值进行取反。 123links[i].onclick = function()&#123; return !showPic(this);&#125; 现在这个函数已经相当完善，虽然它们的长度有所增加，但它们对标记的依赖和假设已经比原来少多了，尽管如此，在showPic函数里仍存在一些需要处理的假设。 如果a元素的title属性存在，变量text将被赋值a元素的title属性，如果不存在，变量text将被赋值为一个空字符串。 假设placeholder元素是否是一张图片，可以用nodeName属性来测试，要注意的是，nodeName属性总是返回的值总是大写字母。 假设description元素的第一个子元素是一个文本节点，可以用nodeType属性来检测，如果nodeType的值是3，就是一个文本节点。 123456789101112131415function showPic(whichpic) &#123; if (!document.getElementById('placeholder')) return false; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); if (placeholder.nodeName != 'IMG') return false; placeholder.setAttribute("src", source); if (document.getElementById('description')) &#123; var text = whichpic.getAttribute('title') ? whichpic.getAttribute('title') : ''; var description = document.getElementById('description'); if(description.firstChild.nodeType == 3)&#123; description.firstChild.nodeValue = text; &#125; &#125; return true;&#125; showPic的代码变得更多了，在实际中，你需要自己决定是否真的需要这些检查，它们针对的是html文档有可能不再你的控制范围内的情况，但理想情况下，脚本不应该对html文档的内容和结构做太多假设。 5、键盘访问事件前面的代码只能用鼠标操作，而浏览器web页面也是可以用键盘进行操作的，有个名叫onkeypress的事件处理函数就是专门用来处理键盘事件的，按下键盘的任何一个按键都会触发onkeypress事件。 如果想把onkeypress事件加到上面的案例并完成和onclick相同的操作，只需要这样写links[i].onkeypress = links[i].onclick;，但是在这个案例中我认为并不需要键盘访问事件，有onclick事件足矣，我想说的是，在这里完全体现出了javascript和html分离带来的方便，如果像是最开始那样把javascript写在html中，将不得不去修改每行html语句，而现在只要在javascript代码中加一条语句即可。 6、DOM Core和HTML-DOM至此，我在编写javascript代码时只用到了以下几个DOM方法：getElementById、getElementsByTagName、getAttribute、setAttribute。 这些方法都是DOM Core的组成部分，它们并不是专属javascript语言，支持DOM的任何一种程序设计语言都可以使用它们，它们的用途也并非仅限于处理网页，它们可以用来处理任何一种标记语言(比如XML)编写出来的文档。像onclick属于HTML-DOM，它们在DOM Core出现之前很久就已经为人们所熟知，比如HTML-DOM提供了一个forms对象，写法是document.forms可以代替document.getElementsByTagName(forms)。还有element.src可以代替element.getAttribute。 它们的区别是HTML-DOM只能处理web文档，我使用DOM Core也是因为其兼容多种类型的文档，其实这个完全是根据使用场景来选择，并没有绝对的对错之分。 7、增加css1234567891011121314151617181920212223242526272829303132333435363738394041424344body &#123; font-family: "Helvetica","Arial",serif; color: #333; background-color: #ccc; margin: 1em 10%;&#125;h1 &#123; color: #333; background-color: transparent;&#125;a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none;&#125;ul &#123; padding: 0;&#125;li &#123; float: left; padding: 1em; list-style: none;&#125;img&#123; display: block;&#125;#imagegallery &#123; list-style: none; overflow: hidden;&#125;#imagegallery li &#123; display: inline;&#125;#imagegallery li a img &#123; border: 0;&#125; 8、把图片的文字链接改为缩略图12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" type="" href="./css/style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul id="imagegallery"&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" title = "A fireworks display"&gt; ![](images/thumbnail_fireworks.jpg) &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" title = "A cup of black offee"&gt; ![](images/thumbnail_coffee.jpg) &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" title = "A red,red rose"&gt; ![](images/thumbnail_rose.jpg) &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigben.jpg" title = "The famous clock"&gt; ![](images/thumbnail_bigben.jpg) &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = "placeholder" src = "images/placeholder.gif" alt = "my image galley"/&gt; &lt;p id="description"&gt;Choose an image&lt;/p&gt; &lt;script src="script/script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》三、最佳实践]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%B8%89%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[1、平稳退化和渐进增强什么是平稳退化不管你想通过javascript个改变哪个网页的行为，都必须三思而后行，首先要确认，为这个网页增加这种额外的行为是否有必要。 在所有的javascript特效当中，最臭名昭著的莫过于那些在人们打开网页时弹出的广告窗口，不幸的是有不少用户为此干脆彻底禁用了javascript，这是一个典型的滥用javascript的例子，从技术上讲弹窗解决了如何向用户发送信息，但在实践中，频繁弹出的广告窗口却让用户不胜其烦，令人欣慰的是这一问题已经收到了所有人的关注，那些不遵守用户至上原则的网站都在自取灭亡。 所以如果要使用javascript就要确认，这么做会对浏览体验产生怎样的影响，最重要的是，如果用户的浏览器不支持或禁用了javascript的情况下仍能顺利浏览你的网址，这就是平稳退化。虽然某些功能无法使用，但最基本的操作仍能顺利完成。 举个例子以弹出窗口的例子来说明平稳退化的思想。这里并不是指在加载网页时弹出，而是点击后弹出，例如服务条款，邮费列表等等。 javascript使用window.open(url,name,features)来创建新的浏览器窗口。 参数1：新窗口里页面的url地址，省略这个参数就是一个空白网页。 参数2：新窗口的名字，代码可以通过这个名字与新窗口交互。 参数3：以逗号分隔的字符串，包括新窗口尺寸(工具条、菜单条、初始显示位置等等)。 123function popUp(winURL)&#123; window.open(winURL,"popup","width=320,height=480");&#125; 这个函数将打开一个320x480像素的新窗口”popup”。 使用popUp函数的一个办法是使用伪协议。 真协议用来在因特网上的计算机之间传输数据包，比如HTTP、FTP协议等，协议则是一种非标准化的协议。 1&lt;a href = "javascript:popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 通过”javascript:”为协议调用popUp()函数。 1&lt;a href = "#" onclick = "popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 这是内嵌式的事件处理函数，这个链接的href没什么用，所以用”#”，表示一个空连接，实际工作由onclick完成。 但是以上两种方法都很糟糕，因为它们都不能平稳退化。有以下两点原因。 用户如果禁用了javascript功能，这样的链接将毫无作用。 第二点是不利于搜索引擎排名，搜索机器人浏览web页的目的是把各种网页添加到搜索引擎的数据库，很少有机器人能理解javascript代码。 其实为javascript代码预留退路很简单，给href设置真实的URL地址。 1&lt;a href = "http://www.example.com/" onclick = "popUp('http://www.example.com/');return false;"&gt;Example&lt;/a&gt; 这样即使javascript被禁用，这个链接也不是失效的，只是功能上打了点折扣，这是一个经典的平稳退化的例子。 渐进增强所谓”渐进增强”就是用一些额外的信息层去包裹原始数据，按照”渐进增强”原则创建出来的网页几乎都符合”平稳退化”原则，在一个网页中，良好的内容就是一切，只有正确的使用标记语言才能对内容做出准确的描述，CSS指令构成了一个表示层使文档呈现出各种模式，但即使去掉这个表示层，文档的内容也依然可以访问。 2、分离javascript就像css那样把style写到html文档中，虽然可以用，但是这种做法弊大于利，最好的方法是把样式信息存入一个外部文件。在文档的head部分用&lt;link&gt;标签调用这个文件，这样更容易阅读和理解，样式信息也更容易更改，不用去文档里逐一搜索和替换，这个结论同样适用于javascript。 现在我要把上面弹窗例子中的onclick事件分离出来。具体步骤如下： 把文档里的所有链接全放入一个数组里。 遍历数组。 如果某个链接的class属性等于popup，就表示这链接在被点击时应该调用popUp()函数 1234567891011121314window.onload = function()&#123; if(!document.getElementsByTagName) return false; var links = document.getElementsByTagName('a'); if(links.length &gt; 0)&#123; for(var i = 0;i &lt; links.length;i++)&#123; if(links[i].getAttribute('class') == 'popup')&#123; links[i].onlcick = function()&#123; popUp(this.getAttribute('href')); return false; &#125; &#125; &#125; &#125;&#125; 以上代码把调用popUp()函数添加到有关的链接上，存入一个外部javascript文件中。 这里使用了window.onload事件，当onload事件触发时代表整个文档已经加载完毕，当然也包括DOM树，我要让HTML文档先加载这样才可以生成DOM树，起码要在DOM树生成后才可以加载javascript文件，否则获取不到文档中的各个元素，即使把javascript文件放到body的底部，也不能保证哪个先加载结束，浏览器可能一次加载多个文件，因为javascript加载时文档可能还没加载完成，所以DOM也没有加载完，很多功能会无法使用。 3、向后兼容性上面的代码中，针对访问者可能未启用javascript功能的情况，需要进行对象检测，在这里用if语句检测访问者的浏览器是否支持document.getElementsByTagName方法。如果不支持，就不会再继续执行，直接return false;这是一种很常见的向后兼容的方法，适用于很多地方。 4、性能考虑在上面案例的for循环开始前检测是否获取到了a元素，没有的话后面的代码也没必要执行，这里将所有a元素存入link变量。出入对性能考虑，我们应该检查查询DOM中某些元素的操作，搜索整个DOM树对性能并没有好处，总之把搜索结果保存在一个全局变量里，或者把一组元素直接以参数形式传递给函数，是最好的方法。 另外，js文件在HTML标签中的位置对页面初次加载时间也有很大影响，通常我习惯放在head中，但位于head中的脚本会导致浏览器无法并行加载其他文件。根绝HTTP规范，浏览器每次从一个域名中最多可能同时下载两个文件，所以把script标签放到文档末尾，之前可以让页面加载更快]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》二、javascript图片库]]></title>
      <url>%2F2017%2F06%2F03%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%BA%8C%E3%80%81javascript%E5%9B%BE%E7%89%87%E5%BA%93%2F</url>
      <content type="text"><![CDATA[从这一篇开始会逐步完成一个图片库的案例，但我们不能直接把所有的图片直接放到一个页面里，因为图片下载的时间较长，用户需要等待很长时间去加载一个网页，所以我们需要一个图片库，把整个图片库的浏览链接集中安排在主页里，只在用户点击了这个主页里的某个图片链接时才把相应的图片加载。 1、建立基础的HTML结构123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" title = "A cup of black offee"&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" title = "A red,red rose"&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigen.jpg" title = "The famous clock"&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 2、改进图片库这个网页现在的功能是： 清单列表中的每个链接分别指向不同的图片，点击跳转到相应的图片页面。 从图片返回列表要借助于浏览器的back功能。 需要改进的地方： 点击某个链接时，能留在这网页而不是转到另一个窗口。 点击某个链接时，能在这个网页上同时看到那张图片及原有清单列表。 点击某个链接时，在图片的下方显示改图片的描述文字。 完成上述目标要完成的几项改进： 通过增加一个占位图片的办法在这个主页上为图片预留一个浏览区域。 点击某个链接时，拦截这个网页的默认行为。把占位图片替换为与那个链接相对应的图片。 点击某个链接时，获取链接的描述文字，保存到图片下方的位置。 第一步、增加占位图片html部分 1&lt;img id = "placeholder" src = "images/placeholder.jpg" alt = "my image galley"/&gt; js部分 12345function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source);&#125; 为了把占位图片替换为要查看的图片，需要一个方法来改变它的src属性。参数whichpic代表一个指向某个图片的a元素，变量source是参数a元素的href属性值，变量placeholder是占位图片的元素对象。 我们还有另一种方法，也就是非DOM方法，直接用placeholder.src = source;，效果等同于placeholder.setAttribute(&quot;src&quot;,source);，我选择DOM方法的原因是setAttribute是第1级DOM，它的兼容性和可移植性更好，DOM本身适用于任何一种标记语言，DOM是一种适用于多种环境和多种程序设计语言的通用型API，而非DOM方法只能适用于web浏览器，所以在以后的选择时，尽量选择DOM方法。 最后将该方法单独存为一个叫做show_pic.js的文件并引用。在实际开发中，可以将多个功能放到一个js文件中，这样可以减少对站点的请求次数，提高性能。 1&lt;script src="script/script.js"&gt;&lt;/script&gt; 第二步、事件处理函数事件处理函数的作用是在特定事件发生时，调用特定的javascript代码。这个案例中要使用的是onclick点击事件。 1&lt;a href = "images/fireworks.jpg" onclick = "showPic(this);return false;" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; 在每一条链接上增加onlcick事件和处理程序。showPic就是之前写好的方法，将this作为参数传进去，this这里指的就是a元素对象。 return false的作用是阻止默认行为被调用，a元素的默认行为是打开一个新窗口，我不需要这个效果，所以要组织。 事件处理函数的工作机制：在给某个元素添加了事件处理函数后，一旦事件发生，javascript代码便会执行，这些被调用的javascript代码可以返回一个值，这个值将被传递给事件处理函数，具体到此案例中，当onclick被触发时，如果执行的代码返回true，onclick事件处理函数就会认为这个链接被点击了，如果返回false，onclick事件处理函数就认为这个链接没有被点击，所以当onclick认为没有点击链接，自然也不会打开一个新链接。 第三步、增加图片描述文字现在我要用DOM给图片增加一段描述，这段描述的位置在img标签之后，同时也起到了占位符的作用 1&lt;p id="description"&gt;Choose an image&lt;/p&gt; 为了实现这个功能也需要扩展一下showPic函数。 获取a标签的title属性值，并存入变量text。 获取描述文本的元素，id值为description的p元素，保存到变量description。 把description对象的第一个子节点的nodeValue属性值设置为变量text的值。 12345678function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source); var text = whichpic.getAttribute('title'); // 1 var description = document.getElementById('description'); // 2 description.firstChild.nodeValue = text; // 3&#125; 这里设置描述文本我使用的是nodeChild属性，nodeChild属性可以设置和获取文本元素的文本内容。需要注意的是必须是文本节点。 比如description是一个元素节点，那么description.nodeChild获取的就是null，用description的子节点才有效description.firstChild.nodeChild，这里description只有一个子节点并且是文本节点，所以使用firstChild和lastChild都一样，如果description有好几个子元素，要获取其中的某个可以用children[index]来获取。 最终效果最后我们增加一些css样式来美化一下页面,创建style.css文件并引入html文件中。 123456789101112131415161718192021222324252627282930313233body &#123; font-family: "Helvetica","Arial",serif; color: #333; background-color: #ccc; margin: 1em 10%;&#125;h1 &#123; color: #333; background-color: transparent; &#125;a &#123; color: #c60; background-color: transparent; font-weight: bold; text-decoration: none;&#125;ul &#123; padding: 0;&#125;li &#123; float: left; padding: 1em; list-style: none;&#125;img &#123; display: block; clear:both;&#125; 以下是script.js文件的最终内容 12345678function showPic(whichpic)&#123; var source = whichpic.getAttribute("href"); var placeholder = document.getElementById("placeholder"); placeholder.setAttribute("src",source); var text = whichpic.getAttribute('title'); var description = document.getElementById('description'); description.firstChild.nodeValue = text;&#125; html文件的最终结构如下 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt;&lt;head&gt; &lt;meta charset = "utf-8"/&gt; &lt;title&gt;Image Gallery&lt;/title&gt; &lt;link rel="stylesheet" type="" href="./css/style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Snapshots&lt;/h1&gt; &lt;ul&gt; &lt;li&gt; &lt;a href = "images/fireworks.jpg" onclick = "showPic(this);return false;" title = "A fireworks display"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/coffee.jpg" onclick = "showPic(this);return false;" title = "A cup of black offee"&gt;Coffee&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/rose.jpg" onclick = "showPic(this);return false;" title = "A red,red rose"&gt;Rose&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href = "images/bigben.jpg" onclick = "showPic(this);return false;" title = "The famous clock"&gt;Big Ben&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img id = "placeholder" src = "images/placeholder.gif" alt = "my image galley"/&gt; &lt;p id="description"&gt;Choose an image&lt;/p&gt; &lt;script src="script/script.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面的最终效果如下，点击i链接可以改变图片和描述文字。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《DOM编程艺术》一、DOM]]></title>
      <url>%2F2017%2F04%2F13%2F%E3%80%8ADOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E4%B8%80%E3%80%81DOM%2F</url>
      <content type="text"><![CDATA[1、DOM的含义 文档(D)，指的是document，当创建了一个网页并把它加载到web浏览器中时，DOM就在幕后悄然而生，DOM把我们编写的网页文档转换为一个文档对象。 对象(O)，指的就是javascript中的三种对象，用户定义对象、内建对象、宿主对象。 模型(M)，可以理解为模型Model或者地图Map，我们可以通过javascript代码来读取这张地图。 要理解模型或者地图的概念，首先我们要理解DOM是把一份文档表示为一棵树。以下面文档为例。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang = "en"&gt; &lt;head&gt; &lt;meta charset = "utf-8"&gt; &lt;title&gt;Shopping list&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;What to buy&lt;/h1&gt; &lt;p title = "a gentle reminder"&gt;Don't forget to buy this stuff&lt;/p&gt; &lt;ul id = "purchases"&gt; &lt;li&gt;A tin of beans&lt;/li&gt; &lt;li class = "sale"&gt;Cheese&lt;/li&gt; &lt;li class = "sale"&gt;Milk&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 上面的一长串代码可以理解为以下的DOM树 从上图可以看出，html永远是一个文档的开始，可以看作是树根，再深一层就是head和body，它们位于一层，所以是兄弟关系(sibling)，它们都有各自的子元素(child)，有着共同的父元素(parent)。 实际上用parent、silbling、child就可以代表整个DOM树的结构，比如ul是ul是body的child元素，而ul又是li的parent元素，ul和p是sibling元素，并且这棵树上的每个元素都是一个DOM节点。 2、节点上面介绍了DOM的概念，由图也可以看出，DOM树是由一个个节点组成的，这些就是DOM节点。分为三种类型。 元素节点 标签的名字就是元素节点，例如”p”、”ul”、”body”等等。 文本节点 被元素包括的文本内容就是文本节点，比如上面文档中被包含的”A tin of beans”。 属性节点 属性节点用来对元素做出更具体的描述，比如的title属性，也包括id和class属性，属性节点也总是被包含在元素节点内部。 那么我们如何区分这三种节点呢？可以使用nodeType属性。nodeType属性总共有12种可取值，但其中仅有3种有实用价值。 元素节点的nodeType属性值是1 属性节点的nodeType属性值是2 文本节点的nodeType属性值是3 实际使用中可以通过元素对象的nodeType属性值来判断节点类型。 3、获取元素有3种DOM方法可以获取元素节点，分别是通过元素id、通过标签名、通过class获取。 通过id名获取这个方法将返回一个与给定id属性值的元素节点对应的元素对象，它是document对象特有函数。1document.getElementById(&apos;box&apos;); 获取id属性值是’box’的元素对象。 这里一直再说元素对象这个概念，其实就是指的html元素，但是在DOM里html元素都是DOM节点。而DOM节点本身就是一个对象，所以叫做元素对象。另外函数和方法其实也是一个概念，对象的方法其实就是一个函数。 通过标签名获取这个方法返回一个对象数组，与getElementById不同的是，这个返回的是一个数组，返回的数组中，每个元素都是获取到的元素对象，可以用length属性查出这个数组的长度。 1document.getElementsByTagName('li'); 这个方法允许把一个通配符作为它的参数，可以获取文档里的所有元素，也可以和getElementById结合使用 12var box = document.getElementById('box');var lis = box.getElementsByTagName('*'); 这样可以获取id为box的元素下的所有元素对象。 通过class获取这是HTML5中新增的方法，可以通过class名获取元素，返回的也是一个对象数组。 1document.getElementsByClassName('sale important'); 获取class属性为sale和important的元素对象，这个元素必须同时有这两个class名，顺序无所谓。也可以和getElementById结合使用。 12var box = document.getElementById('box');var sales = box.getElementsByClassName('sale'); 获取id值为box的元素下的所有class名为sale的元素。 需要注意的是这个方法比较新，所以用的时候要小心，为了弥补这个不足，我们可以自己封装一个获取class名的方法以适用于旧版浏览器。 获取class名的兼容性处理 1234567891011121314function getElementsByClassName(node, className) &#123; if (node.getElementsByClassName) &#123; return node.getElementsByClassName(className); &#125; else &#123; var results = new Array(); var elems = node.getElementsByClassName('*'); for (var i = 0; i &lt; elems.length; i++) &#123; if (elems[i].className.indexOf(className) != -1) &#123; results[results.length] = elems[i]; &#125; &#125; return results; &#125;&#125; 这个函数接收两个参数，node表示搜索起点，className是要搜索的class名，这个方法不足的地方是不适用多个class名。 4、获取和设置属性已经了解了三种获取元素节点的方法，现在可以去获取它们的属性。 获取属性1234567var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; var title_text = paras[i].getAttribute('title'); if(title_text != null)&#123; alert(title_text); &#125;&#125; getAttribute用于获取属性，需要用元素节点去调用，参数是要获取的属性名，如果调用的元素节点里没有要查找的属性就会返回null。 设置属性12345var paras = document.getElementsByTagName('p');for(var i = 0;i &lt; paras.length;i++)&#123; paras[i].setAttribute('title','brand new title text'); alert(paras[i].getAttribute('title'));&#125; setAttribute用于设置属性，不管调用的元素原来有没有设置的属性，最终都会被设置上，用setAttribute对文档做出修改后，在浏览器中查看源代码仍是改变前的属性，这就是DOM的工作模式，对页面内容更新却不需要在浏览器里刷新。]]></content>
    </entry>

    
  
  
</search>
